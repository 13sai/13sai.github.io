{"meta":{"title":"13sai blog","subtitle":"13sai","description":"13sai blog，分享技术知识，不限于PHP、go、MySQL、Redis、linux、MQ、micro service。","author":"13sai","url":"http://github.13sai.com","root":"/"},"pages":[{"title":"分类","date":"2021-01-26T05:49:58.712Z","updated":"2021-01-26T05:49:58.711Z","comments":false,"path":"categories/index.html","permalink":"http://github.13sai.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-26T05:49:51.326Z","updated":"2021-01-26T05:49:51.326Z","comments":false,"path":"tags/index.html","permalink":"http://github.13sai.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-02-20T10:19:52.000Z","updated":"2021-07-31T12:56:58.768Z","comments":true,"path":"about/index.html","permalink":"http://github.13sai.com/about/index.html","excerpt":"","text":"2015年7月，材料专业毕业，校招入某传统国企，成为小白工程师。数月后，希望遇见更多可能性，毅然辞职前往南京。因为大学自学过前端知识和PHP，转行互联网，从事网站类开发工作，主要语言JS、PHP。2017年，前往杭州，专心于后端开发，业务涉及SAAS、CRM、O2O等，接触了更多WEB开发知识，Linux、Redis、MQ、VUE。2019年，入职游戏公司，支持游戏活动、内部运营平台，开始接触GO。2021年，回到南京，从事直播服务行业，GO工程师岗位，微服务架构，RPC、Kubernetes、CI/CD等。 电影，篮球，历史爱好者，摄影小白，乐器小白。 github：13sai 知乎专栏：技术无边界 微信公众号：程序员涛子"}],"posts":[{"title":"boltdb的使用","slug":"boltdb的使用","date":"2021-08-08T10:43:46.000Z","updated":"2021-08-08T11:03:56.042Z","comments":true,"path":"2021/08/08/361/","link":"","permalink":"http://github.13sai.com/2021/08/08/361/","excerpt":"","text":"Bolt is a pure Go key/value store inspired by Howard Chu’s LMDB project. The goal of the project is to provide a simple, fast, and reliable database for projects that don’t require a full database server such as Postgres or MySQL. bolt 是一个简单的kv数据库，使用及其简单，目前github项目处于只读状态。 数据库连接123456789101112131415161718package mainimport ( &quot;log&quot; &quot;github.com/boltdb/bolt&quot;)func main() &#123; // 文件不存在，会新建文件 db, err := bolt.Open(&quot;sai.db&quot;, 0600, nil) if err != nil &#123; log.Fatal(err) &#125; defer db.Close() ...&#125; 事务1234567891011// 读写err := db.Update(func(tx *bolt.Tx) error &#123; ... return nil&#125;)// 只读，里面只能进行读取操作err := db.View(func(tx *bolt.Tx) error &#123; ... return nil&#125;) 常用操作12345678910111213141516171819202122232425262728293031323334// 创建一个bucket，可以理解成一个tableb, _ := tx.CreateBucketIfNotExists([]byte(&quot;sai0556&quot;))// 新增b.Put([]byte(&quot;a&quot;), []byte(&quot;11&quot;))b.Put([]byte(&quot;b&quot;), []byte(&quot;22&quot;))// 取v := b.Get([]byte(&quot;a&quot;))fmt.Printf(&quot;The a is: %s\\n&quot;, v)// 删除b.Delete([]byte(&quot;a&quot;))// 游标遍历/*First() Move to the first key.Last() Move to the last key.Seek() Move to a specific key.Next() Move to the next key.Prev() Move to the previous key*/c := b.Cursor()for k, v := c.First(); k != nil; k, v = c.Next() &#123; fmt.Printf(&quot;key=%s, value=%s\\n&quot;, k, v)&#125;// ForEach 遍历b.ForEach(func(k, v []byte) error &#123; fmt.Printf(&quot;key=%s, value=%s\\n&quot;, k, v) return nil&#125;)// 删除buckettx.DeleteBucket([]byte(&quot;sai0556&quot;)) 使用很简单，但需要注意以下几点： 只读View中，不能使用编辑、删除、新增等写操作，会产生错误 因为底层使用了读写锁，进行写操作，要尽可能快，更不要开启长事务，会造成阻塞，影响性能 更多说明可参考： https://pkg.go.dev/github.com/boltdb/bolt@v1.3.1 https://github.com/boltdb/bolt","categories":[{"name":"db","slug":"db","permalink":"http://github.13sai.com/categories/db/"}],"tags":[{"name":"db","slug":"db","permalink":"http://github.13sai.com/tags/db/"}]},{"title":"nsq基础知识与简单demo","slug":"nsq小试牛刀","date":"2021-07-31T12:57:54.000Z","updated":"2021-07-31T15:07:42.001Z","comments":true,"path":"2021/07/31/360/","link":"","permalink":"http://github.13sai.com/2021/07/31/360/","excerpt":"","text":"NSQ A realtime distributed messaging platform 优势 基于golang 分布式 水平扩展 自带UI，操作友好 多语言client 组件 组件 功能 nsqd 接收、排队和向客户端传递消息的守护进程 nsqlookupd 管理拓扑信息的守护进程 nsqadmin Web UI，用于实时查看聚合的集群统计信息并执行各种管理任务 utilities 常见基础功能、数据流处理工具，如nsq_stat、nsq_tail、nsq_to_file、nsq_to_http、nsq_to_nsq、to_nsq nsqd它可以独立运行，但通常与nsqlookupd 实例一起配置在集群中（在这种情况下，它将宣布主题和频道以供发现）。 它侦听两个 TCP 端口，一个用于客户端，另一个用于 HTTP API。它可以选择在第三个端口上侦听 HTTPS。 nsqlookupd有两个接口：nsqd用于广播的TCP 接口和用于客户端执行发现和管理操作的 HTTP 接口。 MAC安装 brew install nsqnsqlookupdnsqd –lookupd-tcp-address=127.0.0.1:4160 –broadcast-address=127.0.0.1nsqadmin –lookupd-http-address=127.0.0.1:4161 go-nsq12345678910111213141516171819202122232425262728293031323334// producerpackage nsqimport ( &quot;context&quot; &quot;fmt&quot; &quot;time&quot; &quot;github.com/nsqio/go-nsq&quot; &quot;github.com/spf13/cast&quot;)// 主函数func Send(ctx context.Context, cancel context.CancelFunc, topic string) &#123; defer cancel() str := &quot;127.0.0.1:4150&quot; fmt.Println(&quot;address: &quot;, str) producer, err := nsq.NewProducer(str, nsq.NewConfig()) if err != nil &#123; panic(err) &#125; producer.SetLogger(nil, 0) for i := 0; i &lt; 5; i++ &#123; msg := &quot;13sai, &quot; + cast.ToString(i) fmt.Println(&quot;publish&quot;, msg, producer.Publish(topic, []byte(msg))) time.Sleep(time.Second * 1) &#125; &lt;-ctx.Done() producer.Stop() fmt.Println(&quot;producer exit&quot;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// consumerpackage nsqimport ( &quot;context&quot; &quot;fmt&quot; &quot;time&quot; &quot;github.com/nsqio/go-nsq&quot;)// 消费者type Consumer struct&#123;&#125;// 主函数func Receive(ctx context.Context, cancel context.CancelFunc, topic string) &#123; defer cancel() // address := &quot;127.0.0.1:4161&quot; channel := topic + &quot;-channel&quot; cfg := nsq.NewConfig() cfg.LookupdPollInterval = time.Second * 2 c, err := nsq.NewConsumer(topic, channel, cfg) if err != nil &#123; panic(err) &#125; c.SetLogger(nil, 0) //屏蔽系统日志 c.AddConcurrentHandlers(&amp;Consumer&#123;&#125;, 3) //建立NSQLookupd连接 // if err := c.ConnectToNSQLookupd(address); err != nil &#123; // panic(err) // &#125; //建立多个nsqd连接 if err := c.ConnectToNSQDs([]string&#123;&quot;127.0.0.1:4150&quot;&#125;); err != nil &#123; panic(err) &#125; &lt;-ctx.Done() c.Stop() fmt.Println(&quot;consumer exit&quot;)&#125;// 处理消息func (*Consumer) HandleMessage(msg *nsq.Message) error &#123; fmt.Println(&quot;receive&quot;, msg.NSQDAddress, &quot;message:&quot;, string(msg.Body)) return nil&#125; 12345678910111213141516171819202122232425262728293031323334353637// nsq_testpackage nsqimport ( &quot;context&quot; &quot;os&quot; &quot;os/signal&quot; &quot;syscall&quot; &quot;testing&quot; &quot;time&quot;)func TestReceive(t *testing.T) &#123; topic := &quot;sai0556&quot; ctx, cancel := context.WithCancel(context.Background()) defer cancel() go Send(ctx, cancel, topic) go Receive(ctx, cancel, topic) sig := make(chan os.Signal) signal.Notify(sig, syscall.SIGTERM, syscall.SIGINT) t.Log(&quot;开始监听&quot;) select &#123; case &lt;-ctx.Done(): t.Log(&quot;ctx done&quot;) return case &lt;-sig: t.Log(&quot;signal exit...&quot;) cancel() time.Sleep(2 * time.Second) return &#125; // send(topic)&#125; 测试走一波， 对于NSQ，自己也是刚刚使用，给我的感觉是相当好上手，之前有用过RabbitMQ，nsq相比来说更简单，可能是go-client相对好用一些吧。后续有其他值得分享的点再继续补充。如有需要交流，可联系我email/qq。 参考 nsq","categories":[{"name":"MQ","slug":"MQ","permalink":"http://github.13sai.com/categories/MQ/"}],"tags":[{"name":"nsq","slug":"nsq","permalink":"http://github.13sai.com/tags/nsq/"}]},{"title":"VSCode调试go程序","slug":"VSCode调试go程序","date":"2021-07-07T13:27:35.000Z","updated":"2021-07-07T13:44:55.315Z","comments":true,"path":"2021/07/07/355/","link":"","permalink":"http://github.13sai.com/2021/07/07/355/","excerpt":"","text":"在项目目录新建，.vscode/launch.json 1234567891011121314&#123; &quot;version&quot;: &quot;0.2.0&quot;, // 版本好 &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;app&quot;, // 名称 &quot;type&quot;: &quot;go&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;mode&quot;: &quot;auto&quot;, &quot;program&quot;: &quot;$&#123;cwd&#125;&quot;, &quot;env&quot;: &#123;&quot;DebugEnv&quot;:&quot;1&quot;&#125;, // 环境变量 &quot;args&quot;: [&quot;--config&quot;,&quot;./config-local.yaml&quot;, &quot;--listen&quot;, &quot;:8087&quot;] // 启动参数 &#125; ]&#125; 对于program: 1234567$&#123;workspaceRoot&#125; VSCode当前打开的文件夹$&#123;file&#125; 当前打开的文件$&#123;relativeFile&#125; 相对于workspaceRoot的相对路径$&#123;fileBasename&#125; 当前打开文件的文件名$&#123;fileDirname&#125; 所在的文件夹，是绝对路径$&#123;fileExtname&#125; 当前打开文件的拓展名，如.json$&#123;cwd&#125; 启动时任务运行程序的当前工作目录 然后运行-》启动调试，就能跑起来了，可以打断点调试了。 断点点击代码行左侧即可，还是很方便的。","categories":[{"name":"debug","slug":"debug","permalink":"http://github.13sai.com/categories/debug/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"使用ConfigMap作为容器的配置文件","slug":"使用ConfigMap作为容器的配置文件","date":"2021-06-26T03:48:54.000Z","updated":"2021-06-26T04:04:34.407Z","comments":true,"path":"2021/06/26/350/","link":"","permalink":"http://github.13sai.com/2021/06/26/350/","excerpt":"","text":"构建demo镜像自己制作个镜像方便测试。 go mod init k8s-configmap-demo main.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package mainimport ( &quot;fmt&quot; &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot; &quot;github.com/spf13/pflag&quot; &quot;github.com/spf13/viper&quot;)var ( conf = pflag.StringP(&quot;config&quot;, &quot;c&quot;, &quot;&quot;, &quot;config filepath&quot;))type Config struct &#123; Name string&#125;// 对外的初始化配置方法func configRun(cfg string) error &#123; c := Config&#123; Name: cfg, &#125; if err := c.init(); err != nil &#123; return err &#125; return nil&#125;func (c *Config) init() error &#123; if c.Name != &quot;&quot; &#123; viper.SetConfigFile(c.Name) &#125; else &#123; // 默认配置文件是./config.yaml viper.AddConfigPath(&quot;.&quot;) viper.SetConfigName(&quot;config&quot;) &#125; viper.SetConfigType(&quot;yaml&quot;) // viper解析配置文件 err := viper.ReadInConfig() if err != nil &#123; panic(fmt.Errorf(&quot;Fatal error config file: %s \\n&quot;, err)) &#125; return nil&#125;func main() &#123; pflag.Parse() // 初始化配置 if err := configRun(*conf); err != nil &#123; panic(err) &#125; gin.SetMode(viper.GetString(&quot;mode&quot;)) g := gin.New() g = LoadRoute(g) g.Run(viper.GetString(&quot;addr&quot;))&#125;func LoadRoute(g *gin.Engine) *gin.Engine &#123; g.Use(gin.Recovery()) // 404 g.NoRoute(func (c *gin.Context) &#123; c.String(http.StatusNotFound, &quot;404 not found&quot;); &#125;) g.GET(&quot;/&quot;, Index) return g&#125;// 返回type Response struct &#123; Code int `json:&quot;code&quot;` Message string `json:&quot;message&quot;` Data interface&#123;&#125; `json:&quot;data&quot;`&#125;// api返回结构func ApiResponse(c *gin.Context, code int, message string, data interface&#123;&#125;) &#123; c.JSON(http.StatusOK, Response&#123; Code: code, Message: message, Data: data, &#125;)&#125;func Index(c *gin.Context) &#123; ApiResponse(c, 0, &quot;success&quot;, viper.GetString(&quot;hi&quot;))&#125; 代码比较简单，读取config,运行一个gin http服务，返回配置项[hi]的字符串。 config.yaml 1234name: demo2mode: debugaddr: :8080hi: w~o~w Dockerfile 1234567FROM golang:alpineRUN mkdir /appWORKDIR /appCOPY ./hi /appCOPY ./config.yaml /appRUN chmod +x hiCMD [&quot;./hi&quot;] 构建： 12docker build -t app:0.2 .docker tag sai:0.2 13sai/sai:0.1 提交镜像到hub123docker logindocker push 13sai/sai:0.1 k8s的配置我使用的是Kuboard，下面的操作都是在Kuboard执行 ConfigMap配置创建ConfigMap:进入default空间 &gt; 资源 &gt; 配置字典： 名称 sai 配置数据名称 config.yaml 配置内容 config.yaml里的内容 创建负载配置可参照下面截图，注意几处： 数据卷 Volume，选择configMap 运行容器组pod的Command和挂载点 保存后即可。 最后贴出生成的yaml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235---apiVersion: apps/v1kind: Deploymentmetadata: annotations: deployment.kubernetes.io/revision: &#x27;10&#x27; k8s.kuboard.cn/ingress: &#x27;false&#x27; k8s.kuboard.cn/service: NodePort k8s.kuboard.cn/workload: web-test creationTimestamp: &#x27;2021-06-25T02:30:05Z&#x27; generation: 11 labels: k8s.kuboard.cn/layer: web k8s.kuboard.cn/name: web-test managedFields: - apiVersion: apps/v1 fieldsType: FieldsV1 fieldsV1: &#x27;f:metadata&#x27;: &#x27;f:annotations&#x27;: .: &#123;&#125; &#x27;f:k8s.kuboard.cn/ingress&#x27;: &#123;&#125; &#x27;f:k8s.kuboard.cn/service&#x27;: &#123;&#125; &#x27;f:k8s.kuboard.cn/workload&#x27;: &#123;&#125; &#x27;f:labels&#x27;: .: &#123;&#125; &#x27;f:k8s.kuboard.cn/layer&#x27;: &#123;&#125; &#x27;f:k8s.kuboard.cn/name&#x27;: &#123;&#125; &#x27;f:spec&#x27;: &#x27;f:progressDeadlineSeconds&#x27;: &#123;&#125; &#x27;f:replicas&#x27;: &#123;&#125; &#x27;f:revisionHistoryLimit&#x27;: &#123;&#125; &#x27;f:selector&#x27;: &#x27;f:matchLabels&#x27;: .: &#123;&#125; &#x27;f:k8s.kuboard.cn/layer&#x27;: &#123;&#125; &#x27;f:k8s.kuboard.cn/name&#x27;: &#123;&#125; &#x27;f:strategy&#x27;: &#x27;f:rollingUpdate&#x27;: .: &#123;&#125; &#x27;f:maxSurge&#x27;: &#123;&#125; &#x27;f:maxUnavailable&#x27;: &#123;&#125; &#x27;f:type&#x27;: &#123;&#125; &#x27;f:template&#x27;: &#x27;f:metadata&#x27;: &#x27;f:annotations&#x27;: .: &#123;&#125; &#x27;f:kubectl.kubernetes.io/restartedAt&#x27;: &#123;&#125; &#x27;f:labels&#x27;: .: &#123;&#125; &#x27;f:k8s.kuboard.cn/layer&#x27;: &#123;&#125; &#x27;f:k8s.kuboard.cn/name&#x27;: &#123;&#125; &#x27;f:spec&#x27;: &#x27;f:containers&#x27;: &#x27;k:&#123;&quot;name&quot;:&quot;test1&quot;&#125;&#x27;: .: &#123;&#125; &#x27;f:command&#x27;: &#123;&#125; &#x27;f:image&#x27;: &#123;&#125; &#x27;f:imagePullPolicy&#x27;: &#123;&#125; &#x27;f:lifecycle&#x27;: &#123;&#125; &#x27;f:name&#x27;: &#123;&#125; &#x27;f:resources&#x27;: &#123;&#125; &#x27;f:terminationMessagePath&#x27;: &#123;&#125; &#x27;f:terminationMessagePolicy&#x27;: &#123;&#125; &#x27;f:volumeMounts&#x27;: .: &#123;&#125; &#x27;k:&#123;&quot;mountPath&quot;:&quot;/app/config.yaml&quot;&#125;&#x27;: .: &#123;&#125; &#x27;f:mountPath&#x27;: &#123;&#125; &#x27;f:name&#x27;: &#123;&#125; &#x27;f:subPath&#x27;: &#123;&#125; &#x27;f:dnsConfig&#x27;: &#123;&#125; &#x27;f:dnsPolicy&#x27;: &#123;&#125; &#x27;f:restartPolicy&#x27;: &#123;&#125; &#x27;f:schedulerName&#x27;: &#123;&#125; &#x27;f:securityContext&#x27;: .: &#123;&#125; &#x27;f:seLinuxOptions&#x27;: &#123;&#125; &#x27;f:serviceAccount&#x27;: &#123;&#125; &#x27;f:serviceAccountName&#x27;: &#123;&#125; &#x27;f:terminationGracePeriodSeconds&#x27;: &#123;&#125; &#x27;f:volumes&#x27;: .: &#123;&#125; &#x27;k:&#123;&quot;name&quot;:&quot;config&quot;&#125;&#x27;: .: &#123;&#125; &#x27;f:configMap&#x27;: .: &#123;&#125; &#x27;f:defaultMode&#x27;: &#123;&#125; &#x27;f:name&#x27;: &#123;&#125; &#x27;f:name&#x27;: &#123;&#125; manager: Mozilla operation: Update time: &#x27;2021-06-25T02:52:22Z&#x27; - apiVersion: apps/v1 fieldsType: FieldsV1 fieldsV1: &#x27;f:metadata&#x27;: &#x27;f:annotations&#x27;: &#x27;f:deployment.kubernetes.io/revision&#x27;: &#123;&#125; &#x27;f:status&#x27;: &#x27;f:availableReplicas&#x27;: &#123;&#125; &#x27;f:conditions&#x27;: &#x27;k:&#123;&quot;type&quot;:&quot;Available&quot;&#125;&#x27;: &#x27;f:lastTransitionTime&#x27;: &#123;&#125; &#x27;f:lastUpdateTime&#x27;: &#123;&#125; &#x27;f:message&#x27;: &#123;&#125; &#x27;f:reason&#x27;: &#123;&#125; &#x27;f:status&#x27;: &#123;&#125; &#x27;k:&#123;&quot;type&quot;:&quot;Progressing&quot;&#125;&#x27;: &#x27;f:lastUpdateTime&#x27;: &#123;&#125; &#x27;f:message&#x27;: &#123;&#125; &#x27;f:reason&#x27;: &#123;&#125; &#x27;f:observedGeneration&#x27;: &#123;&#125; &#x27;f:readyReplicas&#x27;: &#123;&#125; &#x27;f:replicas&#x27;: &#123;&#125; &#x27;f:updatedReplicas&#x27;: &#123;&#125; manager: kube-controller-manager operation: Update time: &#x27;2021-06-25T06:56:11Z&#x27; name: web-test namespace: default resourceVersion: &#x27;372632&#x27; selfLink: /apis/apps/v1/namespaces/default/deployments/web-test uid: 31fbb0dc-9862-4f1a-b8c0-e6a5a307e34cspec: progressDeadlineSeconds: 600 replicas: 3 revisionHistoryLimit: 10 selector: matchLabels: k8s.kuboard.cn/layer: web k8s.kuboard.cn/name: web-test strategy: rollingUpdate: maxSurge: 25% maxUnavailable: 25% type: RollingUpdate template: metadata: annotations: kubectl.kubernetes.io/restartedAt: &#x27;2021-06-25T10:52:22+08:00&#x27; creationTimestamp: null labels: k8s.kuboard.cn/layer: web k8s.kuboard.cn/name: web-test spec: containers: - command: - /app/hi image: &#x27;13sai/k8s-configmap-demo:0.1&#x27; imagePullPolicy: Always lifecycle: &#123;&#125; name: test1 resources: &#123;&#125; terminationMessagePath: /dev/termination-log terminationMessagePolicy: File volumeMounts: - mountPath: /app/config.yaml name: config subPath: config.yaml dnsConfig: &#123;&#125; dnsPolicy: ClusterFirst restartPolicy: Always schedulerName: default-scheduler securityContext: seLinuxOptions: &#123;&#125; serviceAccount: default serviceAccountName: default terminationGracePeriodSeconds: 30 volumes: - configMap: defaultMode: 420 name: sai name: config---apiVersion: v1kind: Servicemetadata: annotations: k8s.kuboard.cn/workload: web-test creationTimestamp: &#x27;2021-06-25T02:32:38Z&#x27; labels: k8s.kuboard.cn/layer: web k8s.kuboard.cn/name: web-test managedFields: - apiVersion: v1 fieldsType: FieldsV1 fieldsV1: &#x27;f:metadata&#x27;: &#x27;f:annotations&#x27;: .: &#123;&#125; &#x27;f:k8s.kuboard.cn/workload&#x27;: &#123;&#125; &#x27;f:labels&#x27;: .: &#123;&#125; &#x27;f:k8s.kuboard.cn/layer&#x27;: &#123;&#125; &#x27;f:k8s.kuboard.cn/name&#x27;: &#123;&#125; &#x27;f:spec&#x27;: &#x27;f:externalTrafficPolicy&#x27;: &#123;&#125; &#x27;f:ports&#x27;: .: &#123;&#125; &#x27;k:&#123;&quot;port&quot;:80,&quot;protocol&quot;:&quot;TCP&quot;&#125;&#x27;: .: &#123;&#125; &#x27;f:name&#x27;: &#123;&#125; &#x27;f:port&#x27;: &#123;&#125; &#x27;f:protocol&#x27;: &#123;&#125; &#x27;f:targetPort&#x27;: &#123;&#125; &#x27;f:selector&#x27;: .: &#123;&#125; &#x27;f:k8s.kuboard.cn/layer&#x27;: &#123;&#125; &#x27;f:k8s.kuboard.cn/name&#x27;: &#123;&#125; &#x27;f:sessionAffinity&#x27;: &#123;&#125; &#x27;f:type&#x27;: &#123;&#125; manager: Mozilla operation: Update time: &#x27;2021-06-25T02:37:44Z&#x27; name: web-test namespace: default resourceVersion: &#x27;346740&#x27; selfLink: /api/v1/namespaces/default/services/web-test uid: 21ae5d1d-3a52-496d-8636-1a96b0256ddfspec: clusterIP: 10.110.30.213 externalTrafficPolicy: Cluster ports: - name: rsxstz nodePort: 32286 port: 80 protocol: TCP targetPort: 80 selector: k8s.kuboard.cn/layer: web k8s.kuboard.cn/name: web-test sessionAffinity: None type: NodePort","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://github.13sai.com/categories/kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://github.13sai.com/tags/kubernetes/"}]},{"title":"领域驱动设计","slug":"领域驱动设计","date":"2021-06-10T05:06:19.000Z","updated":"2021-06-10T06:49:02.468Z","comments":true,"path":"2021/06/10/345/","link":"","permalink":"http://github.13sai.com/2021/06/10/345/","excerpt":"","text":"领域驱动设计（Domain Driven Design）的概念出现于 2003 年，与敏捷相比，DDD 在提出之后的很多年都没有称得上“流行”，甚至说从未真正流行过。一部分是因为 DDD 涉及了一些新的名词和概念（比如聚合、限界上下文和领域等），在缺乏具体实践案例的场景下，较难理解这些抽象概念，这导致了学习和应用 DDD 的初期阶段就变得不太顺畅，开发人员可能并不能领会到其中的设计思想及其带来的价值。但是在小范围群体内，逐渐有一批工程师开始能够掌控这种建模方法，并使用 DDD 来设计出具有较高业务复杂性的软件应用。 2013年后，分布式的基础设施逐渐成熟。Martin Fowler 于 2014 年发表了系统阐述微服务的文章，微服务架构开始兴起。软件工程师们发现将单体应用采用微服务架构进行划分需要大量的实践经验和理论基础作指导，否则不能完全体现微服务架构所带来的优势。不过早期熟悉 DDD 思想的开发者发现，DDD 可以有效地根据业务对复杂软件系统进行拆解，微服务架构与 DDD 相得益彰。按照软件工程的思想，我们在创建微服务时，需要满足高内聚、低耦合的要求。而根据 DDD 的思想，可以将限界上下文与微服务进程对应起来。DDD 中限界上下文的概念很契合匹配微服务要求，这两者都强调从业务角度进行划分，以应对日益复杂的软件系统。由此，DDD 迎来了它的高速发展和推广时期。 DDD 不是语言，不是框架，不是架构，而是一种思想，一种方法论，它可以分离业务复杂度和技术复杂度；DDD 也并不是一个新的事物，它是面向对象的提升，最终目标还是高内聚、低耦合。 Eric Evans在《领域驱动设计》一书中，提出了经典的四层架构，如下图所示： 用户界面User Interface负责给用户展示信息，并解释用户命令。 应用层Application负责协调应用程序的活动。不包括任何业务逻辑，不保存业务对象的状态，但能保存应用程序任务过程的状态。 领域层Domain负责业务领域的信息和状态的保存和维护。业务对象的持久化和它们的状态可能会委托给基础设施层。 基础设施层Infrastructure负责支持其他层次，提供基础的消息传递、数据持久化等功能。它提供层之间的信息传递，实现业务对象的持久化，包含对用户界面层的支持性库等。 我们以购物车下订单功能为例来解释这各个层面的作用： 用户界面层提供下单的接口 应用层负责逻辑的整合，如购物车清空、检查库存等 领域层将购物车相关的业务逻辑封装到一个 ShoppingCar 对象中，调用 shoppingCar.order下订单，业务服务的重心从生成订单表中的记录转移到购物车对象本身 底层数据库中如何生成这条记录并不属于我们的核心业务逻辑，这对应 DDD 中的基础设施层，由 Repository 或者 Dao 等数据交互对象负责去持久化我们对领域模型下达的指令所产生的数据库变化。","categories":[{"name":"DDD","slug":"DDD","permalink":"http://github.13sai.com/categories/DDD/"}],"tags":[{"name":"DDD","slug":"DDD","permalink":"http://github.13sai.com/tags/DDD/"}]},{"title":"技术管理痛点","slug":"技术管理痛点","date":"2021-06-03T11:50:49.000Z","updated":"2021-06-10T07:08:09.637Z","comments":true,"path":"2021/06/03/343/","link":"","permalink":"http://github.13sai.com/2021/06/03/343/","excerpt":"","text":"本文是专栏《成为会带团队的技术人》的笔记第三篇。 晋升：是不是技术到位、项目做好就够了？经过多少“关”才能晋升？晋升步骤： 晋升启动——主管提名——部门提报——述职答辩——结果表决——公司复审——结果公布 提名沟通可以在薪资、年终奖等激励上体现自己对苦劳同学的关注，而对于想要晋升的同学，应该更多给他能力培养的机会，因为对技术同学而言，技术是晋升的基础，战功与业绩也缺一不可，后者是为了证明自己的能力和担当足以承载更多职责。 大部分情况下苦劳不等于功劳，是否具备下一个角色所需要的条件才是晋升考核的侧重点。 资料准备4 个关键词：资料素材来源、证明实力、PPT编写、赛前演练与心理辅导 素材来源于“过去财年总结 + 新财年的规划 + 汇报材料 + 分享材料 + 项目总结”，因为经过沉淀的资料才最有价值。有了一些素材资料后，就要把控准备阶段的核心：通过素材去证明你具备下一职级所需要的能力。 围绕 5 个维度（架构能力、细节把控的能力、工程的能力、团队的能力、技术视野）去梳理和提炼关键信息，准备相关资料。 编写 PPT 将证明你能力的框架可视化，突出重点、内容翔实、数据说话、功劳大于苦劳、突出自我。 在团队内部让有提名的同学预演一遍自己准备的内容，其余同学从中指出存在的问题（是否紧张、是否突出亮点……）争取让他脱稿，逻辑严谨，减少紧张感；一些同学会格外在意晋升这件事，患得患失，所以 Leader 要帮他平缓心态，帮助其建立正确的认知：把晋升当作一次分享和总结，就当是对过去一段时间的回顾，不管结果如何，总有所收获。 晋升答辩 拿结果的能力： 清晰的客户价值产出，有思考沉淀和可复制的方法论； 业务理解能力： 客户视角、前瞻性思考与判断、可以持续提升客户价值。 结果安排晋升答辩之后，无外乎两个结果：晋升成功、失败。作为 Leader，你需要让候选人认识到这两种结果，并告知尽最大的努力，考虑最坏的结果，避免形成落差，候选人离职；如果候选人晋升成功，简单庆祝过后，还需要为其新角色明确新的要求和职责，让他有更明确的努力方向，在团队内发挥更大的作用，不要把晋升当作终点，而是后面工作的起点。 晋升不是奖励，是责任与担当，是为未来做的事。 跨团队：没有汇报线的人和事就是推不动？跨团队事务推进的难点 方案无法达成一致： 你提出的 A 方案与运营团队提出的 B 方案，在实现成本、方式、资源等方面存在很明显差异，陷入僵局。 时间无法达成一致： 协作方赞同 A 方案，但对“一周上线项目”的时间节点有意见，认为至少需要 20 天，这会从“时间无法达成一致”回滚到“方案无法达成一致”，陷入新一轮僵局。 优先级无法达成一致： 协作方赞同 A 方案，对项目用时一周也无异议，但该项目优先级在他那儿没有提到很高，一直有优先级更高的项目插队，导致交付时间一变再变、一拖再拖。 阶段性交付结果不一致： 因为某些原因（线上突发状况、同学请假、人员能力较差……），与你协作团队在配合时交付你的结果质量无法满足你的需求，比如运营给的方案有很大漏洞、技术给的接口 Bug 比功能点还多，你又无法直接管理对方团队的成员，最终即使更正了也可能浪费了额外的时间。 难点产生的原因： 协作方不清楚项目原因和意义，会优先考虑自身利益，根据利益高低推进难度由易到难 协作方有自己当前的工作内容和优先级，突然配合进行其他事务，引入的风险往往较高 各部门对彼此之间的工作方式、团队经验以及当前现状往往不了解 任务细化，跨团队合作受时间、空间等因素影响沟通成本较高，有些问题不知道该找谁 跨团队事务推进的基本态度 不要做情绪的奴隶，先找自己的问题 快刀斩乱麻，避免因复杂的问题陷入沼泽 慢思考，快执行 跨团队事务推进的原则方法 合作前（明确目标，确保信息完整） 合作中（定位问题，借势而为） 合作后（承担责任，公开肯定） 换位思考、摆事实、讲道理、凭职级、借势而行、想尽办法达成目标。 做规划：除了交付和稳定性，还要规划什么？团队规划解决的核心问题是：让你在有限的时间和资源内，明确怎么去创造最大的技术价值（ROI）。而且在做团队规划的过程中，其实是一个深入思考、梳理的过程，你可以复盘过去、梳理当下、展望未来，少走弯路。 做规划要考虑团队现状 明确定位与职责 人员情况 业务情况 一个可以参考的思路是： 盯着业务目标去延展人员和业务，从而判断哪些是依赖项，哪些是前置项？在大部分公司中，技术很难直接创造商业价值，往往还是要依赖于业务，所以把业务作为第一目标，为了达成某个业务结果，需要调整人员结构，招聘一些更厉害的人汰换一些不行的人，研究并实现一些新技术，这是比较自然的。 你的规划中包含了什么？不同的技术团队，在规划时所拟定的内容都是不同的，但你其实都可以提炼成共性的3 部分。 业务结果： 直白说就是业务层面的战绩，你团队打造了一个公司 GMV 占比超过 50%的商城，或者支撑了某个快速发展业务，这些都是业务结果，用业务数字来说话。 技术创新： 由技术人员发起或完成的所有降本提效的动作，但是同样要看优先级和投入产出比。 团队建设： 让团队可以长期健康发展下去，要在 Backup、人员组成、机制建设等多个方面下功夫。 自问： WHY：为什么做业务目标/技术创新/团队建设的规划？ WHAT：是否能说明业务目标/技术创新/团队建设规划解决的问题、价值与作用？ WHO：由谁承担？负责人的优势与跌势是什么？ WHEN：所做的规划着眼于现在还是未来？能否保证长期有价值？ HOW：针对不同的部分，具体的落地细则如何？ HOW MUCH：规划要做到什么程度？是否可以形成可衡量的KPI？ 业务结果你要明确现阶段上级领导关注的重点是什么？是转化、流量、留存、还是产品的用户体验？作为技术Leader ，你和团队成员的到达路径是什么？这是线索来源之一。 技术创新稳定性、效能优化、驱动业务、视野展望 团队建设团队建设的关键不只是知人善用，而是： 团队未来需要什么样的人？ 目前团队成员需要什么样的状态和能力？ 团队成员需要承担什么样的责任？ 总的来说，你希望未来自己的团队成为怎样的团队？以此推导离理想状态多远？怎么缩小差距？ 规划落地时的问题与思路容易出现的问题： 规划不等于计划 规划内容想得太多，做成的少 业务压力大，盲盯痛点，忽视目标 规划最终成了技术Leader的规划 做团队规划是一件比较综合宏观的事情，有时哪怕只是几个人的团队，想做好一份规划而非执行计划也很考验 Leader 的思考深度，某种程度来说，规划是你定义一群人在未来一段时间内做什么、怎么做、最终变成什么样。这个过程中需要考量的点非常多，这些深入的思考也会促进你日常的一些行为和结果，对于团队的季度乃至半年规划我是非常推荐你要定期梳理并落地的，有目标和没目标的团队，还是有很大的差别的。 接手新团队：士气低、交付迟、事故多发，如何下手解决？困难挑战 团队内涣散的士气与人心 糟糕的业务现状 自身的适应与改变 行动措施 人员盘点(重点是找出两类人：能做事并且想做事的，不能做事并且不想做事的) 事务盘点 虽然接手一个问题团队很难，要处理很多问题并且非常辛苦，但是对一个 Leader 的锻炼也是无与伦比的，我见过几乎所有优秀的技术 Leader 都是一次次这样磨炼出来的。毕竟技术管理能力很重要的一个落地场景就是这种情况，也是最能发挥技术 Leader 管理能力价值的场景之一。","categories":[{"name":"note","slug":"note","permalink":"http://github.13sai.com/categories/note/"}],"tags":[{"name":"note","slug":"note","permalink":"http://github.13sai.com/tags/note/"}]},{"title":"管理三板斧","slug":"管理三板斧","date":"2021-06-01T11:50:49.000Z","updated":"2021-06-10T07:07:58.034Z","comments":true,"path":"2021/06/01/342/","link":"","permalink":"http://github.13sai.com/2021/06/01/342/","excerpt":"","text":"本文是专栏《成为会带团队的技术人》的笔记第二篇。 管理三板斧：拿结果、建团队、招聘与解聘 定目标：让你的方向与公司的方向保持一致怎么解读目标？解读目标就是要确保自己做的事儿和公司的方向一致，顺势而为，没有走偏（这里的“势”就是公司的战略和目标），正因为有了目标才有根据目标制定的 KPI，才会有围绕目标的执行动作和最终取得的结果。 目标不是一句口号，它是一个个层层拆解、递进的过程。说白了，解读目标是把公司的方向变成你的方向，把上一层的问题转变成你可以改变的问题。 确保目标解读正确有很多技巧和方法。根据目标逐层分解的特性，可以考虑四个方面。 你的主管，确定你老板的目标是什么； 你自身所在的团队、团队的成员们，根据团队情况确定现状； 与你紧密合作的上下游（研发），比如你是做订单系统的，那么支持属性很重，商户、导购、用户很多研发团队都是你的上下游关联方； 直接对口的业务与产品，这是业务目标拆解、业务痛点、客户诉求的直接来源方。 怎么制定目标？结合 4 个关键点来考虑。 “短长”结合：事情分轻重缓急，你一直盯着“急”和“重”，“轻”和“缓”的事情就会转变成“重”和“急”，进入死循环。 要足够聚焦：建议关键目标不要超过 3 个，最多控制在 5 个以内，要找最有客户价值、对公司战略最有帮助的点，目标越少、方向越清晰，当问题发生或者需要判断时越容易做决策，在有限的时间内做出更好的结果。 要有足够的挑战：系统可用性假如去年是 3 个 9，今年考虑业务会发展保守起见还是力保 3 个 9，这样的目标挑战性就不足，也无法体现技术的价值。这个度量是很考验你的，一旦极端就会出现过犹不及的情况。就好比考试前，你用希望考 80 分的努力可能实际只能考 60 分，但如果告诉你 99 分以下都是不及格，可能你就干脆放弃了。 要让组织有沉淀、个人有成长：通过一个个目标的完成，让参与的同学得到个人能力的提升，未来可以承担更大的职责，组织也在这个过程做能力的积累与沉淀。 你可以结合这四点，围绕目标和团队一起讨论策略与打法，将目标拆解成几个关键任务，明确到责任人，总结一下就是：定策略、拆任务、细到人。 怎么传递目标？大部分情况下，你会发现信息不对等、传递过程中的损失、个人理解的差异，直接导致不是所有人都清楚“我们要往哪去”。 最后，目标的传递是一个连贯的动作，要落到日常的管理动作、重点项目与任务、KPI 的过程管理这些平日的点滴中。目标要反复讲，要经常对焦，重要的事儿，3 遍是不够的，要说“300 遍！”。 所谓的方向与目标就是：你要往哪去，你要走多远，你要走到哪。清晰的目标就好比沙漠中的指南针，让你能比其他人更快找到水源并生存下去，今天这节课，我提醒你注意这样几点： 解读目标非常重要，切勿陷入极端，要么不解读，要么领导说什么就是什么。 制定目标一定要够聚焦，但切勿只考虑眼前，注意“长短结合”。 注意目标传递，要充分考虑团队成员的感受，选取合适的方式。 追过程：如何用 PDCA 做过程管理？只有掌握过程管理的方法，才会尽可能减少事务往不好方向发展的波动，从而更轻松、更低风险、更稳妥地去拿到结果，让一切尽在掌控。 什么是过程管理？管理就是追求事务的可持续发展，而想要达成这个目标有两个基本点： 管理动作要形成可持续迭代的闭环； 管理动作足够简单到可以复制和个性化升级。 过程管理是为了让你的想法、灵感、不稳定的发挥逐渐规律化，可以持续迭代被你应用，它的本质就是希望结果越来越好，让你原本靠运气或者模糊经验得来的成功可以被复制，让你在项目中灵光一闪的 Idea 变成你的常规能力。 PDCA 模型 Plan（定计划）：围绕着目标明确里程碑，确定关键节点，与执行的员工达成共识。 Do（做执行）：多给员工空间、多走动、多观察、少干预，放手而非放任，你也不能置身事外。 Check（勤检查）：狠抓关键节点做检查、问进展、问困难、给建议、做辅导、协调资源。 Action（复盘调优）：小事尽快复盘、大事分阶段复盘、事后全面复盘，抓住每一次提升和优化的机会。 如何用 PDCA 做过程管理？很多能力和经验是历练出来的，只要过程可控，过程中走一些弯路也未必是坏事，要允许犯错。但是你要注意，放手不等于放任，更不等于不闻不问，你依然要对最终的结果负责。 复盘前：复盘前的核心在于思考复盘的目的和产出是什么。借此，你才可以明确复盘会议主要会聊些什么，哪些人会参加。 复盘中：自省是复盘会的基调，复盘就一个目的“找到团队的不足加以改进，以便在未来取得更好的结果”。所以每个人没必要甩锅，也没必要全盘否定。在复盘的过程中，一定要把问题找准，内部对齐，达成所有人的共识。 复盘后：会议有结论，结论有计划，计划有责任人，责任人有行动，要建立机制保证在复盘会上讨论出的结论能够落地。 总的来说，小事儿尽快复盘，借此向团队成员传授自己的经验；大事儿分阶段复盘，抓住重点矛盾，推动事情的顺利发展而非追求完美；事后全面复盘，不管对个人还是团队，找自己的问题都是 ROI 最高的方式，找到问题的一方才有改善提升的可能。 三个重点： 目标不会自己长腿走向终点，你一定要做好过程管理以取得可靠的结果。 追过程不意味着事无巨细都要做，追哪些、什么时候追、追到什么程度才是你更应该关心的。 复盘是 PDCA 管理动作中的闭环，如果每次都能提高一点点，长期积累的变化就很大了。 奖优罚劣：怎样传递我们”要什么”与“不要什么”？“奖优罚劣”之所以重要，是因为它能让团队形成可持续发展的氛围，是拿结果的闭环。而我们在这个过程中要注意的就是：引导人性而非对抗人性。 什么是奖优、罚劣奖优最终会落到物质和精神上： 物质上的奖优作用大，但是频次较低，比如以半年/年为单位的晋升、调薪，它能够打开成员的天花板，比如拿了A绩效的同学，第二年他依然希望是A而不是B，从而提高对自己的要求与期望，更容易取得好的成绩。 精神上的奖优体现在日常行为上，频次较高，比如你关注和肯定某位成员的行为，在团队内通过邮件、钉钉等方式简单鼓励推广他的行为。 罚劣也会落到物质和精神上，但它是动作而非目的，你要通过罚劣来传递团队不能容忍什么样的行为，以此提醒、鞭策大家。奖优和罚劣是相互依赖的。 “奖优罚劣”的一些误区： 没有意识到奖优罚劣的示范作用。 你要把“奖优罚劣”当作宣传动作，把结果辐散出去，引导团队风向。 注重罚劣，忽略奖优。 奖惩动作过于儿戏，容易被滥用：“奖惩动作”要建立在尊重的基础上，让成员有收获和反思。 奖优罚劣的关键动作绩效考核我们要从一开始被主观因素影响，逐渐认识到客观的环境与现实，最终在理性与人性中寻找一个平衡，让大家看到付出和能做出好成绩的同学，回报是远远高于其他人的，对于拖整体后退、持续不能改善的同学，团队是不欢迎的。 绩效面谈绩效面谈的核心出发点是通过这次绩效的结果改变某些行为与认识，让团队在未来取得更好的成绩，并不是单纯地通知结果。 面谈流程： 开场定基调 员工自评 主管评价 对焦共识 面谈总结 后续跟进 薪酬激励三个基本原则： 问自己是否敢将资源分配的逻辑与规则在阳光之下讲出来。 不要撒胡椒面，也别做大锅饭，让好的结果超出预期。 面向未来而非现在去做考虑 牢记资源总是有限的，资源分配本身是博弈，有人多就要有人少。这种情况下，平均分配的结果不是普天同庆，而是所有人都不满意，每个人都觉得少。与其如此，不如把资源倾斜到那些你团队最优秀、绩效最好的同学身上，让他们得到预期的收益甚至超出预期。 勤沟通：在信任的基础上，让沟通简单且纯粹要知道，沟通是有目的的，既然沟通的对象是人，我们还希望通过沟通去达到一定的结果（效果），那么就要懂得一定的道理与技巧。 沟通的核心原则沟通是内心想法和思考逻辑的外延，如果你有良好的沟通能力，可以在整个团队中营造公开透明的信任氛围，让信息透明的同时，也让团队成员愿意发出自己的声音。 沟通核心原则的定义是：在相信对方的基础上，让沟通氛围变得“简单且纯粹”。 不同维度的沟通向上沟通有胆量、平行沟通有肺腑、向下沟通有心肝。 向上沟通要有技巧、有原则，认清沟通的目标与目的，不轻易妥协导致更严重的后果。 关于平行沟通有肺腑是指你要真诚沟通，不要油滑套路。 向下沟通有心肝是指有同理心，有尊重的同时要感同身受。 两个具体的沟通场景One One 沟通 接地气，说人话 视人为人 沟通要“勤” 团队沟通与One One沟通不同的是，团队沟通受人数的限制，是一对多的沟通，所以除了参考OneOne沟通的核心点外，你最关键的应该是搭场子，发起团队沟通。 团队沟通目的性更强，频次不高，考验你的控场能力。 建机制：规则流程越建越多，为何效果却越来越差？机制发挥什么作用？两类机制： 与管理相关： 比如为了信息互通，约定每周固定时间通过邮件、会议、IM 等方式，将提前定义好的信息做一个汇总交互（表现为周报、周会等），这就是机制的一种具现。 与技术相关： 比如为了多人协同，制定开发流程、Bug 处理、发布上线流程，甚至在日常实际开发的工作中，往往也先定义 API 契约，然后在联调测试时再真正实现验证，这些约定、契约、流程都是对应机制在落地时的具体表现。 站在团队的角度，建机制尤为重要，你要通过机制让团队有统一的行为与规则，让组织像人一样，言行举止有规律可循。 如何设计一个好的机制？ 规则统一，不自相矛盾 简单有效，便于增删 紧盯整体结果，机制的 ROI 要足够高 机制要怎么落地？ 先说 why： 即机制的内容是什么？为了解决什么问题？你在设计机制时是如何思考的？ 共识的要与不要： 和大家讨论我们要不要这样做？看看大家是怎么想的，通过对话和引导形成一定的结论，有些内容需要保留，有些不合理需要剔除，促成结论最为重要。 承诺行为举止： 确认机制之后，需要让结论形成对各自行为的约束。比如不同的成员认领不同的角色和任务，或者在 IM 中一起公告规则，总之每个成员要与机制的参与感。 先考虑目的， CodeReview 主要是解决两方面的问题：提高代码质量；帮助开发同学认识到如何写出更好的代码。不同的侧重点设计出来的机制也有所不同，按照我的理解，CodeReview 的主要作用还是帮助大家成长，打造团队内的技术提升氛围，次要才是促进产品质量的提升。 确定了核心想要达成的效果，接下来就可以着手确定机制的内容，这里面要考虑几个方面的内容：可能会遇到的问题（阻力）、机制实施的成本、机制运行的时机和周期、站在一个机制参与者的角度考虑他要做什么。 具体 CodeReview 的机制方案可以参考下图： 知人善用：借事修人，借人成事知人善用的三个关键点 找对人 培养人 养成人 怎么落地执行？ 团队盘点 激发意愿 改善计划 tips 不怕没缺点，就怕没特点： 你借人成事，不能一味地关注他的缺点，而是要寻找其特点，发挥他的擅长点，有缺点不可怕，就怕没特点。 新人做老事，老人做新事： 如果在团队中老人一直做老事，新人做新事，那么会出现老人没有新的提高，新人也要克服很多未知的困难；反之，可以重新激发老人的活力，也让新人有借鉴之处。 不要越俎代庖，什么都自己上： 用人的过程中会出现“事情做错”的情况，一旦你发现这样的情况，千万不要直接去帮他纠正，这样无法帮助团队成员成长，团队成员只会当犯错误时，等着你来帮他解决。好的 Leader一定是要在明知前方有坑（这个坑一定是你能控制的）的情况下，也要让团队成员去踩一回，让其有试错的机会，让每个错误都物有所值。 给机会的同时，给压力和帮助： 很多时候压力是成长的催化剂，有了压力也就有了 120% 的动力，所以把某个任务或职责给到一个同学的时候，也要把适当的压力传递过去，让他感受到事情的重要性。与此同时，时刻关注，该给的帮助一定要给到，不能不闻不问。 既敢于承认错误，也允许别人犯错： 让一个人成长不可能完全不让他犯错，有时一些可控的错误反而可能是事后看最大的收获。同时，也不要认定自己之前的做法都是对的，要意识到，哪怕你之前做成功过，也不意味着你就一定是100%正确的。好的 Leader 在培养团队成员时，既要让团队不怕犯错（敢干事），也要敢于承认自己不足，去改善去提高。 找到人：招聘是 Leader 的责任，不是 HR 的招人不等于盲目加人明确业务目标；盘点团队需求；做出岗位设计；提炼岗位要求。 闻味道、问事实、看能力面试前看简历，面试中更多倾听，面试后速写评价。 问事实（STAR法则，看候选人所说的内容是否真正做过，以及思考过程） 看能力 闻味道（是否和团队匹配） 宁缺毋滥，守住底线关注未来 他是否有能力的同时还有潜力？比如很强的发展欲望或学习能力？ 他身上是否有特质足够吸引你？比如让你觉得当他未来会比你更优秀？ 你是希望与他这样的人一起共事的？ 当他加入团队后，能否将团队氛围激活，形成鲶鱼效应？ 宁缺毋滥 能力水平超过团队 50% 的人以上：确保团队越来越强，而不是越来越弱，有的 Leader会觉得候选人比团队最差的两个人好就可以了，但这样一来，随着时间拉长，你的团队会越来越差。 内心是否非常犹豫？犹豫往往意味着“不想要 &gt; 想要”，如果是迫于业务压力不得不加人，我建议你还是不要勉强，因为有可能本来解决业务压力就可以的问题演变成还要额外解决不适合的新员工的问题。 能落地：90 天试用期，转正时我们要考察什么？ 明确新同学落地的整体节奏 重点抓试用期考核以及工作习惯的养成 转正结束后依然保持跟进 既要帮，也要严“既要帮，也要严”是我定义的“能落地”的核心原则，“帮”与“严”是双向要求：帮是指帮助新同学融入团队（针对的是师兄和 Leader）；严是要让新同学在团队中提升自己，遵守团队的做事原则，发挥自己的能力与价值（针对新同学自己）。 招聘只是开始，让新同学能落地、发挥价值才是最终目标。 明确新同学落地的整体节奏 用迎新打破大家在情感上的壁垒； 给新同学安排“师兄”； 明确新同学的作业与目标（做出一些成绩达到转正）； 明确告知转正应该怎么做（把转正做重、做实）。 转正述职要考核什么转正述职才是真正意义上的招聘结束！ 把控转正时间： 提前半个月跟 HR 或者“师兄”确定转正述职时间点。 建立评委会： 由 Leader 主导，与其合作的伙伴（技术同学、产品或者运营）组成小的评委会（如果团队成员较少，也可以只有 Leader 和 HR）这里要注意，合作伙伴的反馈也许会比较主观，你在参考时要尽量保持客观。 明确考核内容： 硬性要求+软性要求。 成长期的跟进慢慢叠加、主动跟进、树立信心 升级汰换：“心要慈，刀要快”开除人“心要慈，刀要快” No Surprise： 不要突然Fire一个人（离职一定不是一个突发行为），没有任何征兆告诉员工 A“你被开除了”，这是典型的管理失职。如果A存在问题，你应该先告知，然后一边和他一起制定改善计划，一边督促其改正。离职往往是一个可预期的结果，无法满足工作需要或者对团队有其他伤害而 A 依旧无法改变时，为了避免对团队产生持久不利的影响，就需要让他离开。 心要慈、刀要快： 杰克·韦尔奇（Jack Welch）曾经说过这样一句话“如果一个人到了中年之后，还没有被告知自己的弱点，反而在某一天因为节约成本的原因被裁掉了，这是最不公平、最不应该发生的事情。就是因为这个公司太仁慈了，他连出去找工作、提升自我的可能性和机会都没有。”你可能觉得，在情感上解聘一个人非常糟糕，但是换一个角度想，如果你对一个人很不满意，却又不找他谈话，不要求他改进，又不开除他，那么从最终结果看不仅对他很残酷，这种“拉锯战”对团队也是不负责任的。 Happy stay、Happy go： 很多时候，送走一个同学对彼此来说并不是一件糟糕的事，换个角度看，如果他在当前环境下一直无法适配团队，对他来说也是很难受的，这时分开对他对团队都是解脱。尤其是当公司出现变化时，如果一些同学不再合适，换环境来讲对他是新的机会，所以你不要存在太多的情绪，而是要往“好聚好散”的方向上推动。 不要给“白兔”生存机会 白兔看起来人畜无害，繁殖能力极强，大公司里最容易存在的就是“白兔”（不干活的好人）。他们目标和价值观认同度较高，但是业绩长期拖后腿。每一家公司都有这样的人，看着勤勤恳恳，但却拿不到任何结果，如果你纵容白兔的存在，那么长久下去，很容易滋生一群白兔磨洋工，针对这类员工，你前期可以给予改正的机会，如果依旧没有改善，应该毫不犹豫将其送走。 离职面谈“TRF” Train him、Remove him、Fire him Train him 是指如果他能力跟不上，你可以给予其帮助；Remove him 是指如果他的能力和岗位匹配有问题，你要更多地采用转岗的方式，为他的发展打开空间；如果在你给予他机会之后，他还是无法改善，那你就应该 Fire him。 需要避免的： “谈不了”：辞退的事实依据不充分，对离职原因讲不清楚。 “无重点”：对有关问题避重就轻，只说无关痛痒的祝福。 “没技巧”：对员工工作横加指责，面谈完反而加深了矛盾。 “从不谈”：是对员工存在很大偏见，不面谈直接一拍两散。","categories":[{"name":"note","slug":"note","permalink":"http://github.13sai.com/categories/note/"}],"tags":[{"name":"note","slug":"note","permalink":"http://github.13sai.com/tags/note/"}]},{"title":"技术人三要素","slug":"技术人三要素","date":"2021-05-31T06:47:22.000Z","updated":"2021-06-10T07:17:59.533Z","comments":true,"path":"2021/05/31/341/","link":"","permalink":"http://github.13sai.com/2021/05/31/341/","excerpt":"","text":"本文是专栏《成为会带团队的技术人》的笔记，自己以前也有带团队经验，但自我感觉做得不够好，这个专栏给我很多启发。 技术人三要素：稳定性、债务、架构 稳定性怎么衡量系统稳定性？一般来讲，通过统计系统不可用的时长或次数就可以对稳定性进行量化，比如业内常说 4 个 9 的可用性（即 1 年内 99.99% 的时间系统是可用的，不可用时长仅为 52.6 分钟）。 针对稳定性的提高也可以看作围绕事故的治理，可以从事故发生的前、中、后分阶段来看对应的关键点。 事故的类型：可用性事故、资损类事故。 事故前预防：主动治理减少系统的风险隐患，重点在变更管控、可用性设计、应急预案与演练。 事故中应急：“止血、恢复”是原则。 事故后复盘：目的不是追责，查根因、改进架构、完善应急、总结经验才是我们想要的。 事故的类型从事故特性上看，我们可以分为可用性事故和资损类事故。 可用性事故：技术原因导致系统部分或者全部功能不可用，业务没办法正常完成对应流程或者提供对应服务。比如因为网络、DB、接口 Bug 等原因，用户没办法登录、商品列表不显示等。 资损类事故：系统的功能都能正常使用，但因为逻辑、计算等原因让业务的某一方产生了资金损失。比如用户支付一律为 0 元、错发 999 无门槛优惠券、商户清结算少打款给商户等等。 故障处理的生命周期 故障处理的生命周期，可以分为 4 个阶段：发现异常、排查问题、判断决策、恢复处理。这 4 个阶段对应的行动并不是完全串行的，虽然有一定的依赖关系，但在实际的处理过程中应该并行展开。类似 fork/join 的模式，不断完成小任务、不断汇总信息，不断做出判断与决策，形成循环直到故障恢复。 1. 故障发现 总的来说，人工的被动反馈在时间和速度上有较强的不确定性，很容易出现“小故障 * 长时间 = 大事故”的情形。而纯粹的技术指标监控又会忽略掉接口正常响应，但是业务异常的场景，只有两者结合，通过监控告警，最大程度上缩短故障感知的时间，才能早发现早解决，减少业务影响。 2. 故障排查 直接锁定：最近的变更点与异常现象间有直接的逻辑关联，进而可以直接锁定到故障点。比如，刚对下单接口进行了发布变更，接口的 QPS 曲线就暴跌，可以基本断定是刚才的发布导致。 排除法：当干扰因素过多（用户、订单等几个系统同时发生变更，引起订单下跌），很难直接锁定到故障点，就要结合业务场景，让整条架构链路上的所有关联方进行自查自证，通过排除法锁定故障。 3. 故障决策业务决策非常复杂，能否第一时间止损很大程度上取决于技术 Leader 的现场反应和操作， 要注意故障决策的两个关键点 ： 一定要有明确的决策人、主导者和有效的沟通方式（钉钉群、多人电话会议、紧急作战会议室等），让信息可以通畅地交流出来，并且决策人可以根据情况做判断与取舍，形成所有人明确的处理结论。 比如，第一时间停止错误红包的发放，确保故障没有增量，并把决策第一时间同步给团队成员，并同步相关负责人后续的动作，对已发放的红包，明确要求负责人汇总各类关键信息（红包数量、涉及金额、涉及用户数、有效时长、可能资损等）。 所有的信息一定要数据化，不同的数据量级会导致决策不同，比如红包错发 50W 可能只是暂停发放，但是存量红包依然可以核销，损失公司可以承担。但是如果错发 5000W，大概就要涉及一系列的调整，这是非常影响决策的。 4. 故障恢复 应急“三板斧”：变更回滚、服务重启、降级&amp;限流。 如何有价值地做事后复盘？你可以从时长、现象、处理时间轴、根因、改进计划这几个维度进行复盘， 在以下几个方面进行深究： 事故时长：1-5-10(即 1 分钟发现、5 分钟响应、10 分钟恢复) 是否达成，如果没有是为什么？哪个环节用时最多，如何提高和改善？ 事故根因：根因不等于直接原因，一个事故的直接原因往往并不复杂，但是根因可能是多个维度的缺失，需要像剥洋葱一样一层层找下去。拿库存接口变更这个Case来说，直接原因就是某段代码逻辑变更导致，但是应该在测试、发布、监控、应急影响、预案设计等多个环节展开去看，根因的挖掘并不忌讳“吹毛求疵”。 事故改进措施：由点推到面、明确到人、明确时间。与根因类似，要结合多个维度形成组合拳的改进点，避免一次性动作，要将重点放在对未来、对同类问题的预防上。核心就是如果再一次发生类似的问题，这些改进措施是不是能起到作用。 关于事后复盘，你可以这样理解，我们要深挖事故如何发生的、如何处理的、未来怎么预防。但要避免情绪化，在复盘会上的反思、感悟、懊恼没有任何意义，如何带领团队把精力放在改进措施的落实以及事故前的治理上更有价值， 另外，你需要留出时间让团队伙伴进行内部的 Review，避免为了开会而复盘。 没有质量的交付，再多再快都毫无意义。 变更会引起90%以上的故障1. 变更需要监控有效的监控要回答三个问题： 是否有问题发生？ 哪里发生了问题？ 发生了什么问题？ 2. 有效灰度必须有耐心 灰度从来不是为了测试，也不等于 A/B Test。它本身是为了对抗“未知的不确定性”。 要想实现灰度的有效性，关键点在于时间和流量。 时间：每个灰度阶段至少有 5 ~ 10 min 的观察，在监控、日志和各方反馈没有异常后再扩大灰度范围，确保一些运行时异常或量变积累质变的问题可以暴露出来。 流量：有时一些业务场景需要特定的触发条件，比如满足某些条件的用户或满足某些条件的订单，那么在灰度时就不能仅通过单位时间内有没有异常来判断，还要确保有足够的有效流量。 3. 回滚就是变更的“后悔药”要知道，系统并不是天然可以无缝回滚的，想要系统具备回滚的能力，在设计与实现阶段需要付出额外的精力。可回滚的本质是系统的兼容性设计与实现，比如常见的“只增不改”，一个 API 内要调整很多实现逻辑才能满足新业务的需求，此时不妨直接新增一个 API ，两个 API 保持参数一致，那么一旦新 API 有异常直接切换回旧的 API 即可。 所以，不论是灰度计划还是回滚策略都应该在架构设计阶段就去考虑，结合排期、风险程度、成本投入这些方面，要做好评估与平衡。 坚守 Design For Failure 的架构理念“Design for failure and nothing will fail”，最早是 AWS 的一条最佳实践，即面向失败进行系统设计。可以理解为：考虑系统所有可能发生故障或不可用的情形，并假设这些可能都会发生，倒逼自己设计足够健壮的系统。 1. 将经验教训沉淀下来历史是最好的老师，我建议你总结并分析过去发生过的事故，并结合常规分布式系统的可用性风险，以此梳理出一个围绕事故隐患的风险点 Checklist，在需求迭代或者架构设计时，通过它高效地找到系统实现的薄弱环节。 除了完善 Checklist，在团队普及这种设计理念之外，更关键的是将这些解决方案沉淀成设计原则，让研发人员可以在实际中落地。 2. 通过演练验证预案设计设计并实现了自己的故障演练系统，日常主动制造事故上下文来验证我们的设计与系统是否可靠。 把稳定性当作机制与文化去建设系统稳定性结果好坏很大程度上取决于技术 Leader 的重视程度，如果一个团队的管理者都不能身体力行的去重视它，而仅仅只是喊喊口号，那就不要指望团队成员能认真地对待这件事。 1. 新人 Landing 从稳定性学习开始2. 每人不低于 35% 的稳定性 KPI3. 好的坏的都要在阳光之下晒一晒 建立资损概念的宏观认知从广义上来看，存在理论损失也应该算资损， 比如因为搜索推荐系统出问题（不论什么原因）导致这一阶段广告的收入减少，或者因系统 Bug 导致用户取消订单的申请被默认同意（虽然原本商户可能也会做同意处理，但是申诉的话平台依然要赔付），类似预计收益减少或者因系统问题产生赔付的场景都应算为资损。 资损防控的三个关键1. 防：资金视角做风险点识别 2. 监：一致性与正确性双核对针对资损感知的核心思想是：基于线上业务结果收拢进行监控，基于线下业务场景扩散进行核对。 与可用性监控围绕接口的技术指标不同，资损更关注的是数据核对，监控的并不是运行状态而是运行结果，并且资损监控的粒度要求非常高，精细到每一笔交易、每一次金额计算、每一个红包发放。所以资损监控的有效性很依赖于场景的覆盖率，仅覆盖几个关键场景是不足以规避资损风险的，除了要定期梳理外，每次系统有变更或者新功能时，都需检查是否有新的核对点，以及旧有核对公式是否需要调整。 3. 控：资金拦截 + 资产控制除了防和监，资损防控的关键主要在“控”字上，我们希望在问题发生后第一时间止损，这就需要技术在系统层面对资金和资产有很强的控制能力。这种能力的表现就是： 不仅可以通过预案将某些场景与链路降级，还可以拦截资金的流出和资产的使用，同时具备快速订正错误数据的能力。 在我们开始处理资损事故时，会有三个共性的需求。 问题止血不新增：核心是关闭问题产生源头，往往通过业务场景降级来实现，比如对错误红包或者满减活动进行下线。 控制资金流出：核心是对资金和资产进行拦截与冻结，避免外流后损失无法修正，比如禁止用户下单时勾选使用有问题的红包。 存量数据订正：核心是捞取问题数据后可以快速地批量处理，比如批量更改红包的金额、甚至直接将红包无效。 虽然其中一些操作对用户体验是有损的，但有而不用是一回事儿，无能为力则是另外一回事儿，其中： 资金拦截的能力主要从资金的流入和流出这两端进行把控。以红包而言就是管控其创建与核销。在红包创建时，有预算系统进行管控，避免无限制地生成红包进而超发。在红包核销时，由交易和营销系统进行验证，确保订单上下文以及红包合法，避免问题红包被核销进而造成无法挽回的资损。 资产管控的能力则是资产的快速锁定和数据订正展开，以红包而言，如果不同模版不同活动的红包都有一个统一的批次号，就可以通过这个标记快速捞取某一批有问题的数据。同时如果提前准备批量订正的脚本，或者有订正数据的平台，就可以快速修改红包金额、使用时间、使用门槛等关键信息，甚至批量无效所有问题红包。 你需要注意，这些能力的实现更多依赖于技术 Leader 在日常需求迭代和架构设计时，是否有意识引导团队加强这方面的建设。大部分的预案思路来源于过去已经发生的问题，或者对未来可能发生问题的假设，将预案常态化是你重点关注并推进落地的。 除了建设预案，还要有预案演练，以此保证预案的有效性。技术 Leader 更应该鼓励测试和开发的同学主动做攻防演练，寻找漏洞、验证止损方案、及时发现并修复问题。 技术债务技术债务在研发领域类似于“金融债务”的概念，大部分情况下是说因为人为妥协，系统的设计和实现没有遵循最佳实践，所以虽然在短期做到了快速交付，但也制约了系统未来的可扩展性，并且埋下了稳定性的风险隐患。就好比你信用卡分期消费，虽然可以立刻满足自己的购买意愿（得到眼前的好处），但同时也会背上一定的负担，在未来必须得偿还。 重视技术债务的原因 影响系统扩展和需求交付 恶性循环导致人员流失 技术债务的恶性循环会影响开发团队的生产力，并降低团队的士气和成员的驱动力，而低生产率导致团队只能优先交付功能，这就推迟了技术债务的解决，从而进一步增加技术债务。 如何从循环的债务困境中突围而出？1.债务的 Owner 是技术 Leader要想解决技术债务，你需要找到技术与业务的平衡点，我的经验是“内外双修”： 内：加强团队的战斗力，减少债务产生的机会，增强债务处理的能力。 外：要深刻地理解业务，并且做好与其他协作方（尤其是产品、业务）的沟通。这样你才能理解协作方想解决什么问题，他们以为要么A、要么B才能解决的问题，既懂技术又懂业务的你能否找到方案C？ 我建议你，面对选择题时不要只看到可选项，要永远寻找第三条路。 如果实在没有其他选择，在技术妥协的同时，做好沟通，让协作方明白方案的临时性以及对未来的影响，争取到承诺在未来给你足够的空间解决这些问题。 2. 通过 CheckList 识别债务建立一个债务 Review 的 CheckList ，并且不断完善。技术债务从表象上可以做一些细分（我整理了一张图）： 通过现象我们就可以反推出一些导致现象的原因，将这些原因结合系统的架构进行分类，就会形成一个个具体的关注点。这些关注点往往是结合我们之前踩过的坑、发生过的问题，以及编码、架构上广为遵守的一些最佳实践所形成的，这样你就可以制定出一个较为详细的 CheckList 用以具体的债务识别（下图供你参考）。 3. 有计划地分级偿债 关键链路优先： 并非所有糟糕的设计与实现都能产生严重后果，即使能，它们发生的概率也不一样，而关键链路意味着业务影响最大，同时日常的改动频率和事故风险也较高，优先解决它的收益是最大的。 历史事故命中优先： 一些设计与实现在过往导致过线上真实问题的发生，不管是否发生在本系统还是当前团队，都相当于已经被证实过的这类债务的严重性，所以应该尽早修复它们，避免类似问题反复发生。 可扩展性优先： 在 CheckList 以及债务现象中我们可以发现，有些问题影响了系统未来的演进，增加了迭代成本，有些问题影响系统的维护，比如代码风格没有统一、缺少文档，在处理时应该优先处理影响可扩展性的问题，后续逐步处理影响可维护性的问题。 权责清晰优先： 一些问题在处理时受到历史架构、组织分工（康威定律）的影响，会导致系统的权责不清晰，这类系统的推进和改造往往需要花费更多的时间精力，并且从顶层设计出发去重新考量，所以权责清晰的部分可以优先处理。 总的来说，通过对技术债务进行分级，实质上也是一个问题分治的过程，将大问题切分成一个个小问题，这样就可以将它们加入日常的迭代中，形成一个分期偿还技术债务的计划，逐步减少技术债务，减轻负担让团队与系统可以轻装上阵。 4. 正视债务做好预防除此之外，预防永远胜于治疗，技术债务汇总预防的关键点在于那些“原本未知”的技术债务要逐渐减少，大家对于实现质量的追求不能止步于“测试没有明显 Bug”，写出能运行的代码是不够的，还要易维护易扩展。而你可以从几个方面着手： 提升团队认识，通过项目复盘、系统重构、事故 Review 等各种机会，通过实际的案例让研发同学清楚技术债务对团队产生的负担，以及对个人能力提升的影响。 建立机制流程，比如在方案设计阶段向下深挖一下实现的要点，更多资深的开发参与到架构评审，或者促进团队形成 code review 的习惯并且达成一个共识标准以提升系统质量。 确保资源投入，在通过债务识别和分级后，将还债的投入提前计算到每次迭代中，确保有一定的资源投入其中。 5. 一些常见的误区通过 CheckList 做债务识别，然后定期诊断、水平扫描、债务定级、分期偿还来做技术债务的处理，最终在团队认识、机制氛围、资源保障上下功夫做预防，这就是技术债务管理的核心思路。 而这个过程中，有一些问题是日常你很容易走入误区的，我简单总结了一下几个注意点： 存在即合理，动态变化才是王道。 不要总想着毕其功于一役，也几乎不太可能有完美的实现或系统，接受技术债务一定会存在的事实，重点在于控制债务积压的程度，欠债本身不可怕，欠债不知且不还才可怕。 不积跬步无以至千里。我们往往过度轻视日常微小积累，又过度重视“大事件”产生的影响。日常这里凑合一下，那里妥协一点，没人关注小问题发生的原因。而一旦发生重大的影响，则恨不得把之前的系统全盘推翻重做一遍。 机制流程外还要讲策略和方法。很多技术 Leader 觉得这件事很重要，讲的同时设计了很多流程和机制，不遵守就要承担怎样怎样的后果，这样往往事半功倍。机制流程不是越多越好，也不能光有惩罚而没有激励，同时最重要的是你不能只追杀要结果，要给帮助、给方法、给支持。 大项目：把握关键点，谋定而后动认清异同，做到心中有数 在这个常规流程中，技术团队的重心是把执行做到位，你要更关注过程管控，确保系统交付。 大项目与常规项目的核心差异点，我认为主要在于这个“大”字上，你可以从三个方面去理解。 出发点不同，业务期望更大 规模不同，复杂度更高 结果评判标准不同，影响更大 把握关键点，谋定而后动 关注效果更重于关注交付，这是大项目的核心特征。 不要为了重构而重构，要知道你要的结果是什么。 大项目的失败存在一个共性的问题：围绕业务结果的思考、计划不足，目标的定义不清晰或没有充分同步给所有相关人，项目同学知其然而不知其所以然。连目标都没有共识，何谈执行到位，项目成功？ 所以我认为越是重大的项目，在计划、设计、准备上投入的精力就应该越多，谋定而后动。 WHY（项目为什么做） WHAT（项目做成什么样） WHO（哪些人来一起做项目） HOW（启动项目后如何做） 合理拆分任务（模块）是项目成功的一半 保持风险意识，敬畏墨菲定律 做好充分的准备之后，可以召开立项会，将 WHY、WHAT、WHO、HOW 的信息与思考同步给项目相关人员。通过 Kick Off 会议确定项目的基调、同步必要信息，为项目推进扫清障碍。 如何处理棘手问题问题一：缺兵少将怎么办？项目组人时你要注意以下几点。 当项目开始时，从更大的范围内寻找合适的同学，而不是看你团队有哪些人。 将参与项目的同学在一定时间内的汇报关系和绩效考核汇总到项目组中，由项目负责人根据实际情况重新安排每个人的权责，并确定绩效的绑定关系与比例。 项目交付并不等于结束，所有人的绩效结果都应和项目目标的达成情况紧密且长期关联。 最后，有时不仅要解决“缺兵”的问题，还要认真考虑是否“少将”？要充分考虑当前的人员是否适合做项目的 Owner，以我的经验来看，项目 Owner 几乎决定了项目成败的 80%，如果 Owner 能力不足，你要给予帮助和支持，或者另找他人，乃至上级的帮助，不要在 Owner 的人选上妥协，毕竟项目成败才是关键。 问题二：推不动的到底是人还是事？ 搞明白冲突现象下的利益诉求： 不同关联方产生观点冲突的现象背后其实是利益冲突，你要搞清楚彼此的顾虑。比如我不愿想让某个系统字段落到订单中，主要是考虑到订单系统的可维护以及稳定性，如果你能解决我的顾虑，会容易说服我。 为项目结果适当妥协： 在很多情况下，我们无法做出完美的方案，可能就是要在系统内通过很糟糕的实现去实现需求。项目没有 100% 完美，抓住核心原则不放弃，可控部分适当妥协换取项目前进是很好的策略。 通过项目地位和决策机制推动项目： 大项目往往是公司重大战略下的产物，一般情况下，不会有人去反对公司的某项既定战略，而你可以通过大项目的重要性在体系内争取更多的资源和帮助。如果你面临一些冲突，要学会利用决策机制，通过更高级别成员的沟通决策拿到解决方案。 问题三：一定会有项目变更吗？常见的变化往往有两种： 项目演进过程中识别出之前未能识别或考虑缺失的点，导致方案需要调整。 出自老板的需求变更，很多情况下都是要新增内容。 3个重点 驾驭大项目是你的试金石和分水岭，对自己职业规划有一定要求的同学一定不要放过打磨修炼的机会。 在大项目中，往往人的问题会比技术与系统的问题难解决，因为与人相关的问题未必完全理性和逻辑，那么此时你也不妨看看感性的沟通与交流是不是有更好的效果。 时刻牢记你将项目按时上线没有故障只是做到了60分，更关键的是业务效果，所以除了盯紧开发过程外，还要在最开始的业务与产品设计阶段就投身其中。 业务理解：深入业务是做好架构的前提为什么技术要理解业务？产品需求不等于业务诉求同样的，技术 Leader 可能会花时间参加各种会议，尤其是产品需求的会，在会上如果仅仅是听“自己团队应该做什么”，而没有思考和探究业务的根本诉求，那么就我的经验来说，技术团队不可避免的会成为工具人。Leader 缺乏独立思考，人云亦云，最后整个团队都会被拖累，这也是为什么大多数研发团队被产品以及业务按在地上摩擦的原因！ 领域建模的前提是理解业务正因为没有仔细看业务的现状、推测业务的发展、去思考业务上对交易的诉求，我们认识的只是一个个需求，而非整体的从业务维度思考系统的设计，导致系统复杂度越来越高。所以要想设计可靠、简单、真正可持续迭代的系统，深度理解业务就是前提，你对业务的理解程度影响了你对系统未来发展的预判程度。 提升技术团队的使命感你写的每一行代码，线上的每一次发布，都会改变用户的体验，解决实际的问题，你就会发现这份工作的意义。 如何理解业务？ 不要盲信产品（不要盲信产品与 PRD，在讨论 PRD 和执行开发任务之前学会独立思考，深入理解业务想要解决什么问题，需要什么效果或作用，严格把控那些伪需求和无价值需求，防止它们侵占团队的技术资源。） 建立走进业务的机制 业务上多参会多画图（参加评审会，梳理流程图等等） 架构设计：治理好系统复杂度才最务实治理好系统复杂度才最务实C.A.R. Hoare曾说过：“软件设计有两种风格，一种是将软件设计得很复杂，以使其缺陷没那么明显；一种是把软件设计得很简单，以使其没有明显的缺陷”。 系统的结构清晰、即使整体繁杂但是每个局部都相对简单、链路干脆直接，没有不必要的冗余。 衡量复杂度 理解成本高：需要很长时间才能理解系统模块的组成及运作，比如新同学加入或系统交接时，老同学很难讲完整、新同学不容易听明白，要几周甚至1~2个月才能完全了解系统的实现和运作机理。 变更牵连多：哪怕是实现一个小的需求都要改造系统的多个部分、甚至多个系统（上下游等），有的还需要协调其他团队或部门，结果导致迭代成本高，并可能引入更高的风险。 一张图装不下：即你无法在一块白板上清晰且完整地画出系统主要功能场景的架构图，可能是牵连的系统、服务、组件过多或者链路设计不合理导致的。 加人无法解决问题：即便你增加人员也难提高系统的交付速度和产出质量，比如原本3个人负责系统，增加到 6 个人的交付产出可能和 3 个人时所差无几，原因在于复杂度过高并且系统结构模糊，很难通过清晰的分工让生产力最大化。 而你可以结合这 4 点表现特征以及自己的主观感受进一步判断系统的复杂度是否过高，如果系统复杂度过高，可能带来一系列问题：迭代压力大、经常延期、稳定性问题频发等。这时，你要着手治理复杂度，尽力不让问题扩大到难以解决只能重做系统的程度。 复杂度治理的思路“高内聚、低耦合”，系统简化和分治。 简化就是去掉不必要的复杂，让设计与实现保持简单。 分治则是将原本难解决的问题，拆分到可解决的粒度，然后再逐一击破。 常见的拆分方式是垂直拆分和水平分层： 垂直拆分把差异明确可以独立迭代的业务拆分开；水平分层把共性的能力下沉隔离。比如电商场景中，购物车和订单可以分成两个服务，它们虽然在业务流程上前后关联，但是各自具备独立完整的业务场景和生命周期，商品加入购物车未必会交易生成订单，可以各自独立存在；而库存和商品则是强依赖的关系，库存无法独立于商品存在。 拆分与合并不绝对，过度地拆分会导致系统无法高内聚，零散分离的系统，会增加稳定性风险和治理与迭代的代价，并且造成大量的协作成本。Linus也曾说过：把复杂系统拆分成模块，似乎没有降低整个系统的复杂度，它降低的只是子系统的复杂度。而整个系统的复杂度，反而会由于拆分后的模块之间，不得不进行交互，变得更加复杂。 复杂度治理实践 相比 coding 更重视设计 永远做 2 套以上的方案 从 MVP 的视角考虑设计：从 MVP （最小完整业务的角度）去考虑系统要如何设计与实现，先做减法再做加法 关注上下游的实现 坚持“日拱一卒 没必要一定把系统做成中台没必要一定把系统做成中台，不做中台就会落后更是无稽之谈，不过，你可以借鉴中台的思路作为系统设计与演进上的形态参考。","categories":[{"name":"note","slug":"note","permalink":"http://github.13sai.com/categories/note/"}],"tags":[{"name":"note","slug":"note","permalink":"http://github.13sai.com/tags/note/"}]},{"title":"Protobuf语法","slug":"Protobuf语法","date":"2021-05-27T09:39:07.000Z","updated":"2021-05-27T10:07:07.826Z","comments":true,"path":"2021/05/27/340/","link":"","permalink":"http://github.13sai.com/2021/05/27/340/","excerpt":"","text":"Protobuf是Protocol Buffer的简称，它是Google公司开发的一种数据描述语言，用于描述一种轻便高效的结构化数据存储格式，是一种高效的数据格式，平台无关、语言无关、可扩展，常用于RPC系统和持续数据存储系统。 字段规则字段格式 限定修饰符 | 数据类型 | 字段名称 | = | 字段编码值 | [字段默认值] 限定修饰符 required、optional、repeated Required：表示是一个必须字段 Optional：表示一个可选字段。对于接收方，如果能够识别可选字段就进行相应的处理，如果无法识别，则忽略该字段 Repeated：表示该字段可以包含0-N个元素。其中特性和optional一样，但是每一次可以包含多个值。可以看做是在传递一个数组的值 数据类型Protobuf定义了一套基本数据类型： .proto 类型 Notes C++ Type Java Type Python Type Go Type Ruby Type C# Type PHP Type Dart Type double double double float float64 Float double float double float float float float float32 Float float float double int32 使用可变长度编码。编码负数的效率低 - 如果您的字段可能有负值，请改用sint32。 int32 int int int32 Fixnum or Bignum (as required) int integer int int64 使用可变长度编码。编码负数的效率低 - 如果您的字段可能有负值，请改用sint64。 int64 long int/long[] int64 Bignum long integer/string[] Int64 uint32 使用可变长度编码 uint32 int int/long uint32 Fixnum or Bignum (as required) uint integer int uint64 使用可变长度编码. uint64 long int/long uint64 Bignum ulong integer/string[] Int64 sint32 使用可变长度编码。签名的int值。这些比常规int32更有效地编码负数。 int32 int int int32 Fixnum or Bignum (as required) int integer int sint64 使用可变长度编码。签名的int值。这些比常规int64更有效地编码负数。 int64 long int/long int64 Bignum long integer/string[] Int64 fixed32 总是四个字节。如果值通常大于228，则比uint32更有效。 uint32 int int/long uint32 Fixnum or Bignum (as required) uint integer int fixed64 总是八个字节。如果值通常大于256，则比uint64更有效 uint64 long int/long[] uint64 Bignum ulong integer/string[] Int64 sfixed32 总是四个字节 int32 int int int32 Fixnum or Bignum (as required) int integer int sfixed64 总是八个字节 int64 long int/long int64 Bignum long integer/string[] Int64 bool bool boolean bool bool TrueClass/FalseClass bool boolean bool string 字符串必须始终包含UTF-8编码或7位ASCII文本，且不能超过232。 string String str/unicode string String (UTF-8) string string String bytes 可以包含不超过232的任意字节序列。 string ByteString str []byte String (ASCII-8BIT) ByteString string List 字段名称字段名称的命名与C、Java等语言的变量命名方式几乎是相同的protobuf 建议字段的命名采用以下划线分隔的驼峰式 字段编码值有了该值，通信双方才能互相识别对方的字段，相同的编码值，其限定修饰符和数据类型必须相同，编码值的取值范围为：1 ~ 2^32 (4294967296)其中 1 ~ 15的编码时间和空间效率都是最高的，编码值越大，其编码的时间和空间效率就越低1900 ~ 2000 编码值为 Google protobuf 系统内部保留值，建议不要在项目中使用 字段默认值当在传递数据时，对于required数据类型，如果用户没有设置值，则使用默认值传递到对端 定义service 如果想要将消息类型用在 RPC 系统中，可以在 .proto文件中定义一个 RPC 服务接口，protocol buffer 编译器会根据所选择的不同语言生成服务接口代码 生成的接口代码作为客户端与服务端的约定，服务端必须实现定义的所有接口方法，客户端直接调用同名方法向服务端发起请求（即便业务上不需要参数也必须指定一个请求消息，一般会定义一个空message） 比如，想要定义一个 RPC 服务并具有一个方法，该方法接收 SearchRequest 并返回一个 SearchResponse，此时可以在.proto文件中进行如下定义： 123service SearchService &#123; rpc Search(SearchRequest) returns (SearchResponse) &#123;&#125;&#125; 定义Message 一个 message 类型定义描述了一个请求或响应的消息格式，可以包含多种类型字段 字段名用小写，转为 go 文件后自动变为大写，message 就相当于结构体 添加更多 Message 类型一个 .proto 文件中可以定义多个消息类型，一般用于同时定义多个相关的消息，例如在同一个 .proto 文件中同时定义搜索请求和响应消息： 1234567891011// 声明使用的 protobuf 版本syntax = &quot;proto3&quot;message SearchRequest &#123; string query = 1; int32 page_number = 2; int32 result_per_page = ;&#125;message SearchResponse &#123;&#125; 使用其他 Messagemessage 支持嵌套使用，作为另一个 message 中的字段类型 123456789message SearchResponse &#123; repeated Result results = 1;&#125;message Result &#123; string url = 1; string title = 2; repeated string snippets = ;&#125; Message 嵌套的使用支持嵌套消息，消息可以包含另一个消息作为字段。也可以在消息内定义一个新的消息。 内部声明的 message 类型名称只可在内部直接使用： 12345678message SearchResponse &#123; message Result &#123; string url = 1; string title = 2; repeated string snippets = ; &#125; repeated Result results = 1;&#125; 多层嵌套： 1234567891011121314message Outer &#123; message A &#123; message Inner &#123; int64 ival = 1; bool booly = 2; &#125; &#125; message B &#123; message Inner &#123; int64 ival = 1; bool booly = 2; &#125; &#125;&#125; 映射字段每个映射字段会在Go的结构体中生成一个map[TKey]TValue类型的字段，其中TKey是字段的键类型TValue是字段的值类型。对于下面这个消息定义： 12345message Bar &#123;&#125;message Baz &#123; map&lt;string, Bar&gt; foo = 1;&#125; 编译器生成Go结构体 1234type Baz struct &#123; Foo map[string]*Bar&#125; 枚举给出如下枚举 1234567891011121314message SearchRequest &#123; enum Corpus &#123; UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; &#125; Corpus corpus = 1; ...&#125; 编译器将会生成一个枚举类型和一系列该类型的常量。 .proto 文件编译代码 通过定义好的 .proto 文件生成 Go、PHP、Java、Python等代码，需要安装编译器 protoc。 使用 protobuf 编译器不同的语言生成的代码格式不同，比如Go：生成一个 .pb.go 文件，每个消息类型对应一个结构体。 具体protoc安装和代码生成可见：gRPC初体验 也有看到部分项目使用protobuf去替代json去进行前后端数据交换。 参考： Protobuf 语法 Protobuf语言指南 Protobuf生成Go代码指南","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"Go错误处理最佳实践","slug":"Go错误处理最佳实践","date":"2021-05-23T05:37:50.000Z","updated":"2021-06-20T13:41:58.564Z","comments":true,"path":"2021/05/23/338/","link":"","permalink":"http://github.13sai.com/2021/05/23/338/","excerpt":"","text":"Form: lailin.xyz-Go错误处理最佳实践 最佳实践太长不看系列，我们总结一下在 go 中 如何处理 error，具体的原因我们会在下面的内容中进行详细的解释 panic 在程序启动的时候，如果有强依赖的服务出现故障时 panic 退出 在程序启动的时候，如果发现有配置明显不符合要求， 可以 panic 退出（防御编程） 其他情况下只要不是不可恢复的程序错误，都不应该直接 panic 应该返回 error 在程序入口处，例如 gin 中间件需要使用 recover 预防 panic 程序退出 在程序中我们应该避免使用野生的goroutine 如果是在请求中需要执行异步任务，应该使用异步 worker ，消息通知的方式进行处理，避免请求量大时大量 goroutine 创建 如果需要使用 goroutine 时，应该使用同一的 Go 函数进行创建，这个函数中会进行 recover ，避免因为野生 goroutine panic 导致主进程退出 1234567891011func Go(f func())&#123; go func()&#123; defer func()&#123; if err := recover(); err != nil &#123; log.Printf(&quot;panic: %+v&quot;, err) &#125; &#125;() f() &#125;()&#125; error 我们在应用程序中使用 github.com/pkg/errors 处理应用错误，注意在公共库当中，我们一般不使用这个 error应该是函数的最后一个返回值，当error不为 nil时，函数的其他返回值是不可用的状态，不应该对其他返回值做任何期待 func f() (io.Reader, *S1, error) 在这里，我们不知道 io.Reader 中是否有数据，可能有，也有可能有一部分 错误处理的时候应该先判断错误， if err != nil 出现错误及时返回，使代码是一条流畅的直线，避免过多的嵌套. 1234567891011121314151617181920// good casefunc f() error &#123; a, err := A() if err != nil &#123; return err &#125; // ... 其他逻辑 return nil&#125;// bad casefunc f() error &#123; a, err := A() if err == nil &#123; // 其他逻辑 &#125; return err&#125; 在应用程序中出现错误时，使用 errors.New 或者 errors.Errorf 返回错误 12345678func (u *usecese) usecase1() error &#123; money := u.repo.getMoney(uid) if money &lt; 10 &#123; errors.Errorf(&quot;用户余额不足, uid: %d, money: %d&quot;, uid, money) &#125; // 其他逻辑 return nil&#125; 如果是调用应用程序的其他函数出现错误，请直接返回，如果需要携带信息，请使用 errors.WithMessage 12345678910func (u *usecese) usecase2() error &#123; name, err := u.repo.getUserName(uid) if err != nil &#123; return errors.WithMessage(err, &quot;其他附加信息&quot;) &#125; // 其他逻辑 return nil&#125; 如果是调用其他库（标准库、企业公共库、开源第三方库等）获取到错误时，请使用 errors.Wrap 添加堆栈信息 切记，不要每个地方都是用 errors.Wrap 只需要在错误第一次出现时进行 errors.Wrap 即可 根据场景进行判断是否需要将其他库的原始错误吞掉，例如可以把 repository 层的数据库相关错误吞掉，返回业务错误码，避免后续我们分割微服务或者更换 ORM 库时需要去修改上层代码 注意我们在基础库，被大量引入的第三方库编写时一般不使用 errors.Wrap 避免堆栈信息重复 123456789func f() error &#123; err := json.Unmashal(&amp;a, data) if err != nil &#123; return errors.Wrap(err, &quot;其他附加信息&quot;) &#125; // 其他逻辑 return nil&#125; 禁止每个出错的地方都打日志，只需要在进程的最开始的地方使用 %+v 进行统一打印，例如 http/rpc 服务的中间件 错误判断使用 errors.Is 进行比较 12345678910func f() error &#123; err := A() if errors.Is(err, io.EOF)&#123; return nil &#125; // 其他逻辑 return nil&#125; 错误类型判断，使用 errors.As 进行赋值 123456789101112func f() error &#123; err := A() var errA errorA if errors.As(err, &amp;errA)&#123; // ... &#125; // 其他逻辑 return nil&#125; 如何判定错误的信息是否足够，想一想当你的代码出现问题需要排查的时候你的错误信息是否可以帮助你快速的定位问题，例如我们在请求中一般会输出参数信息，用于辅助判断错误 对于业务错误，推荐在一个统一的地方创建一个错误字典，错误字典里面应该包含错误的 code，并且在日志中作为独立字段打印，方便做业务告警的判断，错误必须有清晰的错误文档 不需要返回，被忽略的错误必须输出日志信息 同一个地方不停的报错，最好不要不停输出错误日志，这样可能会导致被大量的错误日志信息淹没，无法排查问题，比较好的做法是打印一次错误详情，然后打印出错误出现的次数 对同一个类型的错误，采用相同的模式，例如参数错误，不要有的返回 404 有的返回 200 处理错误的时候，需要处理已分配的资源，使用 defer 进行清理，例如文件句柄 panic or error? 在 Go 中 panic 会导致程序直接退出，是一个致命的错误，如果使用 panic recover 进行处理的话，会存在很多问题 性能问题，频繁 panic recover 性能不好 容易导致程序异常退出，只要有一个地方没有处理到就会导致程序进程整个退出 不可控，一旦 panic 就将处理逻辑移交给了外部，我们并不能预设外部包一定会进行处理 什么时候使用 panic 呢？ 对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic 使用 error 处理有哪些好处？ 简单。 考虑失败，而不是成功(Plan for failure, not success)。 没有隐藏的控制流。 完全交给你来控制 error。 Error are values。 为什么标准库中 errors.New 会返回一个指针翻看标准库的源代码我们可以发现， errors 库中的 errorString 结构体实现了 error 接口，为什么在 New 一个 error 的时候会返回一个结构体的指针呢？ 123456789101112131415// New returns an error that formats as the given text.// Each call to New returns a distinct error value even if the text is identical.func New(text string) error &#123; return &amp;errorString&#123;text&#125;&#125;// errorString is a trivial implementation of error.type errorString struct &#123; s string&#125;func (e *errorString) Error() string &#123; return e.s&#125; 我们先来看一个例子，我们同样创建了 errorString 的结构体，我们自定义的和标准库中的唯一不同就是，自建的这个返回的是值，而不是指针。在 main 函数的对比中我们就可以发现，我们自定义的 errorString 在对比的时候只要对应的字符串相同就会返回 true，但是标准库的包不会。这是因为，在对比两个 struct 是否相同的时候，会去对比，这两个 struct 里面的各个字段是否是相同的，如果相同就返回 true，但是对比指针的时候会去判断两个指针的地址是否一致。如果字符串相等就返回 true 会导致什么问题呢？如果我有两个包定义了字符串相同的想个错误，在其他库调用对比的时候，可能会由于不同的书写顺序走进不同的分支导致一些不可预期的奇奇怪怪的错误 1234567891011121314151617181920212223242526type errorString struct &#123; text string&#125;func (e errorString) Error() string &#123; return e.text&#125;// New 创建一个自定义错误func New(s string) error &#123; return errorString&#123;text: s&#125;&#125;var errorString1 = New(&quot;test a&quot;)var err1 = errors.New(&quot;test b&quot;)func main() &#123; if errorString1 == New(&quot;test a&quot;) &#123; fmt.Println(&quot;err string a&quot;) // 会输出 &#125; if err1 == errors.New(&quot;test b&quot;) &#123; fmt.Println(&quot;err b&quot;) // 不会输出 &#125;&#125; error type: 错误定义与判断Sentinel Error哨兵错误，就是定义一些包级别的错误变量，然后在调用的时候外部包可以直接对比变量进行判定，在标准库当中大量的使用了这种方式例如下方 io 库中定义的错误 123456789101112131415// EOF is the error returned by Read when no more input is available.// Functions should return EOF only to signal a graceful end of input.// If the EOF occurs unexpectedly in a structured data stream,// the appropriate error is either ErrUnexpectedEOF or some other error// giving more detail.var EOF = errors.New(&quot;EOF&quot;)// ErrUnexpectedEOF means that EOF was encountered in the// middle of reading a fixed-size block or data structure.var ErrUnexpectedEOF = errors.New(&quot;unexpected EOF&quot;)// ErrNoProgress is returned by some clients of an io.Reader when// many calls to Read have failed to return any data or error,// usually the sign of a broken io.Reader implementation.var ErrNoProgress = errors.New(&quot;multiple Read calls return no data or error&quot;) 我们在外部判定的时候一般使用等值判定或者使用 errors.Is 进行判断 1234567if err == io.EOF &#123; //...&#125;if errors.Is(err, io.EOF)&#123; //...&#125; 这种错误处理方式有一个问题是，将 error 当做包的 API 暴露给了第三方，这样会导致在做重构或者升级的时候很麻烦，并且这种方式包含的错误信息会十分的有限 error types这个就类似我们前面定义的 errorString 一样实现了 error 的接口，然后在外部是否类型断言来判断是否是这种错误类型 123456789101112131415161718type MyStruct struct &#123; s string name string path string&#125;// 使用的时候func f() &#123; switch err.(type) &#123; case *MyStruct: // ... case others: // ... &#125;&#125; 这种方式相对于哨兵来说，可以包含更加丰富的信息，但是同样也将错误的类型暴露给了外部，例如标准库中的 os.PathError Opaque errors不透明的错误处理，这种方式最大的特点就是只返回错误，暴露错误判定接口，不返回类型，这样可以减少 API 的暴露，后续的处理会比较灵活，这个一般用在公共库会比较好 12345678type temporary interface &#123; Temporary() bool&#125;func IsTemporary(err error) bool &#123; te, ok := err.(temporary) return ok &amp;&amp; te.Temporary()&#125; 这种方式我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值 error handle: 错误处理优化在 go 中常常会存在大量的 if err 代码，下面介绍两种常见的减少这种代码的方式 bufio.scan对比下面两个函数的处理我们可以发现， count2 使用 sc.Scan 之后一个 if err 的判断都没有，极大的简化了代码，这是因为在 sc.Scan 做了很多处理，像很多类似的，需要循环读取的都可以考虑像这样包装之后进行处理，这样外部包调用的时候就会非常简洁 1234567891011121314151617181920212223242526272829303132333435363738// 统计文件行数func count(r io.Reader) (int, error) &#123; var ( br = bufio.NewReader(r) lines int err error ) for &#123; // 读取到换行符就说明是一行 _, err = br.ReadString(&#x27;\\n&#x27;) lines++ if err != nil &#123; break &#125; &#125; // 当错误是 EOF 的时候说明文件读取完毕了 if err != io.EOF &#123; return 0, err &#125; return lines, err&#125;func count2(r io.Reader) (int, error) &#123; var ( sc = bufio.NewScanner(r) lines int ) for sc.Scan() &#123; lines++ &#125; return lines, sc.Err()&#125; error writer看一个来自 go blog 的例子：https://blog.golang.org/errors-are-values一般代码 12345678910111213_, err = fd.Write(p0[a:b])if err != nil &#123; return err&#125;_, err = fd.Write(p1[c:d])if err != nil &#123; return err&#125;_, err = fd.Write(p2[e:f])if err != nil &#123; return err&#125;// and so on errWriter 12345678910111213141516171819202122type errWriter struct &#123; w io.Writer err error&#125;func (ew *errWriter) write(buf []byte) &#123; if ew.err != nil &#123; return &#125; _, ew.err = ew.w.Write(buf)&#125;// 使用时ew := &amp;errWriter&#123;w: fd&#125;ew.write(p0[a:b])ew.write(p1[c:d])ew.write(p2[e:f])// and so onif ew.err != nil &#123; return ew.err&#125; 如果去翻 标准库中 bufio.Writer 的源代码，你会发现也有这种用法，这种就是将重复的逻辑进行了封装，然后把 error 暂存，然后我们就只需要在最后判断一下 error 就行了 wrap error: 错误包装errors.wrap 有何作用，为什么不用标准库的 fmt.Errorf(&quot;%w&quot;)我们先看一下标准库的源码，我们可以发现当 p.wrappedErr != nil 的时候（也就是有 %w）的时候，会使用一个 wrapError 将错误包装，看 wrapError 的源码可以发现，这个方法只是包装了一下原始错误，并且可以做到附加一些文本信息，但是没有堆栈信息。 12345678910111213141516171819202122232425262728func Errorf(format string, a ...interface&#123;&#125;) error &#123; p := newPrinter() p.wrapErrs = true p.doPrintf(format, a) s := string(p.buf) var err error if p.wrappedErr == nil &#123; err = errors.New(s) &#125; else &#123; err = &amp;wrapError&#123;s, p.wrappedErr&#125; &#125; p.free() return err&#125;type wrapError struct &#123; msg string err error&#125;func (e *wrapError) Error() string &#123; return e.msg&#125;func (e *wrapError) Unwrap() error &#123; return e.err&#125; 在看一下 pkg/errors 的源码，我肯可以发现除了使用 withMessage 附加了错误信息之外还使用 withStack 附加了堆栈信息，这样我们在程序入口处打印日志信息的时候就可以将堆栈信息一并打出了 1234567891011121314151617// Wrap returns an error annotating err with a stack trace// at the point Wrap is called, and the supplied message.// If err is nil, Wrap returns nil.func Wrap(err error, message string) error &#123; if err == nil &#123; return nil &#125; err = &amp;withMessage&#123; cause: err, msg: message, &#125; return &amp;withStack&#123; err, callers(), &#125;&#125; 为什么不允许处处使用 errors.Wrap因为每一次 errors.Wrap 的调用都会为错误添加堆栈信息，如果处处调用那会有大量的无用堆栈我们先看一下只有一处 wrap 12345678910111213141516func main() &#123; fmt.Printf(&quot;err: %+v&quot;, c())&#125;func a() error &#123; return errors.Wrap(fmt.Errorf(&quot;xxx&quot;), &quot;test&quot;)&#125;func b() error &#123; return a()&#125;func c() error &#123; return b()&#125; 看结果我们可以发现已经可以打印出全部的堆栈信息了 123456789101112131415err: xxxtestmain.a /home/ll/project/Go-000/Week02/blog/wrap.go:14main.b /home/ll/project/Go-000/Week02/blog/wrap.go:18main.c /home/ll/project/Go-000/Week02/blog/wrap.go:22main.main /home/ll/project/Go-000/Week02/blog/wrap.go:10runtime.main /usr/local/go/src/runtime/proc.go:204runtime.goexit /usr/local/go/src/runtime/asm_amd64.s:1374 再看多处 wrap 的现象 12345678910111213141516func main() &#123; fmt.Printf(&quot;err: %+v&quot;, c())&#125;func a() error &#123; return errors.Wrap(fmt.Errorf(&quot;xxx&quot;), &quot;a&quot;)&#125;func b() error &#123; return errors.Wrap(a(), &quot;b&quot;)&#125;func c() error &#123; return errors.Wrap(b(), &quot;c&quot;)&#125; 可以看到每一处 wrap 都添加了一次堆栈信息 1234567891011121314151617181920212223242526272829303132333435err: xxxamain.a /home/ll/project/Go-000/Week02/blog/wrap.go:14main.b /home/ll/project/Go-000/Week02/blog/wrap.go:18main.c /home/ll/project/Go-000/Week02/blog/wrap.go:22main.main /home/ll/project/Go-000/Week02/blog/wrap.go:10runtime.main /usr/local/go/src/runtime/proc.go:204runtime.goexit /usr/local/go/src/runtime/asm_amd64.s:1374bmain.b /home/ll/project/Go-000/Week02/blog/wrap.go:18main.c /home/ll/project/Go-000/Week02/blog/wrap.go:22main.main /home/ll/project/Go-000/Week02/blog/wrap.go:10runtime.main /usr/local/go/src/runtime/proc.go:204runtime.goexit /usr/local/go/src/runtime/asm_amd64.s:1374cmain.c /home/ll/project/Go-000/Week02/blog/wrap.go:22main.main /home/ll/project/Go-000/Week02/blog/wrap.go:10runtime.main /usr/local/go/src/runtime/proc.go:204runtime.goexit /usr/local/go/src/runtime/asm_amd64.s:1374 标准库 errors.Is / As 怎么判断错误errors.Is1234567891011121314151617181920212223func Is(err, target error) bool &#123; if target == nil &#123; return err == target &#125; // 通过反射判读 target 是否可以被比较 isComparable := reflectlite.TypeOf(target).Comparable() for &#123; // 循环判断是否相等 if isComparable &amp;&amp; err == target &#123; return true &#125; // 判断是否实现了 is 接口，如果有实现就直接判断 if x, ok := err.(interface&#123; Is(error) bool &#125;); ok &amp;&amp; x.Is(target) &#123; return true &#125; // 去判断是否实现了 unwrap 的接口，如果实现了就进行 unwrap if err = Unwrap(err); err == nil &#123; return false &#125; &#125;&#125; errors.As和 is 的逻辑类似，就是不断的进行 unwrap 进行比较，只要有一个相同就返回，如果一直到底都不行就返回 false 12345678910111213141516171819202122232425func As(err error, target interface&#123;&#125;) bool &#123; if target == nil &#123; panic(&quot;errors: target cannot be nil&quot;) &#125; val := reflectlite.ValueOf(target) typ := val.Type() if typ.Kind() != reflectlite.Ptr || val.IsNil() &#123; panic(&quot;errors: target must be a non-nil pointer&quot;) &#125; if e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) &#123; panic(&quot;errors: *target must be interface or implement error&quot;) &#125; targetType := typ.Elem() for err != nil &#123; if reflectlite.TypeOf(err).AssignableTo(targetType) &#123; val.Elem().Set(reflectlite.ValueOf(err)) return true &#125; if x, ok := err.(interface&#123; As(interface&#123;&#125;) bool &#125;); ok &amp;&amp; x.As(target) &#123; return true &#125; err = Unwrap(err) &#125; return false&#125;","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"go源码学习笔记","slug":"go源码学习笔记","date":"2021-05-07T05:23:27.000Z","updated":"2021-05-07T05:28:29.046Z","comments":true,"path":"2021/05/07/337/","link":"","permalink":"http://github.13sai.com/2021/05/07/337/","excerpt":"","text":"最近有尝试慢慢阅读下go标准库，常用的标准库，会做一些阅读笔记，以陆续发了三五篇，直达专栏-go源码学习笔记。 不定期发布，有兴趣关注下。 go源码之context go源码之x/time/rate go源码之sync.Map go源码之sync.Once go源码之atomic","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"互斥锁、自旋锁、读写锁、悲观锁、乐观锁","slug":"互斥锁、自旋锁、读写锁、悲观锁、乐观锁","date":"2021-05-02T03:30:53.000Z","updated":"2021-05-02T03:33:34.765Z","comments":true,"path":"2021/05/02/336/","link":"","permalink":"http://github.13sai.com/2021/05/02/336/","excerpt":"","text":"From:小林coding-面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景 前言在编程世界里，「锁」更是五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。 如何用好锁，也是程序员的基本素养之一了。 高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。 所以，知道各种锁的开销，以及应用场景是很有必要的。 接下来，就谈一谈常见的这几种锁： 正文多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。 最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。 如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。 所以，为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。 对症下药，才能减少锁对高并发性能的影响。 那接下来，针对不同的应用场景，谈一谈「互斥锁、自旋锁、读写锁、乐观锁、悲观锁」的选择和使用。 互斥锁与自旋锁：谁更轻松自如？最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。 加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。 当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的： 互斥锁加锁失败后，线程会释放 CPU ，给其他线程； 自旋锁加锁失败后，线程会忙等待，直到它拿到锁； 互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。 对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图： 所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。 那这个开销成本是什么呢？会有两次线程上下文切换的成本： 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行； 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。 线程的上下文切换的是什么？当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。 上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。 所以，如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。 自旋锁是通过 CPU 提供的 CAS 函数（Compare And Swap），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。 一般加锁的过程，包含两个步骤： 第一步，查看锁的状态，如果锁是空闲的，则执行第二步； 第二步，将锁设置为当前线程持有； CAS 函数就把这两个步骤合并成一条硬件级指令，形成原子指令，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。 使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 while 循环等待实现，不过最好是使用 CPU 提供的 PAUSE 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。 自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。 自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。 自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对。 它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。 读写锁：读和写还有优先级区分？读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。 所以，读写锁适用于能明确区分读操作和写操作的场景。 读写锁的工作原理是： 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。 所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。 知道了读写锁的工作原理后，我们可以发现，读写锁在读多写少的场景，能发挥出优势。 另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。 读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图： 而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图： 读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。 写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。 既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。 公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。 互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。 乐观锁与悲观锁：做事的心态有何不同？前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。 悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。 那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。 乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。 放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。 可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现乐观锁全程并没有加锁，所以它也叫无锁编程。 这里举一个场景例子：在线文档。 我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。 那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。 怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。 服务端要怎么验证是否冲突了呢？通常方案如下： 由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号； 当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。 实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。 乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。 总结开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。 如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。 如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。 互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。 另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。 相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。 但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。 不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。","categories":[{"name":"base","slug":"base","permalink":"http://github.13sai.com/categories/base/"}],"tags":[{"name":"base","slug":"base","permalink":"http://github.13sai.com/tags/base/"}]},{"title":"golang的单引号双引号反引号","slug":"golang的单引号双引号反引号","date":"2021-04-29T14:59:55.000Z","updated":"2021-04-29T15:15:48.541Z","comments":true,"path":"2021/04/29/335/","link":"","permalink":"http://github.13sai.com/2021/04/29/335/","excerpt":"","text":"单引号Single quote，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。 双引号Double quote，表示字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。 反引号Back quote，表示字符串字面量，与双引号不同，它不支持任何转义序列，但支持换行书写。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。 1234567891011121314151617181920212223a := &#x27;a&#x27;b := &quot;b\\naa&quot;c := `c3ww`var d byte = &#x27;d&#x27;fmt.Println(b)fmt.Println(c)fmt.Printf(&quot;Single quote type:%T\\n&quot;, a)fmt.Printf(&quot;Double quote type:%T\\n&quot;, b)fmt.Printf(&quot;Back quote type:%T\\n&quot;, c)fmt.Printf(&quot;Single quote type:%T\\n&quot;, d)output:------baac 3wwSingle quote type:int32Double quote type:stringBack quote type:stringSingle quote type:uint8","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"MAC安装rabbitmq扩展","slug":"MAC安装rabbitmq扩展","date":"2021-04-29T03:36:56.000Z","updated":"2021-04-29T11:52:43.695Z","comments":true,"path":"2021/04/29/333/","link":"","permalink":"http://github.13sai.com/2021/04/29/333/","excerpt":"","text":"PHP结合rabbitMQ需要安装amqp扩展，之前又在windows安装，今天尝试mac安装一下。 下载 前去amqp，下载需要的版本。 安装 1234phpize// --with-php-config 路径自己修改./configure --with-php-config=xxx/php-configmake &amp;&amp; make install 如果没装rabbitmq-c，应该会报错。 1configure: error: Please reinstall the librabbitmq distribution itself or (re)install librabbitmq development package if it available in your system 下载rabbitmq-c 123cd rabbitmq-c-0.8.0./configure --prefix=/usr/local/rabbitmq-cmake &amp;&amp; make install 重新编译amqp 12./configure --with-php-config=xxx/php-config --with-amqp --with-librabbitmq-dir=/usr/local/rabbitmq-c/make &amp;&amp; make install make时提示缺少amqp_ssl_socket.hfatal error: ‘amqp_ssl_socket.h’ file not found#include &lt;amqp_ssl_socket.h&gt; 这里可以看一下 https://github.com/alanxz/rabbitmq-c/issues/463 然后可以把rabbitmq-c的librabbitmq下amqp_ssl_socket.h文件copy到amqp扩展目录，重新编译即可。 安装成功记得在ini加入extension=”amqp.so”，最后可以使用php -m","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"Docker核心技术与实现原理","slug":"Docker核心技术与实现原理","date":"2021-04-26T03:23:30.000Z","updated":"2021-04-26T03:28:34.862Z","comments":true,"path":"2021/04/26/332/","link":"","permalink":"http://github.13sai.com/2021/04/26/332/","excerpt":"","text":"From: Docker 核心技术与实现原理PS：推荐下draveness的Go 语言设计与实现，很赞 Docker 核心技术与实现原理提到虚拟化技术，我们首先想到的一定是 Docker，经过四年的快速发展 Docker 已经成为了很多公司的标配，也不再是一个只能在开发阶段使用的玩具了。作为在生产环境中广泛应用的产品，Docker 有着非常成熟的社区以及大量的使用者，代码库中的内容也变得非常庞大。 同样，由于项目的发展、功能的拆分以及各种奇怪的改名 PR，让我们再次理解 Docker 的整体架构变得更加困难。 虽然 Docker 目前的组件较多，并且实现也非常复杂，但是本文不想过多的介绍 Docker 具体的实现细节，我们更想谈一谈 Docker 这种虚拟化技术的出现有哪些核心技术的支撑。 首先，Docker 的出现一定是因为目前的后端在开发和运维阶段确实需要一种虚拟化技术解决开发环境和生产环境环境一致的问题，通过 Docker 我们可以将程序运行的环境也纳入到版本控制中，排除因为环境造成不同运行结果的可能。但是上述需求虽然推动了虚拟化技术的产生，但是如果没有合适的底层技术支撑，那么我们仍然得不到一个完美的产品。本文剩下的内容会介绍几种 Docker 使用的核心技术，如果我们了解它们的使用方法和原理，就能清楚 Docker 的实现原理。 Namespaces命名空间 (namespaces) 是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。 在这种情况下，一旦服务器上的某一个服务被入侵，那么入侵者就能够访问当前机器上的所有服务和文件，这也是我们不想看到的，而 Docker 其实就通过 Linux 的 Namespaces 对不同的容器实现了隔离。 Linux 的命名空间机制提供了以下七种不同的命名空间，包括 CLONE_NEWCGROUP、CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER 和 CLONE_NEWUTS，通过这七个选项我们能在创建新的进程时设置新进程应该在哪些资源上与宿主机器进行隔离。 进程进程是 Linux 以及现在操作系统中非常重要的概念，它表示一个正在执行的程序，也是在现代分时系统中的一个任务单元。在每一个 *nix 的操作系统上，我们都能够通过 ps 命令打印出当前操作系统中正在执行的进程，比如在 Ubuntu 上，使用该命令就能得到以下的结果： 12345678910$ ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 Apr08 ? 00:00:09 /sbin/initroot 2 0 0 Apr08 ? 00:00:00 [kthreadd]root 3 2 0 Apr08 ? 00:00:05 [ksoftirqd/0]root 5 2 0 Apr08 ? 00:00:00 [kworker/0:0H]root 7 2 0 Apr08 ? 00:07:10 [rcu_sched]root 39 2 0 Apr08 ? 00:00:00 [migration/0]root 40 2 0 Apr08 ? 00:01:54 [watchdog/0]... Shell 当前机器上有很多的进程正在执行，在上述进程中有两个非常特殊，一个是 pid 为 1 的 /sbin/init 进程，另一个是 pid 为 2 的 kthreadd 进程，这两个进程都是被 Linux 中的上帝进程 idle 创建出来的，其中前者负责执行内核的一部分初始化工作和系统配置，也会创建一些类似 getty 的注册进程，而后者负责管理和调度其他的内核进程。 如果我们在当前的 Linux 操作系统下运行一个新的 Docker 容器，并通过 exec 进入其内部的 bash 并打印其中的全部进程，我们会得到以下的结果： 12345678root@iZ255w13cy6Z:~# docker run -it -d ubuntub809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79root@iZ255w13cy6Z:~# docker exec -it b809a2eb3630 /bin/bashroot@b809a2eb3630:/# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 15:42 pts/0 00:00:00 /bin/bashroot 9 0 0 15:42 pts/1 00:00:00 /bin/bashroot 17 9 0 15:43 pts/1 00:00:00 ps -ef Shell 在新的容器内部执行 ps 命令打印出了非常干净的进程列表，只有包含当前 ps -ef 在内的三个进程，在宿主机器上的几十个进程都已经消失不见了。 当前的 Docker 容器成功将容器内的进程与宿主机器中的进程隔离，如果我们在宿主机器上打印当前的全部进程时，会得到下面三条与 Docker 相关的结果： 1234UID PID PPID C STIME TTY TIME CMDroot 29407 1 0 Nov16 ? 00:08:38 /usr/bin/dockerd --raw-logsroot 1554 29407 0 Nov19 ? 00:03:28 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runcroot 5006 1554 0 08:38 ? 00:00:00 docker-containerd-shim b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79 /var/run/docker/libcontainerd/b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79 docker-runc Shell 在当前的宿主机器上，可能就存在由上述的不同进程构成的进程树： 这就是在使用 clone(2) 创建新进程时传入 CLONE_NEWPID 实现的，也就是使用 Linux 的命名空间实现进程的隔离，Docker 容器内部的任意进程都对宿主机器的进程一无所知。 12345containerRouter.postContainersStart└── daemon.ContainerStart └── daemon.createSpec └── setNamespaces └── setNamespace Go Docker 的容器就是使用上述技术实现与宿主机器的进程隔离，当我们每次运行 docker run 或者 docker start 时，都会在下面的方法中创建一个用于设置进程间隔离的 Spec： 12345678910func (daemon *Daemon) createSpec(c *container.Container) (*specs.Spec, error) &#123; s := oci.DefaultSpec() // ... if err := setNamespaces(daemon, &amp;s, c); err != nil &#123; return nil, fmt.Errorf(&quot;linux spec namespaces: %v&quot;, err) &#125; return &amp;s, nil&#125; Go 在 setNamespaces 方法中不仅会设置进程相关的命名空间，还会设置与用户、网络、IPC 以及 UTS 相关的命名空间： 123456789101112131415161718192021222324func setNamespaces(daemon *Daemon, s *specs.Spec, c *container.Container) error &#123; // user // network // ipc // uts // pid if c.HostConfig.PidMode.IsContainer() &#123; ns := specs.LinuxNamespace&#123;Type: &quot;pid&quot;&#125; pc, err := daemon.getPidContainer(c) if err != nil &#123; return err &#125; ns.Path = fmt.Sprintf(&quot;/proc/%d/ns/pid&quot;, pc.State.GetPID()) setNamespace(s, ns) &#125; else if c.HostConfig.PidMode.IsHost() &#123; oci.RemoveNamespace(s, specs.LinuxNamespaceType(&quot;pid&quot;)) &#125; else &#123; ns := specs.LinuxNamespace&#123;Type: &quot;pid&quot;&#125; setNamespace(s, ns) &#125; return nil&#125; Go 所有命名空间相关的设置 Spec 最后都会作为 Create 函数的入参在创建新的容器时进行设置： 1daemon.containerd.Create(context.Background(), container.ID, spec, createOptions) Go 所有与命名空间的相关的设置都是在上述的两个函数中完成的，Docker 通过命名空间成功完成了与宿主机进程和网络的隔离。 网络如果 Docker 的容器通过 Linux 的命名空间完成了与宿主机进程的网络隔离，但是却又没有办法通过宿主机的网络与整个互联网相连，就会产生很多限制，所以 Docker 虽然可以通过命名空间创建一个隔离的网络环境，但是 Docker 中的服务仍然需要与外界相连才能发挥作用。 每一个使用 docker run 启动的容器其实都具有单独的网络命名空间，Docker 为我们提供了四种不同的网络模式，Host、Container、None 和 Bridge 模式。 在这一部分，我们将介绍 Docker 默认的网络设置模式：网桥模式。在这种模式下，除了分配隔离的网络命名空间之外，Docker 还会为所有的容器设置 IP 地址。当 Docker 服务器在主机上启动之后会创建新的虚拟网桥 docker0，随后在该主机上启动的全部服务在默认情况下都与该网桥相连。 在默认情况下，每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在创建的容器中，会加入到名为 docker0 网桥中。我们可以使用如下的命令来查看当前网桥的接口： 1234$ brctl showbridge name bridge id STP enabled interfacesdocker0 8000.0242a6654980 no veth3e84d4f veth9953b75 Sh docker0 会为每一个容器分配一个新的 IP 地址并将 docker0 的 IP 地址设置为默认的网关。网桥 docker0 通过 iptables 中的配置与宿主机器上的网卡相连，所有符合条件的请求都会通过 iptables 转发到 docker0 并由网桥分发给对应的机器。 12345678$ iptables -t nat -LChain PREROUTING (policy ACCEPT)target prot opt source destinationDOCKER all -- anywhere anywhere ADDRTYPE match dst-type LOCALChain DOCKER (2 references)target prot opt source destinationRETURN all -- anywhere anywhere Sh 我们在当前的机器上使用 docker run -d -p 6379:6379 redis 命令启动了一个新的 Redis 容器，在这之后我们再查看当前 iptables 的 NAT 配置就会看到在 DOCKER 的链中出现了一条新的规则： 1DNAT tcp -- anywhere anywhere tcp dpt:6379 to:192.168.0.4:6379 Sh 上述规则会将从任意源发送到当前机器 6379 端口的 TCP 包转发到 192.168.0.4:6379 所在的地址上。 这个地址其实也是 Docker 为 Redis 服务分配的 IP 地址，如果我们在当前机器上直接 ping 这个 IP 地址就会发现它是可以访问到的： 12345678$ ping 192.168.0.4PING 192.168.0.4 (192.168.0.4) 56(84) bytes of data.64 bytes from 192.168.0.4: icmp_seq=1 ttl=64 time=0.069 ms64 bytes from 192.168.0.4: icmp_seq=2 ttl=64 time=0.043 ms^C--- 192.168.0.4 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 999msrtt min/avg/max/mdev = 0.043/0.056/0.069/0.013 ms Sh 从上述的一系列现象，我们就可以推测出 Docker 是如何将容器的内部的端口暴露出来并对数据包进行转发的了；当有 Docker 的容器需要将服务暴露给宿主机器，就会为容器分配一个 IP 地址，同时向 iptables 中追加一条新的规则。 当我们使用 redis-cli 在宿主机器的命令行中访问 127.0.0.1:6379 的地址时，经过 iptables 的 NAT PREROUTING 将 ip 地址定向到了 192.168.0.4，重定向过的数据包就可以通过 iptables 中的 FILTER 配置，最终在 NAT POSTROUTING 阶段将 ip 地址伪装成 127.0.0.1，到这里虽然从外面看起来我们请求的是 127.0.0.1:6379，但是实际上请求的已经是 Docker 容器暴露出的端口了。 12$ redis-cli -h 127.0.0.1 -p 6379 pingPONG Sh Docker 通过 Linux 的命名空间实现了网络的隔离，又通过 iptables 进行数据包转发，让 Docker 容器能够优雅地为宿主机器或者其他容器提供服务。 libnetwork整个网络部分的功能都是通过 Docker 拆分出来的 libnetwork 实现的，它提供了一个连接不同容器的实现，同时也能够为应用给出一个能够提供一致的编程接口和网络层抽象的容器网络模型。 The goal of libnetwork is to deliver a robust Container Network Model that provides a consistent programming interface and the required network abstractions for applications. libnetwork 中最重要的概念，容器网络模型由以下的几个主要组件组成，分别是 Sandbox、Endpoint 和 Network： 在容器网络模型中，每一个容器内部都包含一个 Sandbox，其中存储着当前容器的网络栈配置，包括容器的接口、路由表和 DNS 设置，Linux 使用网络命名空间实现这个 Sandbox，每一个 Sandbox 中都可能会有一个或多个 Endpoint，在 Linux 上就是一个虚拟的网卡 veth，Sandbox 通过 Endpoint 加入到对应的网络中，这里的网络可能就是我们在上面提到的 Linux 网桥或者 VLAN。 想要获得更多与 libnetwork 或者容器网络模型相关的信息，可以阅读 Design · libnetwork 了解更多信息，当然也可以阅读源代码了解不同 OS 对容器网络模型的不同实现。 挂载点虽然我们已经通过 Linux 的命名空间解决了进程和网络隔离的问题，在 Docker 进程中我们已经没有办法访问宿主机器上的其他进程并且限制了网络的访问，但是 Docker 容器中的进程仍然能够访问或者修改宿主机器上的其他目录，这是我们不希望看到的。 在新的进程中创建隔离的挂载点命名空间需要在 clone 函数中传入 CLONE_NEWNS，这样子进程就能得到父进程挂载点的拷贝，如果不传入这个参数子进程对文件系统的读写都会同步回父进程以及整个主机的文件系统。 如果一个容器需要启动，那么它一定需要提供一个根文件系统（rootfs），容器需要使用这个文件系统来创建一个新的进程，所有二进制的执行都必须在这个根文件系统中。 想要正常启动一个容器就需要在 rootfs 中挂载以上的几个特定的目录，除了上述的几个目录需要挂载之外我们还需要建立一些符号链接保证系统 IO 不会出现问题。 为了保证当前的容器进程没有办法访问宿主机器上其他目录，我们在这里还需要通过 libcontainer 提供的 pivot_root 或者 chroot 函数改变进程能够访问个文件目录的根节点。 1234567891011// pivor_rootput_old = mkdir(...);pivot_root(rootfs, put_old);chdir(&quot;/&quot;);unmount(put_old, MS_DETACH);rmdir(put_old);// chrootmount(rootfs, &quot;/&quot;, NULL, MS_MOVE, NULL);chroot(&quot;.&quot;);chdir(&quot;/&quot;); C 到这里我们就将容器需要的目录挂载到了容器中，同时也禁止当前的容器进程访问宿主机器上的其他目录，保证了不同文件系统的隔离。 这一部分的内容是作者在 libcontainer 中的 SPEC.md 文件中找到的，其中包含了 Docker 使用的文件系统的说明，对于 Docker 是否真的使用 chroot 来确保当前的进程无法访问宿主机器的目录，作者其实也没有确切的答案，一是 Docker 项目的代码太多庞大，不知道该从何入手，作者尝试通过 Google 查找相关的结果，但是既找到了无人回答的 问题，也得到了与 SPEC 中的描述有冲突的 答案 ，如果各位读者有明确的答案可以在博客下面留言，非常感谢。 ### chroot 在这里不得不简单介绍一下 chroot（change root），在 Linux 系统中，系统默认的目录就都是以 / 也就是根目录开头的，chroot 的使用能够改变当前的系统根目录结构，通过改变当前系统的根目录，我们能够限制用户的权利，在新的根目录下并不能够访问旧系统根目录的结构个文件，也就建立了一个与原系统完全隔离的目录结构。 与 chroot 的相关内容部分来自 理解 chroot 一文，各位读者可以阅读这篇文章获得更详细的信息。 CGroups我们通过 Linux 的命名空间为新创建的进程隔离了文件系统、网络并与宿主机器之间的进程相互隔离，但是命名空间并不能够为我们提供物理资源上的隔离，比如 CPU 或者内存，如果在同一台机器上运行了多个对彼此以及宿主机器一无所知的『容器』，这些容器却共同占用了宿主机器的物理资源。 如果其中的某一个容器正在执行 CPU 密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题，而 Control Groups（简称 CGroups）就是能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。 每一个 CGroup 都是一组被相同的标准和参数限制的进程，不同的 CGroup 之间是有层级关系的，也就是说它们之间可以从父类继承一些用于限制资源使用的标准和参数。 Linux 的 CGroup 能够为一组进程分配资源，也就是我们在上面提到的 CPU、内存、网络带宽等资源，通过对资源的分配，CGroup 能够提供以下的几种功能： 在 CGroup 中，所有的任务就是一个系统的一个进程，而 CGroup 就是一组按照某种标准划分的进程，在 CGroup 这种机制中，所有的资源控制都是以 CGroup 作为单位实现的，每一个进程都可以随时加入一个 CGroup 也可以随时退出一个 CGroup。 – CGroup 介绍、应用实例及原理描述 Linux 使用文件系统来实现 CGroup，我们可以直接使用下面的命令查看当前的 CGroup 中有哪些子系统： 12345678910$ lssubsys -mcpuset /sys/fs/cgroup/cpusetcpu /sys/fs/cgroup/cpucpuacct /sys/fs/cgroup/cpuacctmemory /sys/fs/cgroup/memorydevices /sys/fs/cgroup/devicesfreezer /sys/fs/cgroup/freezerblkio /sys/fs/cgroup/blkioperf_event /sys/fs/cgroup/perf_eventhugetlb /sys/fs/cgroup/hugetlb Sh 大多数 Linux 的发行版都有着非常相似的子系统，而之所以将上面的 cpuset、cpu 等东西称作子系统，是因为它们能够为对应的控制组分配资源并限制资源的使用。 如果我们想要创建一个新的 cgroup 只需要在想要分配或者限制资源的子系统下面创建一个新的文件夹，然后这个文件夹下就会自动出现很多的内容，如果你在 Linux 上安装了 Docker，你就会发现所有子系统的目录下都有一个名为 docker 的文件夹： 1234567891011121314151617$ ls cpucgroup.clone_children ...cpu.stat docker notify_on_release release_agent tasks$ ls cpu/docker/9c3057f1291b53fd54a3d12023d2644efe6a7db6ddf330436ae73ac92d401cf1 cgroup.clone_children ...cpu.stat notify_on_release release_agent tasks Shell 9c3057xxx 其实就是我们运行的一个 Docker 容器，启动这个容器时，Docker 会为这个容器创建一个与容器标识符相同的 CGroup，在当前的主机上 CGroup 就会有以下的层级关系： 每一个 CGroup 下面都有一个 tasks 文件，其中存储着属于当前控制组的所有进程的 pid，作为负责 cpu 的子系统，cpu.cfs_quota_us 文件中的内容能够对 CPU 的使用作出限制，如果当前文件的内容为 50000，那么当前控制组中的全部进程的 CPU 占用率不能超过 50%。 如果系统管理员想要控制 Docker 某个容器的资源使用率就可以在 docker 这个父控制组下面找到对应的子控制组并且改变它们对应文件的内容，当然我们也可以直接在程序运行时就使用参数，让 Docker 进程去改变相应文件中的内容。 1234567$ docker run -it -d --cpu-quota=50000 busybox53861305258ecdd7f5d2a3240af694aec9adb91cd4c7e210b757f71153cdd274$ cd 53861305258ecdd7f5d2a3240af694aec9adb91cd4c7e210b757f71153cdd274/$ lscgroup.clone_children cgroup.event_control cgroup.procs cpu.cfs_period_us cpu.cfs_quota_us cpu.shares cpu.stat notify_on_release tasks$ cat cpu.cfs_quota_us50000 Shell 当我们使用 Docker 关闭掉正在运行的容器时，Docker 的子控制组对应的文件夹也会被 Docker 进程移除，Docker 在使用 CGroup 时其实也只是做了一些创建文件夹改变文件内容的文件操作，不过 CGroup 的使用也确实解决了我们限制子容器资源占用的问题，系统管理员能够为多个容器合理的分配资源并且不会出现多个容器互相抢占资源的问题。 UnionFSLinux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。 镜像到底是什么，它又是如何组成和组织的是作者使用 Docker 以来的一段时间内一直比较让作者感到困惑的问题，我们可以使用 docker run 非常轻松地从远程下载 Docker 的镜像并在本地运行。 Docker 镜像其实本质就是一个压缩包，我们可以使用下面的命令将一个 Docker 镜像中的文件导出： 123$ docker export $(docker create busybox) | tar -C rootfs -xvf -$ lsbin dev etc home proc root sys tmp usr var Shell 你可以看到这个 busybox 镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说 Docker 镜像就是一个文件。 存储驱动Docker 使用了一系列不同的存储驱动管理镜像内的文件系统并运行容器，这些存储驱动与 Docker 卷（volume）有些不同，存储引擎管理着能够在多个容器之间共享的存储。 想要理解 Docker 使用的存储驱动，我们首先需要理解 Docker 是如何构建并且存储镜像的，也需要明白 Docker 的镜像是如何被每一个容器所使用的；Docker 中的每一个镜像都是由一系列只读的层组成的，Dockerfile 中的每一个命令都会在已有的只读层上创建一个新的层： 1234FROM ubuntu:15.04COPY . /appRUN make /appCMD python /app/app.py Docker 容器中的每一层都只对当前容器进行了非常小的修改，上述的 Dockerfile 文件会构建一个拥有四层 layer 的镜像： 当镜像被 docker run 命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改。 容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写的层，也就是同一个镜像可以对应多个容器。 AUFSUnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。而 AUFS 即 Advanced UnionFS 其实就是 UnionFS 的升级版，它能够提供更优秀的性能和效率。 AUFS 作为联合文件系统，它能够将不同文件夹中的层联合（Union）到了同一个文件夹中，这些文件夹在 AUFS 中称作分支，整个『联合』的过程被称为联合挂载（Union Mount）： 每一个镜像层或者容器层都是 /var/lib/docker/ 目录下的一个子文件夹；在 Docker 中，所有镜像层和容器层的内容都存储在 /var/lib/docker/aufs/diff/ 目录中： 1234$ ls /var/lib/docker/aufs/diff/00adcccc1a55a36a610a6ebb3e07cc35577f2f5a3b671be3dbc0e74db9ca691c 93604f232a831b22aeb372d5b11af8c8779feb96590a6dc36a80140e38e764d800adcccc1a55a36a610a6ebb3e07cc35577f2f5a3b671be3dbc0e74db9ca691c-init 93604f232a831b22aeb372d5b11af8c8779feb96590a6dc36a80140e38e764d8-init019a8283e2ff6fca8d0a07884c78b41662979f848190f0658813bb6a9a464a90 93b06191602b7934fafc984fbacae02911b579769d0debd89cf2a032e7f35cfa... Shell 而 /var/lib/docker/aufs/layers/ 中存储着镜像层的元数据，每一个文件都保存着镜像层的元数据，最后的 /var/lib/docker/aufs/mnt/ 包含镜像或者容器层的挂载点，最终会被 Docker 通过联合的方式进行组装。 上面的这张图片非常好的展示了组装的过程，每一个镜像层都是建立在另一个镜像层之上的，同时所有的镜像层都是只读的，只有每个容器最顶层的容器层才可以被用户直接读写，所有的容器都建立在一些底层服务（Kernel）上，包括命名空间、控制组、rootfs 等等，这种容器的组装方式提供了非常大的灵活性，只读的镜像层通过共享也能够减少磁盘的占用。 其他存储驱动AUFS 只是 Docker 使用的存储驱动的一种，除了 AUFS 之外，Docker 还支持了不同的存储驱动，包括 aufs、devicemapper、overlay2、zfs 和 vfs 等等，在最新的 Docker 中，overlay2 取代了 aufs 成为了推荐的存储驱动，但是在没有 overlay2 驱动的机器上仍然会使用 aufs 作为 Docker 的默认驱动。 不同的存储驱动在存储镜像和容器文件时也有着完全不同的实现，有兴趣的读者可以在 Docker 的官方文档 Select a storage driver 中找到相应的内容。 想要查看当前系统的 Docker 上使用了哪种存储驱动只需要使用以下的命令就能得到相对应的信息： 12$ docker info | grep StorageStorage Driver: aufs Shell 作者的这台 Ubuntu 上由于没有 overlay2 存储驱动，所以使用 aufs 作为 Docker 的默认存储驱动。 总结Docker 目前已经成为了非常主流的技术，已经在很多成熟公司的生产环境中使用，但是 Docker 的核心技术其实已经有很多年的历史了，Linux 命名空间、控制组和 UnionFS 三大技术支撑了目前 Docker 的实现，也是 Docker 能够出现的最重要原因。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://github.13sai.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://github.13sai.com/tags/Docker/"}]},{"title":"使用缓存的正确姿势","slug":"使用缓存的正确姿势","date":"2021-04-22T04:38:28.000Z","updated":"2021-04-22T05:18:40.174Z","comments":true,"path":"2021/04/22/331/","link":"","permalink":"http://github.13sai.com/2021/04/22/331/","excerpt":"","text":"Form: 使用缓存的正确姿势 缓存是现在系统中必不可少的模块，并且已经成为了高并发高性能架构的一个关键组件。这篇博客我们来分析一下使用缓存的正确姿势。 缓存能解决的问题 提升性能 绝大多数情况下，select 是出现性能问题最大的地方。一方面，select 会有很多像 join、group、order、like 等这样丰富的语义，而这些语义是非常耗性能的；另一方面，大多数应用都是读多写少，所以加剧了慢查询的问题。 分布式系统中远程调用也会耗很多性能，因为有网络开销，会导致整体的响应时间下降。为了挽救这样的性能开销，在业务允许的情况（不需要太实时的数据）下，使用缓存是非常必要的事情。 缓解数据库压力 当用户请求增多时，数据库的压力将大大增加，通过缓存能够大大降低数据库的压力。 缓存的适用场景 对于数据实时性要求不高 对于一些经常访问但是很少改变的数据，读明显多于写，适用缓存就很有必要。比如一些网站配置项。 对于性能要求高 比如一些秒杀活动场景。 缓存三种模式一般来说，缓存有以下三种模式： Cache Aside 更新模式 Read/Write Through 更新模式 Write Behind Caching 更新模式 通俗一点来讲就是，同时更新缓存和数据库（Cache Aside 更新模式）；先更新缓存，缓存负责同步更新数据库（Read/Write Through 更新模式）；先更新缓存，缓存定时异步更新数据库（Write Behind Caching 更新模式）。这三种模式各有优劣，可以根据业务场景选择使用。 Cache Aside 更新模式这是最常用的缓存模式了，具体的流程是： 失效：应用程序先从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。 命中：应用程序从 cache 中取数据，取到后返回。 更新：先把数据存到数据库中，成功后，再让缓存失效。 ​ 注意我们上面所提到的，缓存更新时先更新数据库，然后在让缓存失效。那么为什么不是直接更新缓存呢？这里有一些缓存更新的坑，我们需要避免入坑。 避坑指南一**先更新数据库，再更新缓存。**这种做法最大的问题就是**两个并发的写操作导致脏数据**。如下图（以Redis和Mysql为例），两个并发更新操作，数据库先更新的反而后更新缓存，数据库后更新的反而先更新缓存。这样就会造成数据库和缓存中的数据不一致，应用程序中读取的都是脏数据。 避坑指南二**先删除缓存，再更新数据库。**这个逻辑是错误的，因为两个并发的读和写操作导致脏数据****。如下图（以Redis和Mysql为例）。假设更新操作先删除了缓存，此时正好有一个并发的读操作，没有命中缓存后从数据库中取出老数据并且更新回缓存，这个时候更新操作也完成了数据库更新。此时，数据库和缓存中的数据不一致，应用程序中读取的都是原来的数据（脏数据）。 避坑指南三先更新数据库，再删除缓存。这种做法其实不能算是坑，在实际的系统中也推荐使用这种方式。但是这种方式理论上还是可能存在问题。如下图（以Redis和Mysql为例），查询操作没有命中缓存，然后查询出数据库的老数据。此时有一个并发的更新操作，更新操作在读操作之后更新了数据库中的数据并且删除了缓存中的数据。然而读操作将从数据库中读取出的老数据更新回了缓存。这样就会造成数据库和缓存中的数据不一致，应用程序中读取的都是原来的数据（脏数据）。 但是，仔细想一想，这种并发的概率极低。因为这个条件需要发生在读缓存时缓存失效，而且有一个并发的写操作。实际上数据库的写操作会比读操作慢得多，而且还要加锁，而读操作必需在写操作前进入数据库操作，又要晚于写操作更新缓存，所有这些条件都具备的概率并不大。但是为了避免这种极端情况造成脏数据所产生的影响，我们还是要为缓存设置过期时间。 Read/Write Through 更新模式在上面的 Cache Aside 更新模式中，应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。而在Read/Write Through 更新模式中，应用程序只需要维护缓存，数据库的维护工作由缓存代理了。 Read ThroughRead Through 模式就是在查询操作中更新缓存，也就是说，当缓存失效的时候，Cache Aside 模式是由调用方负责把数据加载入缓存，而 Read Through 则用缓存服务自己来加载。 Write ThroughWrite Through 模式和 Read Through 相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由缓存自己更新数据库（这是一个同步操作）。 Write Behind Caching 更新模式Write Behind Caching 更新模式就是在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是直接操作内存速度快。因为异步，Write Behind Caching 更新模式还可以合并对同一个数据的多次操作到数据库，所以性能的提高是相当可观的。 但其带来的问题是，数据不是强一致性的，而且可能会丢失。另外，Write Behind Caching 更新模式实现逻辑比较复杂，因为它需要确认有哪些数据是被更新了的，哪些数据需要刷到持久层上。只有在缓存需要失效的时候，才会把它真正持久起来。 总结三种缓存模式的优缺点： Cache Aside 更新模式实现起来比较简单，但是需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。 Read/Write Through 更新模式只需要维护一个数据存储（缓存），但是实现起来要复杂一些。 Write Behind Caching 更新模式和Read/Write Through 更新模式类似，区别是Write Behind Caching 更新模式的数据持久化操作是异步的，但是Read/Write Through 更新模式的数据持久化操作是同步的。优点是直接操作内存速度快，多次操作可以合并持久化到数据库。缺点是数据可能会丢失，例如系统断电等。 缓存是通过牺牲强一致性来提高性能的。所以使用缓存提升性能，就是会有数据更新的延迟。这需要我们在设计时结合业务仔细思考是否适合用缓存。然后缓存一定要设置过期时间，这个时间太短太长都不好，太短的话请求可能会比较多的落到数据库上，这也意味着失去了缓存的优势。太长的话缓存中的脏数据会使系统长时间处于一个延迟的状态，而且系统中长时间没有人访问的数据一直存在内存中不过期，浪费内存。 ​","categories":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"}]},{"title":"进程间通信","slug":"进程间通信","date":"2021-04-05T03:19:31.000Z","updated":"2021-04-07T14:31:00.796Z","comments":true,"path":"2021/04/05/328/","link":"","permalink":"http://github.13sai.com/2021/04/05/328/","excerpt":"","text":"文章来源: 张三同学没答好「进程间通信」，被面试官挂了…. Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。 匿名管道顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。 命名管道突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。 消息队列克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。 共享内存可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享内存通信，带来新的问题，多进程竞争同个共享资源会造成数据的错乱。 信号量那么，就需要信号量来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。 信号与信号量名字很相似的叫信号，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中唯一的异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，这是为了方便我们能在任何时候结束或停止某个进程。 前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要 Socket 通信了。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。 以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？ 同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步： 互斥的方式，可保证任意时刻只有一个线程访问共享资源；同步的方式，可保证线程 A 应在线程 B 之前执行。","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"}]},{"title":"Paxos和Raft协议介绍","slug":"Paxos和Raft协议介绍","date":"2021-04-03T07:07:37.000Z","updated":"2021-04-07T14:08:56.979Z","comments":true,"path":"2021/04/03/326/","link":"","permalink":"http://github.13sai.com/2021/04/03/326/","excerpt":"","text":"文章来源: 陶老师运维笔记- 微信公众号 1. 背景介绍1.1 分布式事务分布式事务指事务的操作位于不同的分布式系统节点上，需要保证事务的 AICD 特性。 分布式事务处理的难点是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚） 解决这种分布式一致性问题：其中比较著名的有二阶提交协议（Two Phase Commitment Protocol）、三阶提交协议（Tree Phase Commitment Protocol）和Paxos算法。 1.2 二阶段提交在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。 因此，二阶段提交的算法思路可以概括为： 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。 2PC顾名思义分为两个阶段，其实施思路可概括为： 投票阶段（voting phase）：参与者将操作结果通知协调者； 提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚； 2. Paxos协议PAXOS可以用来解决分布式环境下，设置某一个值的问题。 分布式系统中有多个节点就会存在节点间通信的问题，Paxos是基于消息传递的通讯模型的。它的假设前提是，在分布式系统中进程之间的通信会出现丢失、延迟、重复等现象，但不会出现传错的现象。Paxos算法就是为了保证在这样的系统中进程间基于消息传递就某个值达成一致。 2.1 角色Paxos是第一个被证明的共识算法，原理基于两阶段提交并进行扩展。算法中将节点分为三种类型： 倡议者proposer：提交一个提案，等待大家批准为结案，往往是客户端担任。提案信息包括提案编号和提议的value。 接受者acceptor：负责对提案进行投票，往往服务器担任。若提案获得多数Acceptors的接受，则称该提案被批准（chosen）。 学习者learner：被告知提案结果，只能“学习”被批准的提案。不参与投票过程。客户端和服务端都可担任。 每个节点在协议中可以担任多个角色。 2.2 Paxos算法 segmentfault.com/a/119000000… www.cnblogs.com/hzmark/p/pa… Paxos的特点： 一个或多个节点可以提出提议 系统针对所有提案中的某个提案必须达成一致 最多只能对一个确定的提案达成一致 只要超过半数的节点存活且可互相通信，整个系统一定能达成一致状态 2.2.1 Paxos表决 首先proposers将value发送给Acceptors。 Acceptors对value进行接受（accept）。acceptor可以回应接受或拒绝。 一旦节点中的大多数回应接受，共识就能达成，接受的value成为正式的决议（称为“批准”决议）。 整个过程（一个事务或一个Round）分为两个阶段： phase1（准备阶段） a) Proposer向超过半数（n/2+1）Acceptor发起prepare消息(发送编号) b)如果prepare符合协议规则Acceptor回复promise消息，否则拒绝 phase2（决议阶段或投票阶段） a) 如果超过半数Acceptor回复promise，Proposer向Acceptor发送accept消息(此时包含真实的值) b)Acceptor检查accept消息是否符合规则，消息符合则批准accept请求 根据上述过程当一个proposer发现存在编号更大的提案时将终止提案。这意味着提出一个编号更大的提案会终止之前的提案过程。有可能陷入活锁，违背了Progress的要求。这种情况下的解决方案是选举出一个leader，仅允许leader提出提案。注意一个learner可能兼任proposer。 2.2.2 决议的发布一个显而易见的方法是当acceptors批准一个value时，将这个消息发送给所有learner。但是这个方法会导致消息量过大。可将accept消息发送给learners的一个子集，然后由这些learners去通知所有learners。 但是由于消息传递的不确定性，可能会没有任何learner获得了决议批准的消息。当learners需要了解决议通过情况时，可以让一个proposer重新进行一次提案。 2.3 Paxos与2PC在Paxos算法中，如果我们指定集群中同一时间只能有一个leader，并且要求所有节点都要投票呢？是的，我们就得到了2PC。2PC是Paxos的一个特例 两个阶段分别是准备（prepare）和提交（commit）。准备阶段解决大家对哪个提案进行投票的问题，提交阶段解决确认最终值的问题。 3. Raft协议 raft.github.io/raft.pdf thesecretlivesofdata.com/raft/ www.cnblogs.com/MaggieLXC/p… 3.1 Raft角色Raft算法是Paxos算法的一种简化实现。包括三种角色：leader，candidate和follower。 follower: 所有节点都以follower的状态开始，如果没有收到leader消息则会变成candidate状态。 candidate: 会向其他节点拉选票，如果得到大部分的票则成为leader，这个过程是Leader选举。 leader: 所有对系统的修改都会先经过leader。 3.2 Raft算法Raft有两个基本过程： Leader选举： 每个candidate随机经过一定时间都会提出选举方案，最近阶段中的票最多者被选为leader。 同步log： leader会找到系统中log（各种事件的发生记录）最新的记录，并强制所有的follow来刷新到这个记录。 Raft算法过程: 有三种状态：leader，candidate和follower。 最开始都是follower状态. followers没有听到leader就变成candidate candidate then requests votes from other nodes nodes will reply with their vote Candidate becomes the leader if it gets votes from a majority of nodes This process is called Leader Election. All changes to the system now go through the leader. Each change is added as an entry in the node’s log. This log entry is currently uncommitted so it won’t update the node’s value. To commit the entry the node first replicates it to the follower nodes… then the leader waits until a majority of nodes have written the entry. The entry is now committed on the leader node and the node state is “5”. The leader then notifies the followers that the entry is committed. The cluster has now come to consensus about the system state. This process is called Log Replication. 3.2.1 Leader Election 3.2.2 Log Replication","categories":[{"name":"算法","slug":"算法","permalink":"http://github.13sai.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://github.13sai.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"进程、线程和协程","slug":"进程、线程和协程","date":"2021-04-02T13:53:55.000Z","updated":"2021-04-07T14:04:32.926Z","comments":true,"path":"2021/04/02/325/","link":"","permalink":"http://github.13sai.com/2021/04/02/325/","excerpt":"","text":"1、进程 直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。 2、线程 有时被称为轻量级进程，是操作系统调度（CPU调度）执行的最小单位。线程是进程的一个实体,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。 3、协程 用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 参考： 进程、线程和协程之间的区别和联系 进程和线程、协程的区别","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"}]},{"title":"goroutine","slug":"goroutine","date":"2021-03-19T12:12:19.000Z","updated":"2021-03-27T08:15:09.839Z","comments":true,"path":"2021/03/19/323/","link":"","permalink":"http://github.13sai.com/2021/03/19/323/","excerpt":"","text":"From: 弄懂goroutine调度原理 线程实现模型 goroutine简介 golang语言作者Rob Pike说，“Goroutine是一个与其他goroutines 并发运行在同一地址空间的Go函数或方法。一个运行的程序由一个或更多个goroutine组成。它与线程、协程、进程等不同。它是一个goroutine“。 goroutine通过通道来通信，而协程通过让出和恢复操作来通信； goroutine 通过Golang 的调度器进行调度，而协程通过程序本身调度； 简单的说就是Golang自己实现了协程并叫做goruntine（本文称Go协程），且比协程更强大。 goroutine调度原理上面说到Go协程是通过Golang的调度器进行调度的，其中调度器的线程模型为两级线程模型。 有关两级线程模型的介绍，可以看文章最后。 我们来看下Golang实现的两级线程模型是怎样的。首先要知道这三个字母代表的含义 M：代表内核级的线程 P：全程Processor，代表运行Go协程所需要的资源（上下文环境） G：代表Go协程我们先看下为实现调度Golang定义了这些数据结构存M，P，G 名称 作用范围 描述 全局M列表 Go的运行时 存放所有M的单向链表 全局P列表 Go的运行时 存放所有P的数组 全局G列表 Go的运行时 存放所有G的切片 调度器的空闲M列表 调度器 存放空闲M的单向链表 调度器的空闲P列表 调度器 存放空闲P的单向链表 调度器的自由G列表 调度器 存放自由G的单向链表（有两个） 调度器的可运行G队列 调度器 存放可运行G的队列 P的自由G列表 本地P 存放当前P中自由G的单向链表 P的可运行G队列 本地P 存放当前P中可运行G的队列 然后从上往下解析Go的两级线程模型图 M和内核线程之间是一对一的关系，一个M在其生命周期中，只会和一个内核线程关联，所以不会出现对内核线程的频繁切换； Golang的运行时执行系统监控和垃圾回收等任务时候会导致创建M，M空闲时不会被销毁，而是放到一个调度器的空闲M列表中，等待与P关联，M默认数量为10000 P和M之间是多对多的关系，P和G之间是一对多的关系，他们的关联是易变的，由Golang的调度器完成调度； Golang的运行时按规则调度，让P和不同的M建立或断开关联，使得P中的G能够及时获得运行时机 P的数量默认为CPU总核心数，最大为256，当P没有可运行的G时候（P的可运行G队列为空），P会被放到调度器的空闲P列表中，等待M与它关联； P有可能会被销毁，如运行时用runtime.GOMAXPROCS把P的数量从32降到16时，剩余16个会被销毁，它们原来的G会先转到调度器可运行的G队列和自由G列表 每个P中有可运行的G队列（如图中最下面的那行G）和自由G列表（图中未画出来），当G的代码执行完后，该G不会被销毁，而是被放到P的自由G列表或调度器的自由G列表。如果程序新建了Go协程，调度器会在自由G列表中取一个G，然后把Go协程的函数赋值到G中（如果自由G列表为空，就创建一个G）； 可见Golang调度器在调度时很大程度复用了M，P，G 在Go程序初始化后，调度器首先进行一轮调度，此时用M去搜索可运行的G。其中我们的main函数也是一个G，找到可运行的G后就执行它； 至于怎么找可运行的G呢？答案是到处找，想尽办法找（这里只列出一部分地方）。 从本地P的可运行的G队列找 从调度器的可运行的G队列找 从其他P的可运行的G队列找 P的可运行G队列最大只能存放长度为256的G，当队列满后，调度器会把一半的G转到调度器的可运行G队列。 系统监控上面大概描述了关于goroutine调度的流程。现在还存在一个问题，那就是当Go协程很多（并发量大）时候，显然G是不能一直执行下去的，因为也需要把执行机会留给其他的G。此时Golang运行时的系统监控就起作用了。一般情况，当G运行时间超过10ms后，该G就会被系统告知需要停止了，让其他G运行。（这里情况比较复杂，并不能确保每个G都能被公平执行） 以下特殊情况该G不需要停止 P的可运行G队列为空（没有其他G可运行） 有空闲的M在寻找可运行的G（没有其他G可运行） 空闲的P（还有P闲着） 总结Golang以两级线程实现模型，自己实现goruntine和调度器，优势在于并行和非常低的资源使用。 主要体现 内存消耗方面（每个Go协程占的内存远小于线程占的内存） 切换(调度)开销方面 线程切换涉及模式切换(从用户态切换到内核态) 此外，Go协程执行任务完成的顺序并不都是按我们预期的那样（程序不加以控制的情况下），特别在一些耗时较长的任务中。且每个Go协程执行的时间也不是绝对公平的。 线程实现模型线程实现模型主要分为：用户级线程模型，内核级线程模型和两级线程模型。他们的区别在于线程与内核线程之间的对应关系。 以下我们将分析这三种线程实现模型的特点： 用户级线程模型 多对一关系用户级线程模型为多对一关系。即，一个进程中的所有线程对应一个内核线程； 处理速度快、移植性强；线程的创建、调度、同步等操作由应用程序来处理，不需要让CPU从用户态切换到内核态。所以用户级线程模型在速度快，且移植性强； 并非真正的并发运行如果线程IO操作过程中被阻塞，那么用户空间的其他线程都会被阻塞，因为这些线程无法被内核调度。 内核级线程模型（1）一对一关系内核级线程模型为一对一关系，一个用户线程对应一个内核线程；（2）资源消耗较大，速度较慢进程对线程的创建、终止、切换和同步都必须通过内核提供的系统调用来完成，对内核的调度的调度器造成很大的负担；（3）是真正的并发运行用户线程和内核线程是一对一的关系，线程由内核来管理和调度。当某一线程阻塞时候，不会影响到其他线程。 两级线程模型 多对多的关系两级线程模型是集前面两种模型的优点而设计的，是多对多的关系； 资源消耗较小，速度较快，是真正的并发运行两级线程模型中，一个进程对应多个内核线程，进程中的线程由程序管理和调度并通过映射关系映射到内核线程上。这样即便有线程阻塞后，也不会影响到其他线程； 实现的复杂度大用户线程与内核线程的映射关系需要程序来实现，实现的复杂度大。幸运的是，Golang为我们实现了两级线程模型，这使得它在处理并发问题上更有优势。","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"缓存知识","slug":"缓存知识","date":"2021-03-17T13:05:34.000Z","updated":"2021-04-26T03:41:49.378Z","comments":true,"path":"2021/03/17/322/","link":"","permalink":"http://github.13sai.com/2021/03/17/322/","excerpt":"","text":"缓存雪崩缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间 (例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。 解决办法：大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。 缓存穿透缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。 解决办法：最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。 另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。 5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？ 对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。 Bitmap：典型的就是哈希表 缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。 布隆过滤器（推荐） 就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。 Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。 Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。 缓存击穿指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据。 解决办法：在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。 给一个我公司处理的案例：背景双机拿token，token在存一份到redis，保证系统在token过期时都只有一个线程去获取token;线上环境有两台机器，故使用分布式锁实现。 缓存预热缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据 ！ 解决思路： 直接写个缓存刷新页面，上线时手工操作下； 数据量不大，可以在项目启动的时候自动进行加载； 定时刷新缓存； 缓存更新除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种： 定时去清理过期的缓存； 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。 缓存降级当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。 以参考日志级别设置预案： 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。 服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。 热点数据和冷数据是什么热点数据，缓存才有价值 对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存 对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。 对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。 数据更新前至少读取两次， 缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。 那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。 参考： 码猿技术专栏","categories":[{"name":"cache","slug":"cache","permalink":"http://github.13sai.com/categories/cache/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"}]},{"title":"Redis删除策略和内存淘汰机制","slug":"Redis删除策略和内存淘汰机制","date":"2021-03-14T04:02:04.000Z","updated":"2021-03-27T08:07:12.512Z","comments":true,"path":"2021/03/14/321/","link":"","permalink":"http://github.13sai.com/2021/03/14/321/","excerpt":"","text":"删除策略redis采用的是定期删除+惰性删除策略。 为什么不用定时删除策略? 定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略. 定期删除+惰性删除是如何工作的呢? 定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 采用定期删除+惰性删除就没其他问题了么? 不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。 内存淘汰机制在redis.conf中有一行配置 1maxmemory-policy volatile-lru 该配置就是配内存淘汰策略的 noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键 allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键 volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键 allkeys-random：加入键的时候如果过限，从所有key随机删除 volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐 volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键 volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键 allkeys-lfu：从所有键中驱逐使用频率最少的键 一般的经验规则: 使用allkeys-lru策略：当预期请求符合一个幂次分布(二八法则等)，比如一部分的子集元素比其它其它元素被访问的更多时，可以选择这个策略。 使用allkeys-random：循环连续的访问所有的键时，或者预期请求分布平均（所有元素被访问的概率都差不多） 使用volatile-ttl：要采取这个策略，缓存对象的TTL值最好有差异 volatile-lru 和 volatile-random策略，当你想要使用单一的Redis实例来同时实现缓存淘汰和持久化一些经常使用的键集合时很有用。未设置过期时间的键进行持久化保存，设置了过期时间的键参与缓存淘汰。不过一般运行两个实例是解决这个问题的更好方法。 为键设置过期时间也是需要消耗内存的，所以使用allkeys-lru这种策略更加节省空间，因为这种策略下可以不为键设置过期时间。 LRURedis配置中和LRU有关的有三个： maxmemory: 配置Redis存储数据时指定限制的内存大小，比如100m。当缓存消耗的内存超过这个数值时, 将触发数据淘汰。该数据配置为0时，表示缓存的数据量没有限制, 即LRU功能不生效。64位的系统默认值为0，32位的系统默认内存限制为3GB maxmemory_policy: 触发数据淘汰后的淘汰策略 maxmemory_samples: 随机采样的精度，也就是随即取出key的数目。该数值配置越大, 越接近于真实的LRU算法，但是数值越大，相应消耗也变高，对性能有一定影响，样本值默认为5。 我们知道，LRU算法需要一个双向链表来记录数据的最近被访问顺序，但是出于节省内存的考虑，Redis的LRU算法并非完整的实现。Redis并不会选择最久未被访问的键进行回收，相反它会尝试运行一个近似LRU的算法，通过对少量键进行取样，然后回收其中的最久未被访问的键。通过调整每次回收时的采样数量maxmemory-samples，可以实现调整算法的精度。 根据Redis作者的说法，每个Redis Object可以挤出24 bits的空间，但24 bits是不够存储两个指针的，而存储一个低位时间戳是足够的，Redis Object以秒为单位存储了对象新建或者更新时的unix time，也就是LRU clock，24 bits数据要溢出的话需要194天，而缓存的数据更新非常频繁，已经足够了。 Redis的键空间是放在一个哈希表中的，要从所有的键中选出一个最久未被访问的键，需要另外一个数据结构存储这些源信息，这显然不划算。最初，Redis只是随机的选3个key，然后从中淘汰，后来算法改进到了N个key的策略，默认是5个。 Redis3.0之后又改善了算法的性能，会提供一个待淘汰候选key的pool，里面默认有16个key，按照空闲时间排好序。更新时从Redis键空间随机选择N个key，分别计算它们的空闲时间idle，key只会在pool不满或者空闲时间大于pool里最小的时，才会进入pool，然后从pool中选择空闲时间最大的key淘汰掉。 真实LRU算法与近似LRU的算法可以通过下面的图像对比： 浅灰色带是已经被淘汰的对象，灰色带是没有被淘汰的对象，绿色带是新添加的对象。可以看出，maxmemory-samples值为5时Redis 3.0效果比Redis 2.8要好。使用10个采样大小的Redis 3.0的近似LRU算法已经非常接近理论的性能了。 数据访问模式非常接近幂次分布时，也就是大部分的访问集中于部分键时，LRU近似算法会处理得很好。 Redis为什么不使用原生LRU算法？ 原生LRU算法需要 双向链表 来管理数据，需要额外内存 数据访问时涉及数据移动，有性能损耗 Redis现有数据结构需要改造 LFU在LFU算法中，可以为每个key维护一个计数器。每次key被访问的时候，计数器增大。计数器越大，可以约等于访问越频繁。 上述简单算法存在两个问题： 在LRU算法中可以维护一个双向链表，然后简单的把被访问的节点移至链表开头，但在LFU中是不可行的，节点要严格按照计数器进行排序，新增节点或者更新节点位置时，时间复杂度可能达到O(N)。 只是简单的增加计数器的方法并不完美。访问模式是会频繁变化的，一段时间内频繁访问的key一段时间之后可能会很少被访问到，只增加计数器并不能体现这种趋势。 第一个问题很好解决，可以借鉴LRU实现的经验，维护一个待淘汰key的pool。第二个问题的解决办法是，记录key最后一个被访问的时间，然后随着时间推移，降低计数器。 Redis对象的结构如下： 123456789typedef struct redisObject &#123; unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr;&#125; robj; 在LRU算法中，24 bits的lru是用来记录LRU time的，在LFU中也可以使用这个字段，不过是分成16 bits与8 bits使用： 1234 16 bits 8 bits+----------------+--------++ Last decr time | LOG_C |+----------------+--------+ 高16 bits用来记录最近一次计数器降低的时间ldt，单位是分钟，低8 bits记录计数器数值counter。 LFU配置Redis4.0之后为maxmemory_policy淘汰策略添加了两个LFU模式： volatile-lfu：对有过期时间的key采用LFU淘汰算法 allkeys-lfu：对全部key采用LFU淘汰算法 还有2个配置可以调整LFU算法： 12lfu-log-factor 10lfu-decay-time 1 lfu-log-factor可以调整计数器counter的增长速度，lfu-log-factor越大，counter增长的越慢。 lfu-decay-time是一个以分钟为单位的数值，可以调整counter的减少速度 参考： Redis中的LRU淘汰策略分析 Redis中的LFU算法 玩转Redis-8种数据淘汰策略及近似LRU、LFU原理","categories":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"}]},{"title":"k8s的安装（Mac）","slug":"k8s的安装（Mac）","date":"2021-03-13T07:37:06.000Z","updated":"2021-03-27T07:55:43.183Z","comments":true,"path":"2021/03/13/320/","link":"","permalink":"http://github.13sai.com/2021/03/13/320/","excerpt":"","text":"印象中之前mac装k8s挺麻烦，之前装的版本较低v1.14.7。最近总提示我更新，刚好更新一下，顺便记录下过程。 下载 下载安装[docker-desktop]https://www.docker.com/products/docker-desktop 修改Docker Engine配置，修改镜像源1234567891011&#123; &quot;registry-mirrors&quot;: [ &quot;https://docker.mirrors.ustc.edu.cn&quot;, &quot;https://hub-mirror.c.163.com&quot;, &quot;http://f1361db2.m.daocloud.io&quot; ], &quot;experimental&quot;: false, &quot;features&quot;: &#123; &quot;buildkit&quot;: true &#125;&#125; 安装k8s.gcr.io等组件123git clone https://github.com/AliyunContainerService/k8s-for-docker-desktop.git//切换到你的k8s版本，我的是v1.19.7git checkout v1.19.7 执行 1./load_images.sh 安装k8s依赖。4. Enable Kubernetes，重启，Kubernetes启动比Docker慢多了，稍微等一会就好。 安装kubernetes/dashboard项目地址：https://github.com/kubernetes/dashboard 1kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml 如果执行超时，可以把yaml文件下载到本地运行。 123456kubectl get pod --namespace=kubernetes-dashboardoutput:NAME READY STATUS RESTARTS AGEdashboard-metrics-scraper-79c5968bdc-xvrzd 1/1 Running 0 4m13skubernetes-dashboard-9f9799597-9kmbk 1/1 Running 0 4m13s 可以看到成功安装ubernetes-dashboard。 启动1kubectl proxy 登录打开浏览器：http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login 选择Token登录，用下方命令获取token，登录成功，可以看到界面。 获取token1kubectl -n kube-system describe $(kubectl -n kube-system get secret -n kube-system -o name | grep namespace) | grep token","categories":[{"name":"devops","slug":"devops","permalink":"http://github.13sai.com/categories/devops/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"http://github.13sai.com/tags/k8s/"}]},{"title":"go的GC机制","slug":"go的GC机制","date":"2021-02-27T13:03:12.000Z","updated":"2021-03-02T07:07:38.685Z","comments":true,"path":"2021/02/27/319/","link":"","permalink":"http://github.13sai.com/2021/02/27/319/","excerpt":"","text":"Golang的标记清除如下图所示，通过gcmarkBits位图标记span的块是否被引用。对应内存分配中的bitmap区。 gc 三色标记 白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理） 灰色：对象已被标记，但这个对象包含的子对象未标记 黑色：对象已被标记，且这个对象包含的子对象也已标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理） 例如，当前内存中有A~F一共6个对象，根对象a,b本身为栈上分配的局部变量，根对象a、b分别引用了对象A、B, 而B对象又引用了对象D，则GC开始前各对象的状态如下图所示: 初始状态下所有对象都是白色的。 接着开始扫描根对象a、b; 由于根对象引用了对象A、B,那么A、B变为灰色对象，接下来就开始分析灰色对象，分析A时，A没有引用其他对象很快就转入黑色，B引用了D，则B转入黑色的同时还需要将D转为灰色，进行接下来的分析。 灰色对象只有D，由于D没有引用其他对象，所以D转入黑色。标记过程结束 最终，黑色的对象会被保留下来，白色对象会被回收掉。 gc GC的触发 阈值：默认内存扩大一倍，启动gc 定期：默认2min触发一次gc，src/runtime/proc.go:forcegcperiod 手动：runtime.gc() STWstop the world是gc的最大性能问题，对于gc而言，需要停止所有的内存变化，即停止所有的goroutine，等待gc结束之后才恢复。 标记-清除(mark and sweep)算法的STW(stop the world)操作，就是runtime把所有的线程全部冻结掉，所有的线程全部冻结意味着用户逻辑是暂停的。这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。 Go如何减短这个过程呢？标记-清除(mark and sweep)算法包含两部分逻辑：标记和清除。 我们知道Golang三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑。所以： 清除操作和用户逻辑可以并发。 标记操作和用户逻辑也是并发的，用户逻辑会时常生成对象或者改变对象的引用，那么标记和用户逻辑如何并发呢？这里就让说到golang的写屏障了。 GC流程 Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收 Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW) Sweep: 按标记结果清扫span 目前整个GC流程会进行两次STW(Stop The World), 第一次是Mark阶段的开始, 第二次是Mark Termination阶段. 第一次STW会准备根对象的扫描, 启动写屏障(Write Barrier)和辅助GC(mutator assist). 第二次STW会重新扫描部分根对象, 禁用写屏障(Write Barrier)和辅助GC(mutator assist). 需要注意的是, 不是所有根对象的扫描都需要STW, 例如扫描栈上的对象只需要停止拥有该栈的G.从go 1.9开始, 写屏障的实现使用了Hybrid Write Barrier, 大幅减少了第二次STW的时间. 写屏障因为go支持并行GC， GC的扫描和go代码可以同时运行，这样带来的问题是GC扫描的过程中go代码有可能改变了对象的依赖树。 例如开始扫描时发现根对象A和B，B拥有C的指针。 GC先扫描A，A放入黑色 B把C的指针交给A GC再扫描B，B放入黑色 C在白色，会回收；但是A其实引用了C。 为了避免这个问题, go在GC的标记阶段会启用写屏障(Write Barrier). 启用了写屏障(Write Barrier)后， GC先扫描A，A放入黑色 B把C的指针交给A 由于A在黑色，所以C放入灰色 C没有子对象，放入黑色 扫描B，B没有子对象，放入黑色 即使A可能会在稍后丢掉C, 那么C就在下一轮回收。 开启写屏障之后，当指针发生改变, GC会认为在这一轮的扫描中这个指针是存活的, 所以放入灰色。 其他常见gc机制 引用计数 复制收集 分代收集 GC 的触发时机的两种形式 主动触发，通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。 被动触发，分为两种方式： 使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。 参考： Golang GC(垃圾回收机制) [11. 触发 GC 的时机是什么？](https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.11.GC-GC.md#11. 触发 GC 的时机是什么？)","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"微服务浅析","slug":"微服务浅析","date":"2021-02-25T13:13:35.000Z","updated":"2021-03-02T07:17:49.410Z","comments":true,"path":"2021/02/25/318/","link":"","permalink":"http://github.13sai.com/2021/02/25/318/","excerpt":"","text":"服务端架构的演进一般来说，早期的软件大多数是单体架构，接着使用分层技术演化为垂直架构，然后 SOA 面向服务架构和微服务架构相继登场，最终随着云技术的应用和推广而孕育出云原生架构的思想。下面我们就来一一介绍这些架构设计的基础理念和优缺点。 单体架构在 Web 应用程序发展的早期，大部分工程是将所有的服务端功能模块打包成单个巨石型（Monolith）应用，譬如很多企业的 Java 应用程序打包为 war 包，最终会形成如下图所示的架构。 单体架构的应用开发简单，技术单一，测试、部署相对简单明了。但其缺陷也是非常明显的，进行局部改动就需要重新部署，而且编译时间过长。除此之外，单体架构的技术栈也不易扩展，只能不断地在原有基础上进行局部优化，比如说应用的某一场景需要处理高并发，使用 Go 语言较为合适，但是单体架构并不支持多语言技术栈，这时也就只好作罢。 垂直分层架构单体架构在系统用户访问量逐渐增大的情况下，若仅仅依靠扩展物理机配置或者增加机器来优化系统的性能，往往收效甚微。单体架构中不同业务模块的差异就会显现，比如有些模块是 IO 密集型，有些是计算密集型。这些模块所需要的机器数量和性能各有差异，这时为了提升机器利用率和性能，垂直分层架构就诞生了。 垂直分层架构是将大应用拆分成一个个单体结构的应用。换句话说，垂直架构就是彼此存在依赖关系的组件组成的架构，比如分层——用户界面层依赖业务逻辑，而业务逻辑依赖数据库访问（如下图所示）。垂直分层是一个典型的对复杂系统进行结构化思考和抽象聚合的通用性方法。 这样处理后，垂直分层架构就解决了很多问题：将系统拆分实现了流量分担，解决了部分并发问题；拆分之后，服务间相互独立；性能方面，可以针对单个服务模块进行优化；易于水平扩展，多实例提升容错率。 但其缺点也是明显的，垂直分层架构的系统拆分，使得集群搭建变得复杂；涉及的服务间调用，服务之间耦合度变高，调用关系错综复杂，难以维护调用关系。 SOA 面向服务架构当垂直架构拆分的应用越来越多时，就会出现多个应用都依赖的业务逻辑组件，并且各个应用进行交互的需要也越来越频繁。此时，就需要将部分通用的业务组件独立出来，并定义好服务间交互的接口，向外提供能力，让其他服务调用。SOA 面向服务架构这就“应运而生”了。 SOA 面向服务架构是一种软件体系结构，它将应用程序的不同服务通过定义良好的接口和契约联系起来，这些接口独立定义，不依赖实现服务的编程语言、操作系统。应用程序的不同组件通过网络上的通信协议向其他组件提供服务。通信可以是简单的数据传递，也可以是两个或多个服务彼此协调连接。 SOA 面向服务架构中主要有两个角色：服务提供者和使用者。如上图所示，服务消费者可以通过发送消息来调用订单、购买、账号的服务，这些消息由服务总线转换后发送给对应的服务，实现 SOA 服务之间的交互通信。 SOA 面向服务架构主要适用于大型软件服务企业对外提供服务的场景，至于一般业务场景就并不适用了，因为其服务的定义、注册和调用都需要较为烦琐的编码或者配置实现，并且业务总线也容易导致系统的单点风险并拖累整体性能。 微服务架构随着互联网浪潮的来临，越来越多的中小微企业推出面向普通大众的网站或者应用。这些企业不同于大型软件服务企业，没有能力也无须构建 SOA 所依赖的 ESB 企业服务总线。于是继承 SOA 众多优点和理念的微服务架构于 2014 年由 Matrin Fowler 提出，其理念是将业务系统彻底地组件化和服务化，形成多个可以独立开发、部署和维护的服务或者应用的集合，以应对更快的需求变更和更短的开发迭代周期。 微服务也是一种架构风格，它提倡将大型复杂软件应用划分成多个微服务，这些服务之间互相协调、配合，可独立部署；服务之间松耦合，每个服务代表着一个小的业务能力（如下图所示）。 总体来说，微服务架构有如下的特点： 微服务遵循单一原则，每个微服务负责一个独立上下文边界； 微服务架构提供的服务之间采用 RESTful 等轻量协议传输，相比 ESB 更轻量； 每个服务都有自己独立的业务开发活动和周期； 微服务一般使用容器技术独立部署，运行在自己的独立进程中，合理分配其所需的系统资源，这样开发者就可以更加方便地制定每个服务的优化方案，提高系统可维护性。 但是，微服务架构也会遇到这样或那样的问题。比如，微服务架构拆分的服务实例过多的话，服务治理成本将会极大升高，不利于系统维护；服务之间相互依赖，有可能形成复杂的依赖链条，往往单个服务异常，其他服务都会受到影响，出现服务雪崩效应；服务实例之间交互需要处理分布式事务、调用幂等性和重试等问题，开发成本高，对团队挑战大。 微服务有哪些优势与劣势优势 应用小，可快速编译部署 单个微服务维护性变高，修改容易，因为每个团队独立负责一块功能。新功能交付变快，可以快速开发交付 扩展性变高，根据业务规模可以随时缩减/增加服务器规模 可靠性变强，可以部署很多独立的服务 业务解耦，按照业务边界拆分为多个独立的服务模块 提升研发效率，业务拆分后，服务模块变小，在一个团队内就可以独立编写、测试、发布，加快研发效率。 微服务有这么多优势，那微服务是“银弹”吗？微服务不是银弹，它带来了很多优势，同时也带来了很多劣势（问题）。 劣势 整体复杂度变高，从哪些方面来管理这种复杂度？ 运维变得复杂：微服务变多，怎么监控所有微服务，保证服务稳定？出了问题，怎么定位问题？ 服务管理：微服务变多，管理复杂度变高，治理变得复杂 测试方面的挑战：你需要结合其他的微服务来进行集成测试 分布式问题：分布式数据一致性、分布式事务 服务保障：一个服务出了问题，如何才能不影响其他服务？ 总体架构图 上面的总体架构图一共分了6层 接入层也可以叫负载均衡层，把外部的流量引入到系统中来。一般负载均衡软件有nginx，lvs，还有各大云服务厂商自己的负载均衡服务。 网关层内部接口的一些认证、安全、鉴权、过滤、限流等服务，一般处于这一层。这一层把内部的服务接口做一层安全隔离，保护内部服务，同时也可以实现一些其他需求，比如前面讲的鉴权、黑名单过滤等等需求。所以这一层在微服务架构中是很重要的一层。 业务服务层基础服务和聚合服务 基础服务：根据业务特点又可以分为核心基础服务、公共服务、中间层服务等。 聚合服务：把下面细粒度的基础服务再进一步封装、关联，组合成新的服务，供上层调用。这一层可以实现多变的需求。上面的这种划分是根据逻辑来划分，各个公司可以根据自己实际的业务需求来进行划分。 支撑服务层微服务能够成功实施落地，这一层与下一层CI/CD的配套设施是非常重要。微服务不是把上面的业务服务写完就完事了，在服务治理的过程中需要很多配套设置支持。这一层包括注册服务中心，配置中心，监控报警服务，日志聚合服务，调用链监控几大服务，后台服务涉及的服务有消息队列，定时任务，数据访问等内容。 平台服务层这一层是实施业务弹性治理的关键。集群的资源调度：扩展和减少。业务量上来时，可以弹性增加资源。在微服务建设过程中，可能会遇到一些突发事件。比如微博明星热点事件，会导致访问量暴增，这就需要能实时增加服务资源应对这种突发情况，热点过后，又要减少资源。镜像管理和发布系统配合使用可以应对出现的这种情况。所以很多团队后面会引入docker+k8s，容器，镜像管理，容器服务编排。此外，基于CI/CD的DevOps也是构建在这一层能力。 基础设施层这个是最底层的基础设施，网络，存储，硬盘，IDC的部分。laas 这个概念就是针对这一层。 微服务技术体系 Golang微服务技术栈微服务框架 go-micro go-kit kratos bilibili出品 jupiter 斗鱼出品 go-zero 好未来 网关 kong nginx+lua traefik apisix 服务注册和发现 consul etcd zookeeper 配置中心 Apollo Nacos etcd 服务治理断路器： hystrix-go 流量控制： sentinel-golang-从限流、流量整形、熔断降级、系统负载保护等多个维度来帮助您保障微服务的稳定性。 链路监控zipkin，pinpoint，skywalking，jaeger 日志、业务、系统监控prometheusELK CI/CD jenkins drone 内容来自: 《Go 微服务实战 38 讲》 微服务架构学习与思考(03)：微服务总体架构图解 微服务架构学习与思考(04)：微服务技术体系","categories":[{"name":"架构","slug":"架构","permalink":"http://github.13sai.com/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://github.13sai.com/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"OSI七层协议","slug":"OSI七层协议","date":"2021-02-20T02:29:06.000Z","updated":"2021-03-02T07:22:34.506Z","comments":true,"path":"2021/02/20/314/","link":"","permalink":"http://github.13sai.com/2021/02/20/314/","excerpt":"","text":"From:网络知识梳理–OSI七层网络与TCP/IP五层网络架构及二层/三层网络 OSI七层网络协议OSI是Open System Interconnect的缩写，意为开放式系统互联。 OSI参考模型各个层次的划分遵循下列原则： 根据不同层次的抽象分层 每层应当有一个定义明确的功能 每层功能的选择应该有助于制定网络协议的国际标准。 各层边界的选择应尽量节省跨过接口的通信量。 层数应足够多，以避免不同的功能混杂在同一层中，但也不能太多，否则体系结构会过于庞大 同一层中的各网络节点都有相同的层次结构，具有同样的功能。 同一节点内相邻层之间通过接口(可以是逻辑接口)进行通信。 七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。 不同节点的同等层按照协议实现对等层之间的通信。 根据以上标准，OSI参考模型分为(从上到下): 物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层。 1)物理层涉及在信道上传输的原始比特流。2)数据链路层的主要任务是加强物理层传输原始比特流的功能，使之对应的网络层显现为一条无错线路。发送包把输入数据封装在数据帧，按顺序传送出去并处理接收方回送的确认帧。3)网络层关系到子网的运行控制，其中一个关键问题是确认从源端到目的端如何选择路由。4)传输层的基本功能是从会话层接收数据而且把其分成较小的单元传递给网络层。5)会话层允许不同机器上的用户建立会话关系。6)表示层用来完成某些特定的功能。7)应用层包含着大量人们普遍需要的协议。 各层功能见下表： 七层模型的每一层都具有清晰的特征。基本来说:1)第七至第四层(应用层-&gt;表示层-&gt;会话层-&gt;传输层)处理数据源和数据目的地之间的端到端通信，2)第三至第一层（网络层-&gt;数据链路层-&gt;物理层）处理网络设备间的通信。 另外：OSI模型的七层也可以划分为两组：1）上层（层7、层6和层5，即应用层-&gt;表示层-&gt;会话层）。上层处理应用程序问题，并且通常只应用在软件上。最高层，即应用层是与终端用户最接近的。2）下层（层4、层3、层2和层1，即传输层-&gt;网络层-&gt;数据链路层-&gt;物理层）。下层是处理数据传输的。物理层和数据链路层应用在硬件和软件上。最底层，即物理层是与物理网络媒介（比如说，电线）最接近的，并且负责在媒介上发送 第7层-应用层定义了用于在网络中进行通信和数据传输的接口 - 用户程式；提供标准服务，比如虚拟终端、文件以及任务的传输和处 理；应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。 第6层-表示层掩盖不同系统间的数据格式的不同性；指定独立结构的数据传输格式；数据的编码和解码；加密和解密； 压缩和解压缩这一层主要解决用户信息的语法表示问题。它将预交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。 第5层-会话层管理用户会话和对话；控制用户间逻辑连接的建立和挂断；报告上一层发生的错误这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。 第4层-处理信息的传输层管理网络中端到端的信息传送；通过错误纠正和流控制机制提供可靠且有序的数据包传送；提供面向无连 接的数据包的传送；第4层的数据单元也称作数据包(packets)。但是，当你谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段 (segments)而UDP协议的数据单元称为“数据报(datagrams)”。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端(最终用户到最终用户)的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括：TCP、UDP、SPX等。 第3层-网络层定义网络设备间如何传输数据；根据唯一的网络设备地址路由数据包；提供流和拥塞控制以防止网络资源 的损耗在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。如 果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议(ARP)。有关路由的一切事情都在这第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包(packet)。网络层协议的代表包括：IP、IPX、RIP、OSPF等。 第2层-数据链路层(DataLinkLayer)定义操作通信连接的程序；封装数据包为数据帧；监测和纠正数据包传输错误在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧(Frame)在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧(frame)。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。 第1层-物理层(PhysicalLayer)定义通过网络设备发送数据的物理方式；作为网络媒介和设备间的接口；定义光学、电气以及机械特性。规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。具体地讲，机械 特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等;电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率 距离限制等;功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能;规程特性定义了利用信号线进行bit流传输的一组 操作规程，是指在物理连接的建立、维护、交换信息是，DTE和DCE双放在各电路上的动作系列。在这一层，数据的单位称为比特(bit)。属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等。","categories":[{"name":"网络","slug":"网络","permalink":"http://github.13sai.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://github.13sai.com/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"Git知识汇总","slug":"Git知识汇总","date":"2021-02-13T06:49:23.000Z","updated":"2021-04-13T07:30:40.108Z","comments":true,"path":"2021/02/13/310/","link":"","permalink":"http://github.13sai.com/2021/02/13/310/","excerpt":"","text":"概念4个区git之所以令人费解，主要是它相比于svn等等传统的版本管理工具，多引入了一个暂存区(Stage)的概念，就因为多了这一个概念，而使很多人疑惑。其实，在初学者来说，每个区具体怎么工作的，我们完全不需要关心，而只要知道有这么4个区就够了： 工作区(Working Area) 暂存区(Stage) 本地仓库(Local Repository) 远程仓库(Remote Repository) 5种状态以上4个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是5种状态。以下我们把这5种状态分别命名为： 未修改(Origin) 已修改(Modified) 已暂存(Staged) 已提交(Committed) 已推送(Pushed) 检查修改已修改，未暂存1git diff 已暂存，未提交1git diff --cached 已提交，未推送1git diff master origin/master 撤销修改了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。 恢复已修改，未暂存如果我们只是在编辑器里修改了文件，但还没有执行git add .，这时候我们的文件还在工作区，并没有进入暂存区，我们可以用撤销操作 1git checkout . 或者 1git reset --hard 恢复已暂存，未提交你已经执行了git add .，但还没有执行git commit -m &quot;comment&quot;。这时候你意识到了错误，想要撤销，你可以执行： 12git resetgit checkout . 或者 1git reset --hard git reset只是把修改退回到了git add .之前的状态，也就是说文件本身还处于已修改未暂存状态，你如果想退回未修改状态，还需要执行git checkout .。 或许你已经注意到了，以上两个步骤都可以用同一个命令git reset --hard来完成。是的，就是这个强大的命令，可以一步到位地把你的修改完全恢复到未修改的状态。 恢复已提交，未推送你的手太快，你既执行了git add .，又执行了git commit，这时候你的代码已经进入了你的本地仓库，然而你后悔了，怎么办？不要着急，还有办法。 1git reset --hard origin/master 还是这个git reset --hard命令，只不过这次多了一个参数origin/master，正如我们上面讲过的，origin/master代表远程仓库，既然你已经污染了你的本地仓库，那么就从远程仓库把代码取回来吧。 已推送很不幸，你的手实在是太快了，你既git add了，又git commit了，并且还git push了，这时你的代码已经进入远程仓库。如果你想恢复的话，还好，由于你的本地仓库和远程仓库是等价的，你只需要先恢复本地仓库，再强制push到远程仓库就好了： 12git reset --hard HEAD^git push -f 部分远程仓库设置了禁止强制push，我们可以使用以下方法。 revertgit revert用于反转提交。执行revert命令时要求工作树必须是干净的，git revert用一个新提交来消除一个历史提交所做的任何修改。revert 之后你的本地代码会回滚到指定的历史版本，这时你再 git push 就可以把线上的代码更新。 常用命令 命令 说明 git clone 克隆 git branch (分支名) 创建分支 -D删除分支 git checkout (分支名) 切换分支 -b创建并切换 git checkout (文件名) 撤销此文件修改 git add 将该文件添加到缓存 git status 查看在你上次提交之后是否有修改 git commit 将缓存区内容添加到仓库中 git diff 来查看执行 git status 的结果的详细信息 git reset HEAD 命令用于取消已缓存的内容 git rm 文件 删除文件-f强制删除 git mv 移动文件 git merge 合并分支 git fetch 从远程获取最新版本到本地 git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 将本地分支的更新，推送到远程主机 git push origin –delete test 删除远程分支test git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 将远程存储库中的更改合并到本地分支中 git rebase 命令在另一个分支基础之上重新应用，用于把一个分支的修改合并到当前分支。 git log 命令用于显示提交日志信息。 git reflog 显示每一次命令 git revert 生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留 git reset HEAD 如果发现错误的将不想暂存的文件被git add进入索引之后，想回退取消，则可以使用 设置用户名邮箱： git config –global user.name “13sai” git config –global user.email “957042781@qq.com“ 几个常见问题与解决方案12345678910111213141516171819202122232425262728293031323334353637fatal: No configured push destination.解决：$ git remote add -f -t master -m master origin git://example.com/git.git/fatal: The current branch test has no upstream branch.解决：git push --set-upstream origin test模仿 git clone，但只跟踪选定的分支$ mkdir project.git$ cd project.git$ git init$ git remote add -f -t master -m master origin git://example.com/git.git/$ git merge originfatal：Unable to create &#x27;E:/project/scrm/.git/index.lock&#x27;: File exists.rm -f ./.git/index.lockgit log-p 查看差异-n(n为正整数) 查看最近n次的提交--pretty 按指定格式显示日志信息,可选项有：oneline,short,medium,full,fuller,email,raw以及format:&lt;string&gt;,默认为medium，可以通过修改配置文件来指定默认的方式。e.g. git log (--pretty=)oneline--stat 列出文件的修改行数--sortstat 只显示--stat中最后行数修改添加移除的统计--graph 以简单的图形方式列出提交记录--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。--name-only 仅在提交信息后显示已修改的文件清单。--name-status 显示新增、修改、删除的文件清单。 列出tag git tag # 在控制台打印出当前仓库的所有tag git tag -l ‘v0.1.*’ # 搜索符合模式的Tag 打tag git tag分为两种类型：轻量tag和附注tag。轻量tag是指向提交对象的引用，附注Tag则是仓库中的一个独立对象。建议使用附注Tag。 创建轻量Tag git tag v0.1.2-light 创建附注Tag git tag -a v0.1.2 -m “0.1.2版本” 创建轻量Tag不需要传递参数，直接指定Tag名称即可。 创建附注Tag时，参数a即annotated的缩写，指定Tag类型，后附Tag名。参数m指定Tag说明，说明信息会保存在Tag对象中。 切换到Tag与切换分支命令相同，用 git checkout [tagname] 查看Tag信息用git show命令可以查看Tag的版本信息： git show v0.1.2 删除Tag误打或需要修改Tag时，需要先将Tag删除，再打新Tag。 git tag -d v0.1.2 # 删除Tag 参数d即delete的缩写，意为删除其后指定的Tag。 给指定的commit打Tag 打Tag不必要在head之上，也可在之前的版本上打，这需要你知道某个提交对象的校验和（通过git log获取）。 补打Tag git tag -a v0.1.1 9fbc3d0 Tag推送到服务器 通常的git push不会将Tag对象提交到git服务器，我们需要进行显式的操作： git push origin v0.1.2 # 将v0.1.2 Tag提交到git服务器 git push origin –-tags # 将本地所有Tag一次性提交到git服务器 注意：如果想看之前某个Tag状态下的文件，可以这样操作 git tag 查看当前分支下的Tag git checkout v0.21 此时会指向打v0.21 Tag时的代码状态，（但现在处于一个空的分支上） 删除远程分支和tag在Git v1.7.0 之后，可以使用这种语法删除远程分支： git push origin –delete 删除tag这么用： git push origin –delete tag 否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支： git push origin : 这是删除tag的方法，推送一个空tag到远程tag： git tag -d git push origin :refs/tags/ 重命名远程分支删除远程分支： git push –delete origin devel 重命名本地分支： git branch -m devel develop 推送本地分支： git push origin develop 把本地tag推送到远程 git push –tags # 推送所有tag git push origin :tag # 推送tag","categories":[{"name":"ci","slug":"ci","permalink":"http://github.13sai.com/categories/ci/"}],"tags":[{"name":"git","slug":"git","permalink":"http://github.13sai.com/tags/git/"}]},{"title":"Docker基础与常用命令","slug":"Docker基础与常用命令","date":"2021-02-10T07:13:35.000Z","updated":"2021-04-26T03:28:37.340Z","comments":true,"path":"2021/02/10/312/","link":"","permalink":"http://github.13sai.com/2021/02/10/312/","excerpt":"","text":"Docker 是什么？Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 Docker的三个概念 镜像（Image）：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。 容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。 仓库（Repository）：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。 Docker 的用途Docker 的主要用途，目前有三大类。 （1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 （2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 （3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。 Docker的优缺点优点1. 更高效的利用系统资源 docker对系统资源的利用率更高，无论是应用执行速度，内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机往往可以运行更多数量的应用。 2. 更快速的启动时间 传统的虚拟机技术启动应用服务往往需要数分钟，而docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级，甚至毫秒级的启动时间，大大的节约了开发测试，部署的时间。 3. 一致的运行环境 开发过程中常见的一个问题是环境一致问题，由于开发环境，测试环境，生产环境不一致，导致有些bug并未在开发过程中发现。而docker的镜像提供了除内核外完整的运行时环境，确保环境一致性，从而不会在出现“这段代码在我机器上没问题”这类问题。 4. 持续支付和部署 对开发和运维人员来说，最希望就是一次创建和部署，可以在任意的地方运行。（定制应用镜像来实现集成、持续支付、部署。开发人员可以通过dockerfile来进行镜像构建，并结合持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署）。而且使用dockerfile使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 5. 更轻松的迁移 由于docker确保了执行环境的一致性，使得应用的迁移更加的容易。docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云、甚至是笔记本、其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 6. 更轻松的维护和拓展 docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得十分简单。此外，docker团队同各个开源项目团队一起维护了一大批高质量的官网镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 缺点1.隔离性 基于hypervisor的虚拟技术，在隔离性上比容器技术要好，它们的系统硬件资源完全上虚拟化的，当一台虚拟机出现系统级别的问题，往往不会蔓延到同一宿主机上的其它虚拟机上，但是容器就不一样了，容器之间共享同一个操作系统内核及其它组件，所以在受到诸如黑客攻击这种情况的时候，很容易通过底层操作系统影响的其它容器，甚至逐个击破，产生连锁反应，当然，这个问题可以通过部署容器来解决，但随之又会产生新的问题，比如成本增加以及性能问题。 2.性能 不管是虚拟机还是容器，都是运用不同的技术对应用本身进行了一定程度的封装与隔离，在降低应用和应用之间以及应用和环境之间的耦合性上做了很多努力，但是随之而来的，就会产生更过的网络连接转发和数据交互，这在低并发系统上虽然不会很明显，但是当同一虚拟机或者服务器下面的容器需要更高并发量支撑的时候，也就是并发问题成为系统瓶颈的时候，容器会将这个问题放大，所以，并不是所有的场景都适合容器技术。 3.存储方案 容器的诞生并不是为OS抽象服务的，这是它和虚拟机最大的区别，这样的基因意味着容器天生是为应用环境做更多的努力，容器的伸缩也是基于容器的这一特性，而与之相对的，需要持久化存储方案恰恰相反，在数据存储这一点上Docker容器提供的解决方案是利用volume接口(存储卷)形成数据的映射和转移，以实现数据持久化的目的。但是这样同样也会造成一部分资源的浪费和更多的交互，不管是映射到宿主机上还是网络磁盘，都是退而求其次的解决方案。 基础命令 启动 docker start 容器名 删除 docker rm 容器名 停止所有容器 docker stop $(docker ps -a -q) 删除所有容器 docker rm $(docker ps -a -q) 容器构建镜像 123456789Usage:docker build [OPTIONS] PATH | URL | -OPTIONS:-t ，--tag list #构建后的镜像名称-f， --file string #指定Dockerfiile文件位置示例:- 1，docker build .- 2，docker build -t redis:v1 .- 3，docker build -t redis:v2 -f /path/Dockerfile /path一般常用第2种方式构建，我们在构建时都会切换到Dockerfile文件的目录下进行构建，所以不需要指定-f参数 进入容器（未必一定是bash命令） docker exec -it 容器名 bash 查看容器详细信息 docker inspect 容器名 查看容器的日志 docker logs 容器名 查看本地镜像 docker images docker 网络 命令 说明 docker network connect 将容器连接到网络。 docker network create 创建新的 Docker 网络。默认情况下，在 Windows 上会采用 NAT 驱动，在 Linux 上会采用 Bridge 驱动。可以使用 -d 参数指定驱动（网络类型）。 docker network disconnect 断开容器的网络。 docker network inspect 提供 Docker 网络的详细配置信息。 docker network ls 用于列出运行在本地 Docker 主机上的全部网络。 docker network prune 删除 Docker 主机上全部未使用的网络。 docker network rm 删除 Docker 主机上指定网络。 镜像的保存 123docker save ae513a47849c &gt; nginx-save.tarordocker save -o nginx-save.tar ae513a47849c 镜像的导入 123docker load &lt; nginx-save.tarordocker load -i nginx-save.tar 容器的导出 1docker export -o mysql-`date +%Y%m%d`.tar 220aee82cfea 容器的导入 1docker import my_ubuntu_v3.tar runoob/ubuntu:v4 镜像和容器导出和导入的区别: 1.镜像导入是复制的过程2.容器导入是将当前容器变成一个新的镜像 save 和 export区别： save 保存镜像所有的信息-包含历史 export 只导出当前的信息","categories":[{"name":"Docker","slug":"Docker","permalink":"http://github.13sai.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://github.13sai.com/tags/Docker/"}]},{"title":"小白必须懂的MongoDB的十大总结","slug":"小白必须懂的MongoDB的十大总结","date":"2021-02-03T04:11:33.000Z","updated":"2021-04-07T14:21:37.781Z","comments":true,"path":"2021/02/03/307/","link":"","permalink":"http://github.13sai.com/2021/02/03/307/","excerpt":"","text":"文章来源: 小白必须懂的MongoDB的十大总结 一、MongoDB的认识1、什么是MongoDB？MongoDB 是一个介于关系数据库和非关系数据库之间的开源产品，是最接近于关系型数据库的 NoSQL 数据库。它在轻量级JSON 交换基础之上进行了扩展，即称为 BSON 的方式来描述其无结构化的数据类型。尽管如此它同样可以存储较为复杂的数据类型。它和Redis有异曲同工之妙。虽然两者均为 NoSQL ，但是 MongoDB 相对于 Redis 而言，MongoDB 更像是传统的数据库。早些年我们是先有了 Relation Database (关系型数据库)，然后出现了很多很复杂的query ，里面用到了很多嵌套，很多 join 操作。所以在设计数据库的时候，我们也考虑到了如何应用他们的关系，使得写 query 可以使 database 效率达到最高。后来人们发现，不是每个系统，都需要如此复杂的关系型数据库。有些简单的网站，比如博客，比如社交网站，完全可以斩断数据库之间的一切关系。这样做带来的好处是，设计数据库变得更加简单，写 query 也变得更加简单。然后，query 消耗的时间可能也会变少。因为 query 简单了，少了许多消耗资源的 join 操作，速度自然会上去。正如所说的， query 简单了，很有以前 MySQL 可以找到的东西，现在关系没了，通过 Mongo 找不到了。我们只能将几组数据都抓到本地，然后在本地做 join ，所以在这点上可能会消耗很多资源。这里我们可以发现。如何选择数据库，完全取决于你所需要处理的数据的模型，即 Data Model 。如果它们之间，关系错综复杂，千丝万缕，这个时候 MySQL 一定是首选。如果他们的关系并不是那么密切，那么， NoSQL 将会是利器。 MongoDB 和 Redis 一样均为 key-value 存储系统，它具有以下特点： 面向集合存储，易存储对象类型的数据。 模式自由。 支持动态查询。 支持完全索引，包含内部对象。 支持查询。 支持复制和故障恢复。 使用高效的二进制数据存储，包括大型对象(如视频等)。 自动处理碎片，以支持云计算层次的扩展性 支持 Python ， PHP ， Ruby ， Java ， C ， C# ， Javascript ，Perl 及 C++ 语言的驱动程序，社区中也提供了对 Erlang 及 .NET 等平台的驱动程序。 文件存储格式为 BSON (一种 JSON 的扩展)。 可通过网络访问。 2、MongoDB与MySQL性能比较像 MySQL 一样， MongoDB 提供了丰富的远远超出了简单的键值存储中提供的功能和功能。 MongoDB 具有查询语言，功能强大的辅助索引(包括文本搜索和地理空间)，数据分析功能强大的聚合框架等。相比使用关系数据库而言，使用MongoDB ，您还可以使用如下表所示的这些功能，跨越更多样化的数据类型和数据规模。 MySQL MongoDB 丰富的数据模型 否 是 动态 Schema 否 是 数据类型 是 是 数据本地化 否 是 字段更新 是 是 易于编程 否 是 复杂事务 是 否 审计 是 是 自动分片 否 是 MySQL 中的许多概念在 MongoDB 中具有相近的类比。本表概述了每个系统中的一些常见概念。 MySQL MongoDB 表 集合 行 文档 列 字段 joins 嵌入文档或者链接 3、应用范围和限制MongoDB 的主要目标是在 key-value (键/值)存储方式(提供了高性能和高度伸缩性)以及传统的 RDBMS 系统(丰富的功能)架起一座桥梁，集两者的优势于一身。 MongoDB 适用范围如下： 网站数据： Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。 缓存：由于性能很高， Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由 Mongo 搭建的持久化缓存层可以避免下层的数据源过载。 大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。 高伸缩性的场景： Mongo 非常适合由数十或数百台服务器组成的数据库。 Mongo 的路线图中已经包含对 MapReduce 引擎的内置支持。 用于对象及 JSON 数据的存储： Mongo 的 BSON 数据格式非常适合文档化格式的存储及查询。 MongoDB 当然也会有以下场景的限制： 高度事物性的系统：例如银行或会计系统。传统的关系型数据库目前还是更适用于需要大量原子性复杂事务的应用程序。 传统的商业智能应用：针对特定问题的 BI 数据库会对产生高度优化的查询方式。对于此类应用，数据仓库可能是更合适的选择。 需要 SQL 的问题。 二、MongoDB的安装环境准备 CentOS7 MongoDB 3.6 安装步骤1、创建一个 mongodb-org-3.6.repo 文件1vi /etc/yum.repos.d/mongodb-org-3.6.repo 在文件中加入如下内容： 123456[mongodb-org-3.6]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/amazon/2013.03/mongodb-org/3.6/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc 退出编辑模式，直接输入如下命令安装即可： 1sudo yum install -y mongodb-org 若要安装特定版本的 MongoDB ，请分别指定每个组件包并将版本号附加到包名称，如下所示： 1sudo yum install -y mongodb-org-3.6.3 mongodb-org-server-3.6.3 mongodb-org-shell-3.6.3 mongodb-org-mongos-3.6.3 mongodb-org-tools-3.6.3 你可以指定任何可用的 MongoDB 版本。然而， yum 会在新版本可用时升级软件包。为防止意外升级，请钉住包装。要固定软件包，请将以下 exclude 指令添加到 /etc/yum.conf 文件中： 1exclude=mongodb-org,mongodb-org-server,mongodb-org-shell,mongodb-org-mongos,mongodb-org-tools 我们直接运行如下命令： 1mongod -repair 看到如下字样，说明我们安装成功！ 我们创建一个 db ，并查看下 mongo 的安装位置： 12mkdir dbwhereis mongod 安装完成后启动 mongodb ，并查看下 mongob 启动状态： 12systemctl start mongod.servicesystemctl status mongod.service 如果出现如下字样，说明启动成功！ 成功启动 MongoDB 后，新建一个命令行输入 mongo 进行登录操作，即可进行数据库的一些操作了。 1mongo 三、MongoDB数据类型及常用命令讲解MongoDB 的数据类型大致有下列几种： 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSON (二进制的 JSON)元素的最低值和最高值相对比。 Arrays 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。 下面我们将介绍一些 MongoDB 的常用命令！ 1、创建数据库use 数据库名称 ：创建一个新的数据库。注意：如果该数据库不存在，则创建，如果该数据库存在，则是切换如果创建了数据库，没有任何的操作，则会自动删除该数据库 example： 12&gt; use stuswitched to db stu 2、查看数据库show dbs ：查看当前有多少个数据库 example： 1234&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GB 3、创建集合db.集合名.insert(&#123;&#125;) ：向集合里面，添加文档。&#123;&#125; 里面是 json 的文档。注意： mongodb 里面的集合是隐式创建，就是无需创建，直接使用。 db 表示显示当前所在的数据库。 example： 1234&gt; db.php.insert(&#123;&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:20,&quot;email&quot;:&quot;xiaoming@gmail.com&quot;&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.php.insert(&#123;&quot;name&quot;:&quot;xiaohong&quot;,&quot;age&quot;:18,&quot;email&quot;:&quot;xiaohong@gmail.com&quot;&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) 4、查看集合show tables ：查看当前数据库中的集合 example： 12&gt; show tablesphp 5、查询集合里面的文档db.集合名.find() ：查询当前数据库中该集合下的所有文档 example： 123&gt; db.php.find()&#123; &quot;_id&quot; : ObjectId(&quot;5b9318ac487b851e62879578&quot;), &quot;name&quot; : &quot;xiaoming&quot;, &quot;age&quot; : 20, &quot;email&quot; : &quot;xiaoming@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b9319a2487b851e62879579&quot;), &quot;name&quot; : &quot;xiaohong&quot;, &quot;age&quot; : 18, &quot;email&quot; : &quot;xiaohong@gmail.com&quot; &#125; db.集合名.find ：查询当前数据库中该集合下的第一个文档 example： 1234567891011121314151617181920212223242526272829&gt; db.php.findfunction (query, fields, limit, skip, batchSize, options) &#123; var cursor = new DBQuery(this._mongo, this._db, this, this._fullName, this._massageObject(query), fields, limit, skip, batchSize, options || this.getQueryOptions()); &#123; const session = this.getDB().getSession(); const readPreference = session._serverSession.client.getReadPreference(session); if (readPreference !== null) &#123; cursor.readPref(readPreference.mode, readPreference.tags); &#125; const readConcern = session._serverSession.client.getReadConcern(session); if (readConcern !== null) &#123; cursor.readConcern(readConcern.level); &#125; &#125; return cursor;&#125; 6、删除集合db.集合名.drop() ：删除当前数据库中的集合 example： 12&gt; db.php.drop()true 7、删除数据库db.dropDatabase() ：删除当前的数据库 12&gt; db.dropDatabase()&#123; &quot;dropped&quot; : &quot;stu&quot;, &quot;ok&quot; : 1 &#125; 8、帮助命令help ：全局帮助命令 1234567891011121314151617181920212223&gt; help db.help() help on db methods db.mycoll.help() help on collection methods sh.help() sharding helpers rs.help() replica set helpers help admin administrative help help connect connecting to a db help help keys key shortcuts help misc misc things to know help mr mapreduce show dbs show database names show collections show collections in current database show users show users in current database show profile show most recent system.profile entries with time &gt;= 1ms show logs show the accessible logger names show log [name] prints out the last segment of log in memory, &#x27;global&#x27; is default use set current database db.foo.find() list objects in collection foo db.foo.find( &#123; a : 1 &#125; ) list objects in foo where a == 1 it result of the last line evaluated; use to further iterate DBQuery.shellBatchSize = x set default number of items to display on shell exit quit the mongo shell db.help() ：数据库相关的帮助命令 example： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&gt; db.help()DB methods: db.adminCommand(nameOrDocument) - switches to &#x27;admin&#x27; db, and runs command [just calls db.runCommand(...)] db.aggregate([pipeline], &#123;options&#125;) - performs a collectionless aggregation on this database; returns a cursor db.auth(username, password) db.cloneDatabase(fromhost) db.commandHelp(name) returns the help for the command db.copyDatabase(fromdb, todb, fromhost) db.createCollection(name, &#123;size: ..., capped: ..., max: ...&#125;) db.createView(name, viewOn, [&#123;$operator: &#123;...&#125;&#125;, ...], &#123;viewOptions&#125;) db.createUser(userDocument) db.currentOp() displays currently executing operations in the db db.dropDatabase() db.eval() - deprecated db.fsyncLock() flush data to disk and lock server for backups db.fsyncUnlock() unlocks server following a db.fsyncLock() db.getCollection(cname) same as db[&#x27;cname&#x27;] or db.cname db.getCollectionInfos([filter]) - returns a list that contains the names and options of the db&#x27;s collections db.getCollectionNames() db.getLastError() - just returns the err msg string db.getLastErrorObj() - return full status object db.getLogComponents() db.getMongo() get the server connection object db.getMongo().setSlaveOk() allow queries on a replication slave server db.getName() db.getPrevError() db.getProfilingLevel() - deprecated db.getProfilingStatus() - returns if profiling is on and slow threshold db.getReplicationInfo() db.getSiblingDB(name) get the db at the same server as this one db.getWriteConcern() - returns the write concern used for any operations on this db, inherited from server object if set db.hostInfo() get details about the server&#x27;s host db.isMaster() check replica primary status db.killOp(opid) kills the current operation in the db db.listCommands() lists all the db commands db.loadServerScripts() loads all the scripts in db.system.js db.logout() db.printCollectionStats() db.printReplicationInfo() db.printShardingStatus() db.printSlaveReplicationInfo() db.dropUser(username) db.repairDatabase() db.resetError() db.runCommand(cmdObj) run a database command. if cmdObj is a string, turns it into &#123;cmdObj: 1&#125; db.serverStatus() db.setLogLevel(level,) db.setProfilingLevel(level,slowms) 0=off 1=slow 2=all db.setWriteConcern() - sets the write concern for writes to the db db.unsetWriteConcern() - unsets the write concern for writes to the db db.setVerboseShell(flag) display extra information in shell output db.shutdownServer() db.stats() db.version() current version of the server db.集合名.help() ：集合相关的帮助命令 example： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&gt; db.php.help()DBCollection help db.php.find().help() - show DBCursor help db.php.bulkWrite( operations, ) - bulk execute write operations, optional parameters are: w, wtimeout, j db.php.count( query = &#123;&#125;, ) - count the number of documents that matches the query, optional parameters are: limit, skip, hint, maxTimeMS db.php.copyTo(newColl) - duplicates collection by copying all documents to newColl; no indexes are copied. db.php.convertToCapped(maxBytes) - calls &#123;convertToCapped:&#x27;php&#x27;, size:maxBytes&#125;&#125; command db.php.createIndex(keypattern[,options]) db.php.createIndexes([keypatterns], ) db.php.dataSize() db.php.deleteOne( filter, ) - delete first matching document, optional parameters are: w, wtimeout, j db.php.deleteMany( filter, ) - delete all matching documents, optional parameters are: w, wtimeout, j db.php.distinct( key, query, ) - e.g. db.php.distinct( &#x27;x&#x27; ), optional parameters are: maxTimeMS db.php.drop() drop the collection db.php.dropIndex(index) - e.g. db.php.dropIndex( &quot;indexName&quot; ) or db.php.dropIndex( &#123; &quot;indexKey&quot; : 1 &#125; ) db.php.dropIndexes() db.php.ensureIndex(keypattern[,options]) - DEPRECATED, use createIndex() instead db.php.explain().help() - show explain help db.php.reIndex() db.php.find([query],[fields]) - query is an optional query filter. fields is optional set of fields to return. e.g. db.php.find( &#123;x:77&#125; , &#123;name:1, x:1&#125; ) db.php.find(...).count() db.php.find(...).limit(n) db.php.find(...).skip(n) db.php.find(...).sort(...) db.php.findOne([query], [fields], [options], [readConcern]) db.php.findOneAndDelete( filter, ) - delete first matching document, optional parameters are: projection, sort, maxTimeMS db.php.findOneAndReplace( filter, replacement, ) - replace first matching document, optional parameters are: projection, sort, maxTimeMS, upsert, returnNewDocument db.php.findOneAndUpdate( filter, update, ) - update first matching document, optional parameters are: projection, sort, maxTimeMS, upsert, returnNewDocument db.php.getDB() get DB object associated with collection db.php.getPlanCache() get query plan cache associated with collection db.php.getIndexes() db.php.group( &#123; key : ..., initial: ..., reduce : ...[, cond: ...] &#125; ) db.php.insert(obj) db.php.insertOne( obj, ) - insert a document, optional parameters are: w, wtimeout, j db.php.insertMany( [objects], ) - insert multiple documents, optional parameters are: w, wtimeout, j db.php.mapReduce( mapFunction , reduceFunction , ) db.php.aggregate( [pipeline], ) - performs an aggregation on a collection; returns a cursor db.php.remove(query) db.php.replaceOne( filter, replacement, ) - replace the first matching document, optional parameters are: upsert, w, wtimeout, j db.php.renameCollection( newName , ) renames the collection. db.php.runCommand( name , ) runs a db command with the given name where the first param is the collection name db.php.save(obj) db.php.stats(&#123;scale: N, indexDetails: true/false, indexDetailsKey: , indexDetailsName: &#125;) db.php.storageSize() - includes free space allocated to this collection db.php.totalIndexSize() - size in bytes of all the indexes db.php.totalSize() - storage allocated for all data and indexes db.php.update( query, object[, upsert_bool, multi_bool] ) - instead of two flags, you can pass an object with fields: upsert, multi db.php.updateOne( filter, update, ) - update the first matching document, optional parameters are: upsert, w, wtimeout, j db.php.updateMany( filter, update, ) - update all matching documents, optional parameters are: upsert, w, wtimeout, j db.php.validate( ) - SLOW db.php.getShardVersion() - only for use with sharding db.php.getShardDistribution() - prints statistics about data distribution in the cluster db.php.getSplitKeysForChunks( ) - calculates split points over all chunks and returns splitter function db.php.getWriteConcern() - returns the write concern used for any operations on this collection, inherited from server/db if set db.php.setWriteConcern( ) - sets the write concern for writes to the collection db.php.unsetWriteConcern( ) - unsets the write concern for writes to the collection db.php.latencyStats() - display operation latency histograms for this collection 四、增删改查操作1、添加文档db.集合名.insert(&#123;k1:v1,k2:v2...&#125;) ：向当前数据库的该集合下添加文档 我们在添加文档的时候有如下注意点： a) 文档就是键值对，数据类型是 BSON 格式，支持的值更加丰富。 BSON 是 JSON 的扩展，新增了诸如日期，浮点等 JSON 不支持的数据类型。 b) 在添加的文档里面，都有一个 &#39;_id&#39; 的键，值为对象类型 ObjectID ，在这里，我们解释下 ObjectID 类型： 每个文档都有一个 _id 字段，并且同一集合中的 _id 值唯一，该字段可以是任意类型的数据，默认是一个 ObjectID 对象。ObjectID 对象数据组成：时间戳|机器码|PID|计数器_id 的键值我们可以自己输入，但是不能重复，但要注意的一点是在插入数据的时候，如果 _id 的值重复则会报错 c) 可以使用 js 代码来完成批量插入文档 example： 1234567891011121314151617&gt; for(var i=1;i&lt;=10;i++)&#123;... db.php.insert(&#123;&#x27;name&#x27;:&#x27;xiaobai&#x27;+i,&#x27;age&#x27;:i,&#x27;email&#x27;:&#x27;xiaobai&#x27;+i+&#x27;@gmail.com&#x27;&#125;)... &#125;WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.php.find()&#123; &quot;_id&quot; : ObjectId(&quot;5b931b74a39e4f4842ba36b3&quot;), &quot;name&quot; : &quot;xiaoming&quot;, &quot;age&quot; : 20, &quot;email&quot; : &quot;xiaoming@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931b7ca39e4f4842ba36b4&quot;), &quot;name&quot; : &quot;xiaohong&quot;, &quot;age&quot; : 18, &quot;email&quot; : &quot;xiaohong@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36b5&quot;), &quot;name&quot; : &quot;xiaobai1&quot;, &quot;age&quot; : 1, &quot;email&quot; : &quot;xiaobai1@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36b6&quot;), &quot;name&quot; : &quot;xiaobai2&quot;, &quot;age&quot; : 2, &quot;email&quot; : &quot;xiaobai2@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36b7&quot;), &quot;name&quot; : &quot;xiaobai3&quot;, &quot;age&quot; : 3, &quot;email&quot; : &quot;xiaobai3@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36b8&quot;), &quot;name&quot; : &quot;xiaobai4&quot;, &quot;age&quot; : 4, &quot;email&quot; : &quot;xiaobai4@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36b9&quot;), &quot;name&quot; : &quot;xiaobai5&quot;, &quot;age&quot; : 5, &quot;email&quot; : &quot;xiaobai5@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36ba&quot;), &quot;name&quot; : &quot;xiaobai6&quot;, &quot;age&quot; : 6, &quot;email&quot; : &quot;xiaobai6@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bb&quot;), &quot;name&quot; : &quot;xiaobai7&quot;, &quot;age&quot; : 7, &quot;email&quot; : &quot;xiaobai7@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bc&quot;), &quot;name&quot; : &quot;xiaobai8&quot;, &quot;age&quot; : 8, &quot;email&quot; : &quot;xiaobai8@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bd&quot;), &quot;name&quot; : &quot;xiaobai9&quot;, &quot;age&quot; : 9, &quot;email&quot; : &quot;xiaobai9@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36be&quot;), &quot;name&quot; : &quot;xiaobai10&quot;, &quot;age&quot; : 10, &quot;email&quot; : &quot;xiaobai10@gmail.com&quot; &#125; 2、删除文档db.集合名.remove&#123;(条件)&#125; ：删除当前数据库下指定集合中满足条件的文档(不写条件则删除所有的文档) example： 1234567891011&gt; db.php.remove(&#123;age:20&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)&gt; db.php.remove(&#123;age:&#123;&#x27;$lt&#x27;:6&#125;&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 5 &#125;)&gt; db.php.find()&#123; &quot;_id&quot; : ObjectId(&quot;5b931b7ca39e4f4842ba36b4&quot;), &quot;name&quot; : &quot;xiaohong&quot;, &quot;age&quot; : 18, &quot;email&quot; : &quot;xiaohong@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36ba&quot;), &quot;name&quot; : &quot;xiaobai6&quot;, &quot;age&quot; : 6, &quot;email&quot; : &quot;xiaobai6@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bb&quot;), &quot;name&quot; : &quot;xiaobai7&quot;, &quot;age&quot; : 7, &quot;email&quot; : &quot;xiaobai7@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bc&quot;), &quot;name&quot; : &quot;xiaobai8&quot;, &quot;age&quot; : 8, &quot;email&quot; : &quot;xiaobai8@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bd&quot;), &quot;name&quot; : &quot;xiaobai9&quot;, &quot;age&quot; : 9, &quot;email&quot; : &quot;xiaobai9@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36be&quot;), &quot;name&quot; : &quot;xiaobai10&quot;, &quot;age&quot; : 10, &quot;email&quot; : &quot;xiaobai10@gmail.com&quot; &#125; 这里我们在删除 php 集合中年龄小于6的文档时，我们使用了操作符来完成。 比较运算符 操作符 效果 $gt 大于 $lt 小于 $gte 大于等于 $lte 小于等于 $exists 存在与否 $in 包含 $ne 不等于 $nin 不包含 逻辑运算符 操作符 效果 $exists 存在与否 $or 或者 $and 并且 $not 不存在 $mod 求模 $where 位置 特别的 $exists: true 表示字段存在 排序 sort 操作 效果 $asc 升序 $desc 降序 3、更新文档更新文档有两种方式进行修改 方法一、直接修改 db.集合名.update(&#123;条件&#125;,&#123;新的文档&#125;) ：修改当前数据库下指定集合中满足条件的文档信息 example： 123456&gt; db.php.find()&#123; &quot;_id&quot; : ObjectId(&quot;5b931b7ca39e4f4842ba36b4&quot;), &quot;name&quot; : &quot;xiaohong&quot;, &quot;age&quot; : 18, &quot;email&quot; : &quot;xiaohong@gmail.com&quot; &#125;&gt; db.php.update(&#123;age:18&#125;,&#123;name:&#x27;xiaobai5&#x27;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.php.find()&#123; &quot;_id&quot; : ObjectId(&quot;5b931b7ca39e4f4842ba36b4&quot;), &quot;name&quot; : &quot;xiaobai5&quot; &#125; db.集合.update(条件,新文档,是否新增,是否修改多条) ：修改当前数据库下指定集合中满足条件的文档信息 是否新增：如果值是1(true)则没有满足条件的 则添加 是否修改多条：若值是1(true)，如果满足条件的有多个文档 则都要修改 example： 12345678910&gt; db.php.update(&#123;age:10&#125;,&#123;name:&#x27;xiaoli&#x27;&#125;,true,true)WriteResult(&#123; &quot;nMatched&quot; : 0, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 0, &quot;writeError&quot; : &#123; &quot;code&quot; : 9, &quot;errmsg&quot; : &quot;multi update only works with $ operators&quot; &#125;&#125;) 方法二、使用修改器 example： 我们要修改 age=6 的文档名称为 xiaosan ，并且其他键值不能丢失 我们可以使用修改器 $inc ：加上一个数字 $set ：修改某一个字段，如果该字段不存在就增这个字段 语法：db.集合名.update(&#123;条件&#125;,&#123;修改器名称:&#123;修改的键:修改的新值&#125;&#125;) 12&gt; db.php.update(&#123;age:6&#125;,&#123;&#x27;$set&#x27;:&#123;name:&#x27;xiaosan&#x27;&#125;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;) 那如果我们要修改 age=10 的文档的年龄增加十岁，我们可以这样做： 12&gt; db.php.update(&#123;age:10&#125;,&#123;$inc:&#123;age:10&#125;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;) 4、查询文档语法： db.集合名.find(&#123;条件&#125;) example： 取出 php 集合里面的第一个文档 12&gt; db.php.findOne()&#123; &quot;_id&quot; : ObjectId(&quot;5b931b7ca39e4f4842ba36b4&quot;), &quot;name&quot; : &quot;xiaobai5&quot; &#125; 取出 php 集合里面 age=6 的文档 12&gt; db.php.find(&#123;age:6&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36ba&quot;), &quot;name&quot; : &quot;xiaosan&quot;, &quot;age&quot; : 6, &quot;email&quot; : &quot;xiaobai6@gmail.com&quot; &#125; 取出 php 集合里面 age&gt;8 的文档 123&gt; db.php.find(&#123;age:&#123;&#x27;$gt&#x27;:8&#125;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bd&quot;), &quot;name&quot; : &quot;xiaobai9&quot;, &quot;age&quot; : 9, &quot;email&quot; : &quot;xiaobai9@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36be&quot;), &quot;name&quot; : &quot;xiaobai10&quot;, &quot;age&quot; : 20, &quot;email&quot; : &quot;xiaobai10@gmail.com&quot; &#125; 取出 php 集合里面的文档，只显示 name 键 1234567891011121314&gt; db.php.find(&#123;&#125;,&#123;age:1&#125;)//1表示只显示age键值&#123; &quot;_id&quot; : ObjectId(&quot;5b931b7ca39e4f4842ba36b4&quot;) &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36ba&quot;), &quot;age&quot; : 6 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bb&quot;), &quot;age&quot; : 7 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bc&quot;), &quot;age&quot; : 8 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bd&quot;), &quot;age&quot; : 9 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36be&quot;), &quot;age&quot; : 20 &#125;&gt; db.php.find(&#123;&#125;,&#123;age:0&#125;)//1表示除了显示age键值，其他的都显示&#123; &quot;_id&quot; : ObjectId(&quot;5b931b7ca39e4f4842ba36b4&quot;), &quot;name&quot; : &quot;xiaobai5&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36ba&quot;), &quot;name&quot; : &quot;xiaosan&quot;, &quot;email&quot; : &quot;xiaobai6@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bb&quot;), &quot;name&quot; : &quot;xiaobai7&quot;, &quot;email&quot; : &quot;xiaobai7@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bc&quot;), &quot;name&quot; : &quot;xiaobai8&quot;, &quot;email&quot; : &quot;xiaobai8@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bd&quot;), &quot;name&quot; : &quot;xiaobai9&quot;, &quot;email&quot; : &quot;xiaobai9@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36be&quot;), &quot;name&quot; : &quot;xiaobai10&quot;, &quot;email&quot; : &quot;xiaobai10@gmail.com&quot; &#125; 根据年龄的(降序|升序)来显示文档 12db.集合名.find().sort(&#123;age:1&#125;)根据年龄升序db.集合名.find().sort(&#123;age:0&#125;)根据年龄降序 显示 php 集合中的前三个文档 1234&gt; db.php.find().limit(3)&#123; &quot;_id&quot; : ObjectId(&quot;5b931b7ca39e4f4842ba36b4&quot;), &quot;name&quot; : &quot;xiaobai5&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36ba&quot;), &quot;name&quot; : &quot;xiaosan&quot;, &quot;age&quot; : 6, &quot;email&quot; : &quot;xiaobai6@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bb&quot;), &quot;name&quot; : &quot;xiaobai7&quot;, &quot;age&quot; : 7, &quot;email&quot; : &quot;xiaobai7@gmail.com&quot; &#125; 显示 php 集合中的第三个文档到第五个文档 1234&gt; db.php.find().skip(2).limit(3)&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bb&quot;), &quot;name&quot; : &quot;xiaobai7&quot;, &quot;age&quot; : 7, &quot;email&quot; : &quot;xiaobai7@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bc&quot;), &quot;name&quot; : &quot;xiaobai8&quot;, &quot;age&quot; : 8, &quot;email&quot; : &quot;xiaobai8@gmail.com&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5b931dfba39e4f4842ba36bd&quot;), &quot;name&quot; : &quot;xiaobai9&quot;, &quot;age&quot; : 9, &quot;email&quot; : &quot;xiaobai9@gmail.com&quot; &#125; 统计 php 集合中文档的个数 1db.集合名.count():返回集合中有多少个文档 五、用户管理(权限控制)1、权限概述在 MongoDB 里面的用户是属于数据库的，每个数据库都有自己的管理员。管理员登录后，只能操作所属的数据库。注意：在 admin 的数据库中创建的用户是超级管理员，登陆后可以操作任何的数据库 2、创建用户(1) 选择数据库 1use 数据库的名称 (2) 添加用户 1db.createUser(用户名,密码,是否只读) 第三个参数”是否只读”默认是 false ，创建的用户可以执行读写，如果是 true ，则创建的用户只能查询，不能修改。 注意点：在创建用户之前，必须先创建一个超级管理员 example： 1234567891011121314151617&gt; use adminswitched to db admin&gt; db.createUser(&#123;user:&#x27;user&#x27;,... pwd:&#x27;passwd&#x27;, ... roles:[... &#123;role:&#x27;userAdminAnyDatabase&#x27;, db:&#x27;admin&#x27;&#125;... ]... &#125;)Successfully added user: &#123; &quot;user&quot; : &quot;user&quot;, &quot;roles&quot; : [ &#123; &quot;role&quot; : &quot;userAdminAnyDatabase&quot;, &quot;db&quot; : &quot;admin&quot; &#125; ]&#125; 3、验证权限(用户登录)在添加完成管理员之后，我们做如下操作： (1) 如果你是安装成windows服务的方式安装的，则卸载服务，在安装时添加一个 -auth 选项，auth 表示要开启权限认证 (2) 如果你是直接启动的方式，则停止服务，重新启动，在启动时也要添加 --auth 选项，auth 表示要开启权限认证 如果没有通过权限验证，直接操作数据库，则报如下错误提示： 1234error: &#123; &quot;$err&quot; : &quot;unauthorized db:test lock type:-1 client:127.0.0.1&quot;, &quot;code&quot; : 10057&#125; 如何通过权限验证 选择数据库 执行db.auth (用户名,密码) 4、删除用户和修改密码注意：创建的用户名和密码是存储在各自数据库里面的 system.users 集合里面的。想要删除用户，则直接删除 system.users 集合里面的文档即可 5、总结说明a) 非 admin 数据库的用户不能使用数据库命令，比如 show dbs 等 (b) admin 数据库中的用户被视为超级用户(即管理员)，在认证之后，管理员可以读写所有数据库，执行特定的管理命令。 (c) 在开启安全检查之前，一定要至少有个管理员账户。 (d) 数据库的用户账号以文档的形式存储在 system.users 集合里面。可以在 system.users 集合中删除用户账号文档，就可以删除用户。 六、MongoDB中的索引1、普通单列索引 我们用如下代码来测试： 123for(var i=0;i&lt;200000;i++)&#123; db.java.insert(&#123;name:&#x27;xiao&#x27;+i,age:i&#125;)&#125; 第一、我们先检验一下查询性能 12345var start=new Date()db.java.find(&#123;name:&#x27;xiao156789&#x27;&#125;)var end=new Date()end-start17510 第二、为 name 创建索引 1234567&gt; db.java.ensureIndex(&#123;name:1&#125;)&#123; &quot;createdCollectionAutomatically&quot; : false, &quot;numIndexesBefore&quot; : 1, &quot;numIndexesAfter&quot; : 2, &quot;ok&quot; : 1&#125; 第三、再执行第一部分代码可以看出有数量级的性能提升 语法：db.集合名.ensureIndex(&#123;键名:1&#125;) ：1是升序，-1是降序 2、多列索引(复合索引) 创建多列索引语法：db.集合名.ensureIndex(&#123;field1:1/-1,field2:1/-1&#125;)对 name 和 age 建立一个复合索引，可以使用 db.集合名.getIndexes() 查看创建的索引情况 3、子文档索引 语法： db.集合名.ensureIndex(&#123;field.subfield:1/-1&#125;)如下文档可以建立子文档索引 12&#123;name:&#x27;诺基亚手机1&#x27;,price:12.34,spc:&#123;weight:100,area:&#x27;纽约&#x27;&#125;&#125;&#123;name:&#x27;诺基亚手机2&#x27;,price:42.34,spc:&#123;weight:200,area:&#x27;伦敦&#x27;&#125;&#125; 比如要查询 weight=100 的文档 1db.goods.find(&#123;&#x27;spc.weight&#x27;:100&#125;) 根据当前案例，我们建立子文档索引 1db.net.ensureIndex(&#123;&#x27;spc.w&#x27;:1&#125;) 4、唯一索引 语法： db.集合名.ensureIndex(&#123;name:-1&#125;,&#123;unique:true&#125;) 5、查看索引 (1) 查看当前索引状态： db.集合名.getIndexes() (2) 详情查看本次查询使用哪个索引和查询数据的状态信息： db.集合名.find(&#123;name:&#39;&#39;xiao&#125;).explain() 6、删除索引 删除单个索引： db.集合名.dropIndex(&#123;filed:1/-1&#125;) 删除所有索引： db.集合名.dropIndexes() 7、重建索引 一个表经过很多次修改后，导致表的文件产生空洞，索引文件也如此，可以通过索引的重建，减少索引文件碎片，并提高索引的效率，类似 mysql 中的 optimize table 。 mysql 里面使用 optimize table 语法： optimize table 表名 语法： db.集合名.reIndex() 8、索引使用注意事项 (1) 创建索引的时候，注意1是正序创建索引，-1是倒序创建索引 (2) 索引的创建在提高查询性能的同时会影响插入性能，对于经常查询少插入 (3) 复合索引要注意索引的先后顺序 (4) 每个键全建立索引不一定就能提高性能，索引不是万能的。 (5) 在做排序工作的时候如果是超大数据量也可以考虑加上索引用来提高排序的性能。 八、MongoDB中的数据导出与导出利用mongoexport -h host主机 -port 端口 -d 指明使用的库 -o 指明要导出的文件名 -csv 指定导出的csv格式 -q 过滤导出 -f field1 field2 列名 -u username 用户名 -p password 密码 注意：在使用用户名和密码是超级管理员的时候，如果端口是默认的可以不使用-port来指定端口 (2) 导入数据 -d 待导入的数据库 -c 待导入的集合(不存在会自己创建) -type csv/json(默认) -file 备份文件路径 例如：导入json 1./bin/mongoimport -h -port 端口号 -d test -c goods -file ./goodsall.json 导入csv 123./bin/mongoimport -h -port 端口号 -d test -c goods -type csv -f goods.id,goods.name -file ./goodsall.csv./bin/mongoimport -h -port 端口号 -d test -c goods -type csv -f -headline -f goods.id,goods.name -file ./goodsall.csv 九、主从复制(读写分离)主从复制是一个简单的数据库同步备份的集群技术，至少两台数据库服务器，可以分别设置主服务器和从服务器，对主服务器的任何操作都会同步到从服务器上。 实现的注意点 1、在数据库集群中要明确的知道谁是主服务器，主服务器只有一台 2、从服务器要知道自己的数据源 也就是对应的主服务是谁 3、–master用来确定主服务器 –slave和–source来控制从服务器 配置步骤 (1) 启动主服务器 (2) 启动从服务器 (3) 客户端登录到主服务器 添加一些数据，测试是否同步到从服务器，在主服务器里面，添加了一些文档： 第一步，客户端登录到主服务器，添加一些文档 第二步，登录到从服务器，查看是否有数据，如果有数据，则成功了！","categories":[{"name":"SQL","slug":"SQL","permalink":"http://github.13sai.com/categories/SQL/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://github.13sai.com/tags/MongoDB/"}]},{"title":"ElasticSearch基础知识","slug":"ElasticSearch基础知识","date":"2021-02-02T07:06:24.000Z","updated":"2021-04-26T03:34:48.272Z","comments":true,"path":"2021/02/02/306/","link":"","permalink":"http://github.13sai.com/2021/02/02/306/","excerpt":"","text":"文章来源:铭毅天下 1.ES基础1.1 ES定义elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 1.2 Lucene与ES关系？1）Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 2）Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 1.3 ES主要解决问题：1）检索相关数据；2）返回统计结果；3）速度要快。 1.4 ES工作原理当ElasticSearch的节点启动后，它会利用多播(multicast)(或者单播，如果用户更改了配置)寻找集群中的其它节点，并与之建立连接。这个过程如下图所示： 1.5 ES核心概念1）Cluster：集群。ES可以作为一个独立的单个搜索服务器。不过，为了处理大型数据集，实现容错和高可用性，ES可以运行在许多互相合作的服务器上。这些服务器的集合称为集群。 2）Node：节点。形成集群的每个服务器称为节点。 3）Shard：分片。当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的。 4）Replia：副本。为提高查询吞吐量或实现高可用性，可以使用分片副本。副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。 5）全文检索。全文检索就是对一篇文章进行索引，可以根据关键字搜索，类似于mysql里的like语句。全文索引就是把内容根据词的意义进行分词，然后分别创建索引，例如”你们的激情是因为什么事情来的” 可能会被分词成：“你们“，”激情“，“什么事情“，”来“ 等token，这样当你搜索“你们” 或者 “激情” 都会把这句搜出来。 1.6 ES数据架构的主要概念（与关系数据库Mysql对比）（1）关系型数据库中的数据库（DataBase），等价于ES中的索引（Index）（2）一个数据库下面有N张表（Table），等价于1个索引Index下面有N多类型（Type），（3）一个数据库表（Table）下的数据由多行（ROW）多列（column，属性）组成，等价于1个Type由多个文档（Document）和多Field组成。（4）在一个关系型数据库里面，schema定义了表、每个表的字段，还有表和字段之间的关系。 与之对应的，在ES中：Mapping定义索引下的Type的字段处理规则，即索引如何建立、索引类型、是否保存原始索引JSON文档、是否压缩原始JSON文档、是否需要分词处理、如何进行分词处理等。（5）在数据库中的增insert、删delete、改update、查search操作等价于ES中的增PUT/POST、删Delete、改_update、查GET. 1.7 ELK是什么？ ELK=elasticsearch+Logstash+kibanaelasticsearch：后台分布式存储以及全文检索logstash: 日志加工、“搬运工”kibana：数据可视化展示。ELK架构为数据分布式存储、可视化查询和日志解析创建了一个功能强大的管理链。 三者相互配合，取长补短，共同完成分布式大数据处理工作。 2. ES特点和优势 1）分布式实时文件存储，可将每一个字段存入索引，使其可以被检索到。2）实时分析的分布式搜索引擎。 分布式：索引分拆成多个分片，每个分片可有零个或多个副本。集群中的每个数据节点都可承载一个或多个分片，并且协调和处理各种操作； 负载再平衡和路由在大多数情况下自动完成。3）可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。也可以运行在单台PC上（已测试）4）支持插件机制，分词插件、同步插件、Hadoop插件、可视化插件等。 3、ES性能3.1 性能结果展示 硬件配置：CPU 16核 AuthenticAMD内存 总量：32GB硬盘 总量：500GB 非SSD 在上述硬件指标的基础上测试性能如下：1）平均索引吞吐量： 12307docs/s（每个文档大小：40B/docs）2）平均CPU使用率： 887.7%（16核，平均每核：55.48%）3）构建索引大小： 3.30111 GB4）总写入量： 20.2123 GB5）测试总耗时： 28m 54s. 3.2 性能esrally工具（推荐）使用参考：http://blog.csdn.net/laoyang360/article/details/52155481 4、为什么要用ES？4.1 ES国内外使用优秀案例1） 2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”。2）维基百科：启动以elasticsearch为基础的核心搜索架构。3）SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”。4）百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据。 4.2 我们也需要实际项目开发实战中，几乎每个系统都会有一个搜索的功能，当搜索做到一定程度时，维护和扩展起来难度就会慢慢变大，所以很多公司都会把搜索单独独立出一个模块，用ElasticSearch等来实现。 近年ElasticSearch发展迅猛，已经超越了其最初的纯搜索引擎的角色，现在已经增加了数据聚合分析（aggregation）和可视化的特性，如果你有数百万的文档需要通过关键词进行定位时，ElasticSearch肯定是最佳选择。当然，如果你的文档是JSON的，你也可以把ElasticSearch当作一种“NoSQL数据库”， 应用ElasticSearch数据聚合分析（aggregation）的特性，针对数据进行多维度的分析。 【知乎：热酷架构师潘飞】ES在某些场景下替代传统DB个人以为Elasticsearch作为内部存储来说还是不错的，效率也基本能够满足，在某些方面替代传统DB也是可以的，前提是你的业务不对操作的事性务有特殊要求；而权限管理也不用那么细，因为ES的权限这块还不完善。由于我们对ES的应用场景仅仅是在于对某段时间内的数据聚合操作，没有大量的单文档请求（比如通过userid来找到一个用户的文档，类似于NoSQL的应用场景），所以能否替代NoSQL还需要各位自己的测试。如果让我选择的话，我会尝试使用ES来替代传统的NoSQL，因为它的横向扩展机制太方便了。 5. ES的应用场景是怎样的？通常我们面临问题有两个：1）新系统开发尝试使用ES作为存储和检索服务器；2）现有系统升级需要支持全文检索服务，需要使用ES。以上两种架构的使用，以下链接进行详细阐述。http://blog.csdn.net/laoyang360/article/details/52227541 一线公司ES使用场景：1）新浪ES 如何分析处理32亿条实时日志 http://dockone.io/article/5052）阿里ES 构建挖财自己的日志采集和分析体系 http://afoo.me/columns/tec/logging-platform-spec.html3）有赞ES 业务日志处理 http://tech.youzan.com/you-zan-tong-ri-zhi-ping-tai-chu-tan/4）ES实现站内搜索 http://www.wtoutiao.com/p/13bkqiZ.html 6. 如何部署ES？6.1 ES部署（无需安装） 1）零配置，开箱即用2）没有繁琐的安装配置3）java版本要求：最低1.7我使用的1.8[root@lyng config_lhy]# echo $JAVA_HOME/opt/jdk1.8.0_914）下载地址：https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/zip/elasticsearch/2.3.5/elasticsearch-2.3.5.zip5）启动cd /usr/local/elasticsearch-2.3.5./bin/elasticsearchbin/elasticsearch -d(后台运行) 6.2 ES必要的插件必要的Head、kibana、IK（中文分词）、graph等插件的详细安装和使用。http://blog.csdn.net/column/details/deep-elasticsearch.html","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://github.13sai.com/categories/ElasticSearch/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://github.13sai.com/tags/ElasticSearch/"}]},{"title":"vue子组件","slug":"vue子组件","date":"2021-01-26T02:14:53.000Z","updated":"2021-04-13T07:34:50.614Z","comments":true,"path":"2021/01/26/305/","link":"","permalink":"http://github.13sai.com/2021/01/26/305/","excerpt":"","text":"先来看demo: 父组件： 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;app-container calendar-list-container&quot;&gt; &lt;el-tabs v-model=&quot;activeName&quot; type=&quot;card&quot;&gt; &lt;el-tab-pane label=&quot;待审核&quot; name=&quot;first&quot;&gt; &lt;test-page status=&quot;1&quot; @toP=&quot;funct&quot;&gt;&lt;/test-page&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;全部&quot; name=&quot;second&quot;&gt; &lt;test-page status=&quot;0&quot;&gt;&lt;/test-page&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import TestPage from &#x27;@/views/components/TestPage&#x27;export default &#123; components: &#123; TestPage &#125;, name: &quot;test&quot;, data() &#123; return &#123; activeName: &#x27;first&#x27;, &#125;; &#125;, methods: &#123; funct(v) &#123; console.warn(v) &#125; &#125;&#125;;&lt;/script&gt; 子组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;template&gt; &lt;div&gt; &lt;el-table key=&quot;tableList&quot; v-loading=&quot;listLoading&quot; :data=&quot;list&quot; element-loading-text=&quot;给我一点时间&quot; border fit highlight-current-row style=&quot;width: 100%&quot; &gt; &lt;el-table-column align=&quot;center&quot; label=&quot;id&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span&gt;&#123;&#123; scope.row.id &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column align=&quot;center&quot; label=&quot;地点&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span&gt;&#123;&#123; scope.row.address &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column align=&quot;center&quot; label=&quot;状态&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-tag type=&quot;info&quot; v-if=&quot;scope.row.status == 0&quot;&gt;已拒绝&lt;/el-tag&gt; &lt;el-tag v-if=&quot;scope.row.status == 1&quot;&gt;审核中&lt;/el-tag&gt; &lt;el-tag type=&quot;success&quot; v-if=&quot;scope.row.status == 2&quot;&gt;已通过&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column align=&quot;center&quot; label=&quot;活动时间&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span&gt;&#123;&#123; scope.row.start_date &#125;&#125;&lt;/span&gt;&lt;br&gt;至 &lt;span&gt;&#123;&#123; scope.row.end_date &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;...export default &#123; name: &quot;TestPage&quot;, props: [&#x27;status&#x27;], data() &#123; return &#123; list: [], pagination: &quot;&quot;, listQuery: &#123; page: 1, limit: 20, status: 1, type:&#x27;&#x27;, &#125;, typeList: [], dialogFormVisible: false, temp: &#123; image : &#x27;&#x27;, user: &#123; nickname: &#x27;&#x27;, &#125;, college: &#123; name: &quot;&quot;, &#125;, materials: [], &#125;, &#125;; &#125;, created() &#123; this.listQuery.status = this.$props.status; this.getList(); this.$emit(&#x27;toP&#x27;, this.listQuery) &#125;, methods: &#123; ... &#125;&#125;;&lt;/script&gt;&lt;style&gt;.row-container .el-row &#123; margin-bottom: 20px; &amp;:last-child &#123; margin-bottom: 0; &#125; &#125;&lt;/style&gt; 这个demo简单使用了组件引入，及子组件于父组件通信。 引入子组件1234import TestPage from &#x27;@/views/components/TestPage&#x27;export default &#123; components: &#123; TestPage &#125;, 使用: 1&lt;test-page&gt;&lt;/test-page&gt; 父组件传递数据到子组件父组件的status就是传递的数据 1&lt;test-page status=&quot;0&quot;&gt;&lt;/test-page&gt; 子组件接收： 1this.$props.status 子组件传递数据到父组件子组件，其实是传递了一个toP事件 1this.$emit(&#x27;toP&#x27;, this.listQuery) 父组件 123456789&lt;test-page @toP=&quot;funct&quot;&gt;&lt;/test-page&gt;...methods: &#123; funct(v) &#123; console.warn(v) &#125;&#125; 这里需要稍微注意的就是驼峰命名转**-**，使用相对简单。","categories":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/categories/js/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://github.13sai.com/tags/vue/"}]},{"title":"网站不能访问的问题集合","slug":"网站不能访问的问题集合","date":"2021-01-13T03:43:22.000Z","updated":"2021-01-13T03:50:02.003Z","comments":true,"path":"2021/01/13/302/","link":"","permalink":"http://github.13sai.com/2021/01/13/302/","excerpt":"","text":"https访问不了现象https访问不了，绑定host可访问，网站无报错 排查ping域名对于ip也正常，telnet 443端口失败 处理开启443端口 加了CDN的部分页面突然打不开现象加了cdn的部分页面打不开，http页面访问正常，绑定host访问也正常 打不开的情况nginx有报错如： pwritev() “/usr/local/webserver/nginx_new/fastcgi_temp/1/96/0001214961” failed (28: No space left on device) while reading upstream, client: 61.241.120.188, server:www.13sai.com, request: “GET / HTTP/1.1”, upstream: “fastcgi://127.0.0.1:9000”, host: “www.13sai.com&quot;，后又反馈后台文件上传失败 排查去掉cdn能正常访问，挂载磁盘未满，系统盘满，乍一看是cdn和waf问题 处理系统盘100%，注意No space left on device，挪动大文件到挂载的磁盘，cdn页面也恢复正常 建议上传大文件，下载大文件尽量别放在系统盘","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/tags/web/"}]},{"title":"go源码之context","slug":"go源码之context","date":"2021-01-06T12:31:36.000Z","updated":"2021-01-06T15:40:31.330Z","comments":true,"path":"2021/01/06/311/","link":"","permalink":"http://github.13sai.com/2021/01/06/311/","excerpt":"","text":"定义说明 Package context defines the Context type, which carries deadlines, cancelation signals, and other request-scoped values across API boundaries and between processes.Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. When a Context is canceled, all Contexts derived from it are also canceled. 粗略翻译一下就是： context定义了上下文类型，它携带跨越API边界和进程之间的deadlines、取消信号和其他请求范围的值。对服务器的传入请求应该创建上下文，对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传播上下文，可以选择用使用WithCancel、WithDeadline、WithTimeout或WithValue创建的派生上下文替换它。当一个上下文被取消时，所有从它派生的上下文也被取消。 源码结构 名称 类型 说明 Context interface 定义了 Context 接口的四个方法Deadline、Done、Err、Value emptyCtx int 注意：emptyCtx永远不会取消，没有值，也没有截止日期。这里使用的是类型等价定义，emptyCtx等价于int类型。并且定义上面的四个方法和String方法。 Background func 返回new(emptyCtx) TODO func 返回new(emptyCtx) CancelFunc func CancelFunc告诉操作放弃其工作，不等待工作停止。多个goroutine可以同时调用CancelFunc。在第一个调用之后，对CancelFunc的后续调用将不执行任何操作。 WithCancel func WithCancel返回一个带有新的Done通道的parent副本。当返回的cancel函数被调用时，上下文的Done通道被关闭或者当父上下文的Done通道关闭时，无论哪个先发生。取消此上下文将释放与之相关的资源，代码也应该如此在此上下文中运行的操作一完成，就调用cancel。 newCancelCtx func 返回一个初始化的cancelCtx propagateCancel func propagateCancel在父元素被取消时取消子元素，这里有用到原子锁 parentCancelCtx func 找到第一个可取消的父节点 removeChild func 移除父节点的子节点 canceler interface 取消者，定义了cancel和Done两个方法 init func 初始化方法 cancelCtx struct 一个可以取消的 Context contextName func 返回上下文名称 WithDeadline func 创建一个有 deadline 的 context timerCtx struct timerCtx带有timeout 和deadline 。它将cancelCtx嵌入到实现Done和Err。它通过停止计时器来实现取消，然后委托给cancelCtx.cancel。 WithTimeout func 创建一个有 timeout 的 context WithValue func 创建一个存储 k-v 对的 context valueCtx struct 存储k-v，配合WithValue使用 stringify func 接口类型返回字符串 Context12345678910111213type Context interface &#123; // 获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消 Deadline() (deadline time.Time, ok bool) // 返回一个只读的chan，类型为struct&#123;&#125;，我们在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。 Done() &lt;-chan struct&#123;&#125; // 在 channel Done 关闭后，返回 context 取消原因 Err() error // 获取该Context上绑定的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是并发安全的 Value(key interface&#123;&#125;) interface&#123;&#125;&#125; canceler1234type canceler interface &#123; cancel(removeFromParent bool, err error) Done() &lt;-chan struct&#123;&#125;&#125; 实现了上面定义的两个方法的 Context，就表明该 Context 是可取消的。源码中有两个类型实现了 canceler 接口：*cancelCtx 和 *timerCtx。注意是加了 * 号的，是这两个结构体的指针实现了 canceler 接口。 接口设计成这个样子的原因： “取消”操作应该是建议性，而非强制性 “取消”操作应该可传递 emptyCtx123456789101112131415161718192021222324252627282930313233343536type emptyCtx intfunc (*emptyCtx) Deadline() (deadline time.Time, ok bool) &#123; return&#125;func (*emptyCtx) Done() &lt;-chan struct&#123;&#125; &#123; return nil&#125;func (*emptyCtx) Err() error &#123; return nil&#125;func (*emptyCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123; return nil&#125;func (e *emptyCtx) String() string &#123; switch e &#123; case background: return &quot;context.Background&quot; case todo: return &quot;context.TODO&quot; &#125; return &quot;unknown empty Context&quot;&#125;cancelCtxtype cancelCtx struct &#123; Context mu sync.Mutex // 互斥锁 done chan struct&#123;&#125; children map[canceler]struct&#123;&#125; err error &#125; 我们重点看一下这个方法 1234567891011121314151617181920212223242526272829303132func (c *cancelCtx) cancel(removeFromParent bool, err error) &#123; if err == nil &#123; panic(&quot;context: internal error: missing cancel error&quot;) &#125; c.mu.Lock() if c.err != nil &#123; c.mu.Unlock() return // 已经被其他协程取消 &#125; // 给 err 字段赋值 c.err = err // 关闭 channel，通知其他协程 if c.done == nil &#123; c.done = closedchan &#125; else &#123; close(c.done) &#125; // 遍历它的所有子节点 for child := range c.children &#123; // 递归地取消所有子节点 child.cancel(false, err) &#125; // 将子节点置空 c.children = nil c.mu.Unlock() if removeFromParent &#123; // 从父节点中移除自己 removeChild(c.Context, c) &#125;&#125; cancel()方法的功能就是关闭 channel：c.done；递归地取消它的所有子节点；从父节点从删除自己。达到的效果是通过关闭 channel，将取消信号传递给了它的所有子节点。 1234func WithCancel(parent Context) (ctx Context, cancel CancelFunc)func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)func WithValue(parent Context, key, val interface&#123;&#125;) Context 上面四个可以理解为Context的继承衍生。 对于我们日常使用来说，学会Context的继承的4个方法和Background、TODO基本就够了。 Context使用场景 超时请求 12345678910111213141516171819package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;time&quot;)func main() &#123; ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond) defer cancel() select &#123; case &lt;-time.After(1 * time.Second): fmt.Println(&quot;overslept&quot;) case &lt;-ctx.Done(): fmt.Println(ctx.Err()) // prints &quot;context deadline exceeded&quot; &#125;&#125; 共享数据 1234567891011121314151617181920212223package mainimport ( &quot;context&quot; &quot;fmt&quot;)func main() &#123; ctx := context.Background() process(ctx) ctx = context.WithValue(ctx, &quot;traceId&quot;, &quot;qcrao-2019&quot;) process(ctx)&#125;func process(ctx context.Context) &#123; traceId, ok := ctx.Value(&quot;traceId&quot;).(string) if ok &#123; fmt.Printf(&quot;process over. trace_id=%s\\n&quot;, traceId) &#125; else &#123; fmt.Printf(&quot;process over. no trace_id\\n&quot;) &#125;&#125; 这个在web开发中很实用，传递session、token等信息。 防止 goroutine 泄漏12345678910111213141516171819202122232425262728package mainimport ( &quot;time&quot; &quot;fmt&quot;)func gen() &lt;-chan int &#123; ch := make(chan int) go func() &#123; var n int for &#123; ch &lt;- n n++ time.Sleep(time.Second) &#125; &#125;() return ch&#125;func main() &#123; for n := range gen() &#123; fmt.Println(n) if n == 5 &#123; break &#125; &#125;&#125; 当 n = 5 的时候，直接 break 。但是 gen 的协程就会执行无限循环，永远不会停下来。发生了 goroutine 泄漏。 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( &quot;time&quot; &quot;fmt&quot; &quot;context&quot;)func gen(ctx context.Context) &lt;-chan int &#123; ch := make(chan int) go func() &#123; var n int for &#123; select &#123; case &lt;-ctx.Done(): return case ch &lt;- n: n++ time.Sleep(time.Second) &#125; &#125; &#125;() return ch&#125;func main() &#123; ctx, cancel := context.WithCancel(context.Background()) defer cancel() // 避免其他地方忘记 cancel，且重复调用不影响 for n := range gen(ctx) &#123; fmt.Println(n) if n == 5 &#123; cancel() break &#125; &#125;&#125; Context 使用原则最后记住几个主要的使用原则： 不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。 不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。 不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。 同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。 参考文章： 深度解密Go语言之context Go语言实战笔记（二十）| Go Context​","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"MongoDB的简单使用说明","slug":"MongoDB的简单使用说明","date":"2020-12-24T11:55:10.000Z","updated":"2020-12-24T12:17:35.419Z","comments":true,"path":"2020/12/24/301/","link":"","permalink":"http://github.13sai.com/2020/12/24/301/","excerpt":"","text":"安装12345// 下载，注意下载对应的系统版本，否则安装会报错wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.4.1.tgz// 解压即可，无需编译安装tar -zxvf mongodb-linux-x86_64-rhel70-4.4.1.tgzmv mongodb-linux-x86_64-rhel70-4.4.1 /usr/local/mongodb 启动服务新建mongodb.conf（版本可能不一样，略有不同） 12345dbpath = /data/mongodb/data #数据文件存放目录 logpath = /data/mongodb/log/mongodb.log #日志文件存放目录 port = 27000 #端口 fork = true #以守护程序的方式启用，即在后台运行 bind_ip=127.0.0.1 1234cd /usr/local/mongodb/// 启动服务bin/mongod -f ./mongodb.conf 新增用户设置密码 12345678910111213141516171819use admin;db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;666888&quot;,roles:[&quot;userAdminAnyDatabase&quot;]&#125;);use test;db.createUser(&#123; user: &quot;test&quot;, pwd: &quot;123456&quot;, roles: [&#123;role: &quot;readWrite&quot;,db: &quot;hotel&quot;&#125;]&#125;)db.createUser( &#123; user: &quot;admin&quot;, pwd: &quot;5176567&quot;, roles: [&#123;role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot;&#125;] &#125;) role的说明 12345678910Read：允许用户读取指定数据库readWrite：允许用户读写指定数据库dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profileuserAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。root：只在admin数据库中可用。超级账号，超级权限 建议出root和admin，各个数据库使用自己独立的账号密码。 auth尝试一下，如果返回1，表示auth验证成功 1db.auth(&#x27;root&#x27;, &#x27;666888&#x27;) 常用命令关闭mongo服务 12use admindb.shutdownServer() 清空当前数据库 12use xxxdb.dropDatabase() 集成到Laravel安装 composer require jenssegers/mongodb 3.6.x 低版本需要在config/app.php加入 1Jenssegers\\Mongodb\\MongodbServiceProvider::class, 配置database.php 1234567891011121314&#x27;mongodb&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;mongodb&#x27;, &#x27;host&#x27; =&gt; env(&#x27;MONGODB_HOST&#x27;, &#x27;127.0.0.1&#x27;), &#x27;port&#x27; =&gt; env(&#x27;MONGODB_PORT&#x27;, 27017), &#x27;database&#x27; =&gt; env(&#x27;MONGODB_DATABASE&#x27;, &#x27;test&#x27;), &#x27;username&#x27; =&gt; env(&#x27;MONGODB_USERNAME&#x27;, &#x27;test&#x27;), &#x27;password&#x27; =&gt; env(&#x27;MONGODB_PWD&#x27;, &#x27;&#x27;), &#x27;options&#x27; =&gt; [ // here you can pass more settings to the Mongo Driver Manager // see https://www.php.net/manual/en/mongodb-driver-manager.construct.php under &quot;Uri Options&quot; for a list of complete parameters that you can use &#x27;database&#x27; =&gt; env(&#x27;MONGODB_AUTHENTICATION_DATABASE&#x27;, &#x27;hotel&#x27;), // required with Mongo 3+ ], ], Model定义: 1234567891011121314151617181920&lt;?php/** * Author: 13sai * Date: 2020/12/22 * Time: 15:08 */namespace App\\Models;use Jenssegers\\Mongodb\\Eloquent\\Model;class Product extends Model&#123; protected $collection = &#x27;products&#x27;; protected $connection = &#x27;mongodb&#x27;; protected $guarded = [&#x27;id&#x27;];&#125; 使用: 1234567$users = User::distinct(&#x27;name&#x27;)-&gt;get();$users = User::whereIn(&#x27;age&#x27;, [16, 18, 20])-&gt;get();$total = Product::count();$price = Product::avg(&#x27;price&#x27;); Eloquent ORM常用的命令均支持，用起来毫无违和感，select略有不同，会把_id查询出来。 更多命令点击查看代码仓库 大致也就这些了，赶紧使用起来吧！！！","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://github.13sai.com/tags/mongodb/"}]},{"title":"go的并发模型","slug":"go的并发模型","date":"2020-11-21T13:26:35.000Z","updated":"2020-11-21T14:20:49.201Z","comments":true,"path":"2020/11/21/283/","link":"","permalink":"http://github.13sai.com/2020/11/21/283/","excerpt":"","text":"介绍并发模型，我们先来说一下并发和并行。 并发和并行并发和并行否是为了充分利用CPU多核计算资源提出来的概念。 并发指的是在同一个时间段内，多条指令在CPU上同时执行 并行值得是在同一时刻，多条指令在CPU上同时执行 并发程序其实并不要求CPU具备多核计算的能力，在同一时间段内，多个线程会被分配一定的执行时间片，在CPU上被快速轮换执行。 CSP并发模型Go语言中实现了两种并发模型，一种是依赖于共享内存实现的线程-锁并发模型，另一种则是CSP。 CSP倡导使用通信来共享内存，它有两个关键点： 并发实体，通常可以理解为执行线程，它们相互独立且可以并发执行 通道，并发实体之间通过通道发送消息，进行通信 CSP 类似于我们常用的同步队列，它关注的消息传输的方式（通道），并不关注消息实体。发送者和接收者可能并不知道对方是谁，耦合度是很低的。 虽然CSP的通道提供了极大的灵活性，但作为独立的对象，它可以被任意并发实体创建、读取、写入、使用，但使用时务必注意，当一个并发实体在读取一个永远没有数据放入的通道或者把数据放入一个永远不会被读取的通道，是会被阻塞，发生死锁的。 MPG线程模型Go语言不但有着独特的并发编程模型，还拥有强大的用于调度goroutine、对接系统级线程的调度器。 这个调度器是Go语言运行时系统的重要组成部分，它主要负责统筹调配Go并发编程模型中的三个主要元素，即：MPG。 模块 说明 Machine 一个Machine对应一个内核线程，相当于内核线程在Go进程中的映射 Processor 一个Processor表示执行Go程序所必须的上下文环境，可以理解为用户代码逻辑的处理器 Goroutine 是对Go语言中代码片段的封装，其实是一个轻量级的用户线程 M和P是一对一绑定的，但由于P的存在，G和M可以呈现出多对多的关系。当一个正在与某个M对接并运行着的G，需要因某个事件（比如等待I/O或锁的解除）而暂停运行的时候，调度器总会及时地发现，并把这个G与那个M分离开，以释放计算资源供那些等待运行的G使用。 可以看图，更直观： 有关P和M的个数问题 P的数量： 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。 M的数量: go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000。但是内核很难支持这么多的线程数，所以这个限制可以忽略。 runtime/debug中的SetMaxThreads函数，设置M的最大数量。 M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。 P和M何时会被创建： P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。 M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。 参考： 《Go语言高并发于为服务实战》 《Go语言核心36讲》 Golang调度器GMP原理与调度全分析","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"实例学go系列文章","slug":"实例学go系列","date":"2020-11-12T12:56:47.000Z","updated":"2021-04-13T07:26:55.847Z","comments":true,"path":"2020/11/12/281/","link":"","permalink":"http://github.13sai.com/2020/11/12/281/","excerpt":"","text":"自己写了一个学习go的文章，主要通过实例去实践学习go中常见的知识点。 点击直达github demo1-搭建httpserver https://zhuanlan.zhihu.com/p/288860232 demo2.1-利用gin搭建一个api框架 demo2.2-利用gin搭建一个api框架 demo3-防止漏打卡，利用gin和cron来做一个智能提醒 demo4-grpc demo5-没有对象，new一个，go demo6-go-kit是个啥，我想试一试 demo7-docker-compose整合go-kit和redis、mysql demo8-goroutine+channel demo9-限流器 demo10-MongoDB实现附近的人","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"MySQL间隙锁","slug":"MySQL间隙锁","date":"2020-10-27T12:01:18.000Z","updated":"2021-04-13T07:33:11.368Z","comments":true,"path":"2020/10/27/279/","link":"","permalink":"http://github.13sai.com/2020/10/27/279/","excerpt":"","text":"gap lock，也就是间隙锁，是innodb行级锁的一种，其他的还有record lock, Next-KeyLocks。 行锁（Record Lock）：锁直接加在索引记录上面。 间隙锁（Gap Lock）：锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。 Next-Key Lock：行锁与间隙锁组合起来用就叫做Next-Key Lock。 什么时候会取得gap lock这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。locking reads，UPDATE和DELETE时，除了对唯一索引的唯一搜索外都会获取gap锁或next-key锁。即锁住其扫描的范围。 我们来看看实例： 12345mysql&gt; CREATE TABLE `test` ( `id` int(11) DEFAULT NULL, `c1` int(11) DEFAULT NULL, KEY `test_idx1` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 插入3条记录， 1234mysql&gt; insert into test values(10,1);insert into test values(20,2);insert into test values(30,3); 在REPEATABLE READ下，更新一条记录不提交，然后看看能阻塞另外的会话哪些操作。 SESSION 1: SESSION 1中更新id=20的记录 123456mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; update test set c1=2 where id=20;Query OK, 1 row affected (0.04 sec)Rows matched: 1 Changed: 1 Warnings: 0 SESSION 2: 12345678910111213141516171819mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test values(9,4);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into test values(10,4);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; insert into test values(19,4);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; update test set c1=22 where id=20;ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; insert into test values(20,4);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; insert into test values(21,4);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; insert into test values(29,4);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; insert into test values(30,4);Query OK, 1 row affected (0.01 sec) SESSION 2中，执行插入操作，发现[10,30)范围不能插入数据。 SESSION 1: 123mysql&gt; begin;mysql&gt; update test set c1=4 where id=21;Query OK, 0 rows affected (0.00 sec) SESSION 2: 1234567mysql&gt; begin;mysql&gt; update test set c1=22 where id=20;Query OK, 1 row affected (0.01 sec)mysql&gt; insert into test values(20,4);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; update test set c1=4 where id=30;Query OK, 0 rows affected (0.00 sec) 这里呢，是去锁住了一条不存在的记录，他会锁住最近的[20,30)区间，然而与前一个例子不同的是，这里update（id = 20）是可以成功的，insert（id = 20）是不可以的。 如果SESSION 1的表扫描没有用到索引，那么gap或next-key锁住的范围是整个表，即任何值都不能插入。 作用间隙锁在InnoDB的唯一作用就是防止其它事务的插入操作，以此来达到防止幻读的发生，所以间隙锁不分什么共享锁与排它锁。 既然知道有gap lock和next key lock，我们开发中就要避免收到其影响，在并发场景下，使用锁尽量走索引，甚至是唯一索引。当然，也可以关闭间隙锁，可以把隔离级别降为读已提交Read Committed，或者开启参数innodb_locks_unsafe_for_binlog。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"layer关闭的问题","slug":"layer关闭的问题","date":"2020-10-21T11:54:05.000Z","updated":"2021-04-13T07:33:08.240Z","comments":true,"path":"2020/10/21/277/","link":"","permalink":"http://github.13sai.com/2020/10/21/277/","excerpt":"","text":"layer弹出层应该是我们比较常用的一个组件了。 遇到个问题，就是弹出层加上下一个上一个，其实按理是比较好实现，点击上一个下一个按钮，调用一下layer.close即可，然而无奈的是弹出的是一个iframe，都不在一个页面，如何调用layer.close。 那可怎么办呢？ 123456789var index=parent.layer.getFrameIndex(window.name);parent.layer.close(index);parent.layer.open(&#123; type: 2, title: &#x27;详情&#x27;, shadeClose: true, area: [&#x27;1000px&#x27;, &#x27;96%&#x27;], content: &quot;...&quot;&#125;); 如上，我们可以调用parent.layer.close，并通过parent.layer.getFrameIndex获取副页面的layer元素，这样就实现此需求了。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"golang的time使用","slug":"golang的time使用","date":"2020-09-10T12:44:26.000Z","updated":"2020-09-14T12:44:57.077Z","comments":true,"path":"2020/09/10/275/","link":"","permalink":"http://github.13sai.com/2020/09/10/275/","excerpt":"","text":"time应该是开发中比较常用的库了，常见方法说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package mainimport ( &quot;time&quot; &quot;fmt&quot;)func main() &#123; a := time.Now().Unix() fmt.Println(&quot;时间戳---&quot;, a) // 2006-01-02 15:04:05 记住这一刻 b := time.Now().Format(&quot;2006-01-02 15:04:05&quot;) fmt.Println(&quot;格式化时间&quot;, b) /** func (t Time) Add(d Duration) Time Duration如下 const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) */ c := time.Now().Add(time.Minute * 3) fmt.Println(&quot;3分钟后时间&quot;, c.Format(&quot;2006-01-02 15:04:05&quot;)) /** func (t Time) AddDate(years int, months int, days int) Time */ d := time.Now().AddDate(-1, 1,10) fmt.Println(&quot;时间&quot;, d.Format(&quot;2006-01-02 15:04:05&quot;)) // 返回年月日三个值 fmt.Println(time.Now().Date()) // 返回时分秒三个值 fmt.Println(time.Now().Clock()) fmt.Println(time.Now().Year(), time.Now().Month(), time.Now().Day()) fmt.Println(time.Now().Weekday(), time.Now().Hour()) fmt.Println(time.Now().YearDay()) fmt.Println(time.Since(d)) // tring返回采用如下格式字符串的格式化时间。 // &quot;2006-01-02 15:04:05.999999999 -0700 MST&quot; fmt.Println(time.Now().String()) time.AfterFunc(2*time.Second, func() &#123; fmt.Println(&quot;hello 2s&quot;) &#125;) loc, _ := time.LoadLocation(&quot;Asia/Shanghai&quot;) const longForm = &quot;Jan 2, 2006 at 3:04pm (MST)&quot; const shortForm = &quot;2006-Jan-02&quot; t, _ := time.ParseInLocation(longForm, &quot;Jul 9, 2012 at 5:02am (CEST)&quot;, loc) fmt.Println(t) /** func ParseInLocation(layout, value string, loc *Location) (Time, error) */ t, _ = time.ParseInLocation(shortForm, &quot;2022-Jul-09&quot;, loc) fmt.Println(t) /** func Parse(layout, value string) (Time, error) 解析一个格式化的时间字符串并返回它代表的时间 ParseInLocation类似Parse但有两个重要的不同之处。 第一，当缺少时区信息时，Parse将时间解释为UTC时间，而ParseInLocation将返回值的Location设置为loc； 第二，当时间字符串提供了时区偏移量信息时，Parse会尝试去匹配本地时区，而ParseInLocation会去匹配loc */ t, _ = time.Parse(longForm, &quot;Feb 3, 2023 at 7:54pm (PST)&quot;) fmt.Println(t) t, _ = time.Parse(shortForm, &quot;2020-Feb-03&quot;) fmt.Println(t) ch := make(chan int) timeout := time.After(time.Second * 2) timer := time.NewTimer(time.Second * 4) var i int go func() &#123; for &#123; // i++ select &#123; case &lt;- ch: fmt.Println(&quot;channel close&quot;) return case &lt;- timer.C: fmt.Println(&quot;4s的NewTimer定时任务&quot;) case &lt;- timeout: fmt.Println(&quot;4s定时输出&quot;) case &lt;- time.After(time.Second * 6): fmt.Println(&quot;6s到了&quot;) // default: // //Sleep 1秒，参数就是上面的Duration // time.Sleep(time.Second * 1) // fmt.Println(&quot;go 1s&quot;) &#125; &#125; &#125;() time.Sleep(time.Second * 15) fmt.Println(&quot;close----&quot;) close(ch) time.Sleep(time.Second * 2)&#125;","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"Laravel6配合MaatwebsiteExcel实现Excel导出","slug":"Laravel6配合MaatwebsiteExcel实现Excel导出","date":"2020-08-31T04:43:01.000Z","updated":"2021-04-13T07:32:16.186Z","comments":true,"path":"2020/08/31/272/","link":"","permalink":"http://github.13sai.com/2020/08/31/272/","excerpt":"","text":"相比导入，项目中导出场景更多，估摸着现在有十多个导出了，之前写了导入，这会才把导出补上。 安装之前说过，这里说一下配置，虽然已有默认配置，但还是有修改配置的场景，所以建议生成配置文件。 配置12//生成config/excel.phpphp artisan vendor:publish --provider=&quot;Maatwebsite\\Excel\\ExcelServiceProvider&quot; 配置只提一个，其他注释蛮细的， 123456789&#x27;csv&#x27; =&gt; [ &#x27;delimiter&#x27; =&gt; &#x27;,&#x27;, &#x27;enclosure&#x27; =&gt; &#x27;&quot;&#x27;, &#x27;line_ending&#x27; =&gt; PHP_EOL, // 导出csv中文乱码，把use_bom设为true即可 &#x27;use_bom&#x27; =&gt; true, &#x27;include_separator_line&#x27; =&gt; false, &#x27;excel_compatibility&#x27; =&gt; false,], 接下来，来完成一个导出的demo说明下常用的一些点。 DEMO1php artisan make:export MultiExport 生成文件如下： 12345678910111213141516&lt;?phpnamespace App\\Exports;use Maatwebsite\\Excel\\Concerns\\FromCollection;class MultiExport implements FromCollection&#123; /** * @return \\Illuminate\\Support\\Collection */ public function collection() &#123; // &#125;&#125; 自定义sheet，增加 WithTitle 自定义列名，增加WithHeadings 不想使用Collection，替换FromCollection使用FromArray 多个sheet，替换FromCollection使用WithMultipleSheets 经过改造： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?php/** * 多重导出 */namespace App\\Exports;use App\\Exports\\MultiExportA;use App\\Exports\\MultiExportB;use Maatwebsite\\Excel\\Concerns\\WithMultipleSheets;class MultiExport implements WithMultipleSheets&#123; private $date; public function __construct($date) &#123; $this-&gt;date = $date; &#125; public function sheets(): array &#123; $sheets = []; $sheets[] = new MultiExportA($this-&gt;date); $sheets[] = new MultiExportB($this-&gt;date); return $sheets; &#125;&#125;---// MultiExportA，MultiExportB类比即可&lt;?phpnamespace App\\Exports;use Maatwebsite\\Excel\\Concerns\\FromArray;use Maatwebsite\\Excel\\Concerns\\WithHeadings;use Maatwebsite\\Excel\\Concerns\\WithTitle;use App\\Models\\ExportA;class MultiExportA implements FromArray, WithTitle, WithHeadings&#123; private $date; public function __construct($date, $cityId) &#123; $this-&gt;date = $date; &#125; public function headings(): array &#123; return [ &#x27;ID&#x27;, &#x27;名称&#x27;, &#x27;价格&#x27;, &#x27;手机&#x27; ]; &#125; /** * @return array */ public function array() : array &#123; $data = ExportA::where(&#x27;date&#x27;, $this-&gt;date) -&gt;get() -&gt;toArray(); $ret = []; foreach ($data as $val) &#123; // 一段神奇的代码计算出了价格 $price = ...; $ret[] = [ &#x27;id&#x27; =&gt; $val[&#x27;id&#x27;].&quot;\\t&quot;, &#x27;name&#x27; =&gt; $val[&#x27;name&#x27;], &#x27;price&#x27; =&gt; $price, // 转换为文本，编码excel使用了科学计数法 &#x27;mobile&#x27; =&gt; $val[&#x27;mobile&#x27;].&quot;\\t&quot;, ]; &#125; return $ret; &#125; /** * @return string */ public function title(): string &#123; return &#x27;表格A&#x27;; &#125;&#125; 使用 123456// 保存$obj = new MultiExport($date);Excel::store($obj, &#x27;MultiExport&#x27;.$date.&#x27;.xlsx&#x27;);// 下载csvExcel::download($obj, &#x27;MultiExport&#x27;.$date.&#x27;.csv&#x27;, \\Maatwebsite\\Excel\\Excel::CSV, [&#x27;Content-Type&#x27; =&gt; &#x27;text/csv&#x27;]); 问题思考当数据量过大的时候，导出时很可能会内存溢出了。建议： 使用其他高性能的组件，或者使用原生代码流式输出到浏览器，也可以直接使用其他语言（比如go）编写 文件过大，Excel打开大数据量文件也很鸡肋，容易卡死甚至崩溃，尝试分文件导出，比如1w一个文件 部分导出过程可能有计算，可以提前计算好，导出时直接读表，使用LazyCollection， 使用 Lazy Collections 来提高 Laravel Excel 读取的性能（轻松支持百万数据）","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://github.13sai.com/tags/Laravel/"}]},{"title":"Laravel常用代码合集","slug":"Laravel常用代码合集","date":"2020-08-30T12:40:13.000Z","updated":"2021-04-13T07:32:23.694Z","comments":true,"path":"2020/08/30/270/","link":"","permalink":"http://github.13sai.com/2020/08/30/270/","excerpt":"","text":"用Laravel也有不短的时间了，也用过不少版本了，以下代码是在日常项目中收集，作为笔记，也分享出来，希望对你有点用处。注：版本没标注，若有不兼容的问题，微调即可。 验证不太习惯单独弄个Request验证类，比较习惯下面的写法： 1234567891011121314151617181920212223use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Validator; $inputData = $request-&gt;only([&#x27;name&#x27;, &#x27;address&#x27;, &#x27;mobile&#x27;, &#x27;draw_id&#x27;]); $messages = [ &#x27;required&#x27;=&gt;&#x27;:attribute为必填项&#x27;, &#x27;int&#x27;=&gt;&#x27;:attribute参数类型错误&#x27;, &#x27;max&#x27;=&gt;&#x27;:attribute长度不得超过 :size&#x27;, ]; $validator = Validator::make($inputData, [ &#x27;draw_id&#x27; =&gt; &#x27;required|int&#x27;, &#x27;name&#x27; =&gt; &#x27;required&#x27;, &#x27;mobile&#x27; =&gt; &#x27;required&#x27;, &#x27;address&#x27; =&gt; &#x27;required&#x27;, ], $messages,[ &#x27;name&#x27;=&gt;&#x27;收货人姓名&#x27;, &#x27;mobile&#x27;=&gt;&#x27;手机号码&#x27;, &#x27;address&#x27;=&gt;&#x27;收货地址&#x27;, ]); if ($validator-&gt;fails()) &#123; return self::response([], current($validator-&gt;errors()-&gt;all()), 2); &#125; ORM关联查询 一对一 123456789101112// Model定义，关联外键class User extends Model&#123; ... public function userIntegral() &#123; return $this-&gt;hasOne(&#x27;App\\Models\\UserIntegral&#x27;, &#x27;user_id&#x27;, &#x27;id&#x27;); &#125;&#125;// 使用with查询(new User())-&gt;with(&#x27;userIntegral&#x27;)-&gt;orderBy(&#x27;id&#x27;, &#x27;desc&#x27;)-&gt;paginate($limit); 一对多 1234567891011121314//Modelnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class Hotel extends Model&#123; public function orders() &#123; return $this-&gt;hasMany(&#x27;App\\Models\\Order&#x27;); &#125;&#125;//使用，比如查询某个Hotel下status=30的Order$hotel = Hotel::with([&#x27;orders&#x27; =&gt; function ($query) &#123; $query-&gt;where(&#x27;status&#x27;, 30); &#125;])-&gt;find(4); 统一异常处理这个可以参见之前的文章Laravel 统一错误处理为 JSON 队列失败队列入库 生成表生成failed_jobs表 12php artisan queue:failed-tablephp artisan migrate 单独处理 可以在Job中单独处理失败，Job失败也会写入上面生成的failed_jobs表 12345678910/*** 任务失败的处理过程** @param Exception $exception* [@return](https://learnku.com/users/31554) void*/public function failed(Exception $exception)&#123; // 处理&#125; 重试队列有时候代码有漏洞可能会有队列执行失败的状况，这时候我们就需要重试。 查看所有失败1php artisan queue:failed 重试所有失败1php artisan queue:retry all 重试单个失败1php artisan queue:retry 13 清空失败（重要的队列数据万不可这么操作）1php artisan queue:flush 另外，手动去操作确实不太方便，你可以设置个cron，定时重试所有失败，但务必要注意消息提醒，以免队列一直重试一直失败，往复运行，影响了正常的队列性能。 其他常用代码文件上传OSS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use Controller;use Illuminate\\Support\\Facades\\Storage;use Illuminate\\Support\\Facades\\Validator;use OSS\\OssClient;use OSS\\Core\\OssException;class UploadController extends Controller&#123; public function index(Request $request) &#123; $file = $request-&gt;file(&#x27;file&#x27;); if ($file-&gt;isValid()) &#123; $ext = $file-&gt;getClientOriginalExtension(); $realPath = $file-&gt;getRealPath(); $filepath = config(&#x27;app.env&#x27;).&#x27;/&#x27; . md5(uniqid(&#x27;&#x27;, true)); $result = $this-&gt;uploadOss($realPath, $filepath.&quot;.&quot;.$ext); if ($result[&#x27;code&#x27;]) &#123; return response([&#x27;code&#x27; =&gt; 2, &#x27;msg&#x27; =&gt; $result[&#x27;msg&#x27;]]); &#125; else &#123; return response([&#x27;code&#x27; =&gt; 0, &#x27;msg&#x27; =&gt; &#x27;上传成功&#x27;, &#x27;data&#x27; =&gt; [ &#x27;filepath&#x27; =&gt; $result[&#x27;data&#x27;][&#x27;url&#x27;], &#x27;data&#x27; =&gt; $request-&gt;all() ]]); &#125; &#125; &#125; /** * 上传oss * @param $filePath 当前路径 * @param $object 预定义文件名，可含文件夹 * [@return](https://learnku.com/users/31554) array */ public function uploadOss($filePath, $object) &#123; $accessKeyId = config(&#x27;filesystems.disks&#x27;)[config(&#x27;filesystems.default&#x27;)][&#x27;access_key&#x27;]; $accessKeySecret = config(&#x27;filesystems.disks&#x27;)[config(&#x27;filesystems.default&#x27;)][&#x27;secret_key&#x27;]; $endpoint = config(&#x27;filesystems.disks&#x27;)[config(&#x27;filesystems.default&#x27;)][&#x27;endpoint&#x27;]; $bucket= config(&#x27;filesystems.disks&#x27;)[config(&#x27;filesystems.default&#x27;)][&#x27;bucket&#x27;]; $url = config(&#x27;filesystems.disks&#x27;)[config(&#x27;filesystems.default&#x27;)][&#x27;host&#x27;]; try&#123; $ossClient = new OssClient($accessKeyId, $accessKeySecret, $endpoint); $ossClient-&gt;uploadFile($bucket, $object, $filePath); return [ &#x27;code&#x27; =&gt; 0, &#x27;data&#x27; =&gt; [ &#x27;url&#x27; =&gt; $url.&#x27;/&#x27;.$object ] ]; &#125; catch(OssException $e) &#123; return [ &#x27;code&#x27; =&gt; 1, &#x27;msg&#x27; =&gt; $e-&gt;getMessage() ]; &#125; &#125;&#125;// -------// 配置&#x27;oss&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;oss&#x27;, &#x27;root&#x27; =&gt; &#x27;&#x27;, &#x27;access_key&#x27; =&gt; env(&#x27;OSS_ACCESS_KEY&#x27;), &#x27;secret_key&#x27; =&gt; env(&#x27;OSS_SECRET_KEY&#x27;), &#x27;endpoint&#x27; =&gt; env(&#x27;OSS_ENDPOINT&#x27;), // 使用 ssl 这里设置如: https://oss-cn-beijing.aliyuncs.com &#x27;bucket&#x27; =&gt; env(&#x27;OSS_BUCKET&#x27;), &#x27;isCName&#x27; =&gt; env(&#x27;OSS_IS_CNAME&#x27;, false), // 如果 isCname 为 false，endpoint 应配置 oss 提供的域名如：`oss-cn-beijing.aliyuncs.com`，否则为自定义域名，，cname 或 cdn 请自行到阿里 oss 后台配置并绑定 bucket &#x27;host&#x27; =&gt; env(&#x27;OSS_HOST&#x27;, &#x27;&#x27;)], json输出1234567891011121314protected static $code = 0;protected static $msg = &#x27;ok&#x27;;public function response($data = [], $msg = &#x27;&#x27;, $code = 0)&#123; if (is_null($data)) &#123; $data = new \\stdClass(); &#125; return response()-&gt;json([ &#x27;code&#x27; =&gt; $code? $code : self::$code, &#x27;msg&#x27; =&gt; $msg? $msg : self::$msg, &#x27;data&#x27; =&gt; $data, ], 200);&#125; 进程锁 普通版本 12345678910111213141516// $autoDel字段删除，$ttl 过期时间，秒public function processLock($key, $autoDel = true, $ttl = 60)&#123; $key = &#x27;processLock:&#x27;.$key; // 不同版本或redis扩展，会有略微不同，自行调整下代码即可 if (Redis::Command(&#x27;set&#x27;, [$key, 1, &#x27;EX&#x27;, $ttl, &#x27;NX&#x27;])) &#123; if ($autoDel) &#123; register_shutdown_function(function () use ($key) &#123; Redis::del($key); &#125;); &#125; return true; &#125; return false;&#125; lua版本 123456789101112131415161718192021222324 public function getScript() &#123; return &lt;&lt;&lt;LUA local ret = redis.call(&quot;setnx&quot;, KEYS[1], ARGV[1]) if ret == 1 then return redis.call(&quot;expire&quot;, KEYS[1], ARGV[2]) else return 0 endLUA; &#125; public function processLock($key, $autoDel = true, $ttl = 60) &#123; if (Redis::eval($this-&gt;getScript(), 1, $key, 1, $ttl)) &#123; if ($autoDel) &#123; register_shutdown_function(function () use ($key) &#123; Redis::del($key); &#125;); &#125; &#125; return false; &#125; 说明：Redis::eval行第一个1表示key的数量，是为了区分KEYS和ARGV。 JWTLaravel 配合 jwt 使用 系统通知到钉钉我们可以使用队列，把一些重要的通知投到钉钉，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?phpnamespace App\\Jobs;use Illuminate\\Bus\\Queueable;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Foundation\\Bus\\Dispatchable;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Support\\Facades\\Log;use GuzzleHttp\\Client;class SystemNotify implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; private $title; private $content; private $type; private $robot; const DD_URL = &#x27;https://oapi.dingtalk.com&#x27;; /** * Create a new job instance. * * @param $title * @param string $content * @param string $type text, markdown * @param int $robot */ public function __construct($title, $content = &#x27;&#x27;, $type = &#x27;markdown&#x27;, $robot = 1) &#123; // 单独使用SystemNotify队列 $this-&gt;queue = &#x27;SystemNotify&#x27;; $this-&gt;title = $title; $this-&gt;content = $content; $this-&gt;type = $type; $this-&gt;robot = $robot; &#125; /** * Execute the job. * * @return void */ public function handle() &#123; // 可以不使用关键字，建议钉钉机器人使用IP段设置，更为安全 switch ($this-&gt;type)&#123; case &#x27;markdown&#x27;: $params = [ &#x27;msgtype&#x27; =&gt; $this-&gt;type, $this-&gt;type =&gt; [ &#x27;title&#x27; =&gt; $this-&gt;title.&#x27;[关键字]&#x27;, &#x27;text&#x27; =&gt; $this-&gt;content ] ]; break; default: $params = [ &#x27;msgtype&#x27; =&gt; $this-&gt;type, $this-&gt;type =&gt; [ &#x27;content&#x27; =&gt; $this-&gt;content.&#x27;[关键字]&#x27;, ] ]; break; &#125; $params = json_encode($params, JSON_UNESCAPED_UNICODE); $uri = self::URL_MAPPING[$this-&gt;robot]; $this-&gt;getClient()-&gt;request(&#x27;POST&#x27;, $uri, [ &#x27;headers&#x27; =&gt; [ &#x27;Content-Type&#x27; =&gt; &#x27;application/json;charset=utf-8&#x27; ], &#x27;body&#x27; =&gt; $params ]); &#125; // 对应不同的钉钉群通知，修改access_token参数即可 const URL_MAPPING = [ 1 =&gt; &#x27;/robot/send?access_token=@1&#x27;, 2 =&gt; &#x27;/robot/send?access_token=@2&#x27; ]; public function getClient() &#123; return new Client([ &#x27;base_uri&#x27; =&gt; &#x27;https://oapi.dingtalk.com&#x27;, &#x27;timeout&#x27; =&gt; 30, &#x27;verify&#x27; =&gt; false ]); &#125;&#125; 说明：通知内容可以自定义，添加智能机器人操作比较简单就不赘述了 钉钉文档 后台操作日志利用 Laravel 中间件给后台加个操作日志 ExcelLaravel6 配合 Maatwebsite\\Excel 实现 Excel 导入 Laravel6 配合 Maatwebsite\\Excel 实现 Excel 导出 陆续补充中…","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://github.13sai.com/tags/Laravel/"}]},{"title":"利用之前的gin-frame做一个钉钉智能提醒","slug":"利用之前的gin-frame做一个钉钉智能提醒","date":"2020-08-02T02:04:43.000Z","updated":"2021-04-13T07:22:11.754Z","comments":true,"path":"2020/08/02/263/","link":"","permalink":"http://github.13sai.com/2020/08/02/263/","excerpt":"","text":"最近项目有点多，更新文章的频率降低了，虽然都是公司自己的项目，但让我作着作着作出了外包的感觉～～～ 之前又出过gin-frame的文章，今天就利用gin-frame做一个钉钉智能提醒功能吧。 需求工作生活中，琐事太多，就容易忘，希望有这么个智能提醒功能，能利用钉钉准时推送提醒我！比如： 每周五18:00提醒我发周报 每周三14:00提醒我发车买奶茶 10分钟提醒我去会议室开会 2020-08-20提醒我纪念日到了 …诸如此类 钉钉接入钉钉有机器人功能，之前已有应用到项目告警提醒等功能中，效果不错，另外Outgoing机制也已经开放使用，我们就可以利用它进行对话了。 点击直达钉钉相关文档 按照文档在群里新建机器人即可。我开启的是webhook自定义机器人，outgoing提送地址就是项目接收信息地址，比如：http://cron.13sai.com/dingdingPost。 解析内容钉钉文档的outgoing说明不全，或者是藏在哪里我没找到，可以使用@机器人接收信息打印看一下。 123456789101112131415161718192021222324&#123; &quot;conversationId&quot;:&quot;xxx&quot;, &quot;atUsers&quot;:[ &#123; &quot;dingtalkId&quot;:&quot;xxx&quot; &#125;], &quot;chatbotUserId&quot;:&quot;xxx&quot;, &quot;msgId&quot;:&quot;xxx&quot;, &quot;senderNick&quot;:&quot;sai0556&quot;, &quot;isAdmin&quot;:false, &quot;sessionWebhookExpiredTime&quot;:1594978626787, &quot;createAt&quot;:1594973226742, &quot;conversationType&quot;:&quot;2&quot;, &quot;senderId&quot;:&quot;xxx&quot;, &quot;conversationTitle&quot;:&quot;智能备忘录&quot;, &quot;isInAtList&quot;:true, &quot;sessionWebhook&quot;:&quot;xxx&quot;, &quot;text&quot;:&#123; &quot;content&quot;:&quot; hello gin-frame&quot; &#125;, &quot;msgtype&quot;:&quot;text&quot;&#125;//关注senderId发送人id，text发送内容，senderNick发送人昵称即可 定义一个struct，接收消息 1234567891011121314151617181920type DingDingMsgContent struct &#123; SenderNick string `json:&quot;senderNick&quot;` SenderId string `json:&quot;senderId&quot;` Text struct &#123; Content string `json:&quot;content&quot;` &#125; `json:&quot;text&quot;`&#125;func DingDing(c *gin.Context) &#123; data, _ := ioutil.ReadAll(c.Request.Body) form := DingDingMsgContent&#123;&#125; err := json.Unmarshal([]byte(data), &amp;form) // err := c.ShouldBindJSON(&amp;form) if err != nil &#123; fmt.Println(err) return &#125; ....&#125; 发送钉钉消息12345678910111213141516171819202122232425262728293031323334353637383940func SendDD(msg string) &#123; // 打印出来看看是个啥 fmt.Println(msg) tips := make(map[string]interface&#123;&#125;) content := make(map[string]interface&#123;&#125;) tips[&quot;msgtype&quot;] = &quot;text&quot; // @ 是用来提醒群里对应的人 arr := strings.Split(msg, &quot;@&quot;) // [提醒]是机器人关键字，个人建议设置机器人限制ip或使用token，比较靠谱 content[&quot;content&quot;] = fmt.Sprintf(&quot;%s[提醒]&quot;, arr[0]) tips[&quot;text&quot;] = content if len(arr) &gt; 1 &#123; mobile := make([]string, 0) at := make(map[string]interface&#123;&#125;) mobile = append(mobile, arr[1]) at[&quot;atMobiles&quot;] = mobile tips[&quot;at&quot;] = at &#125; bytesData, err := json.Marshal(tips) if err != nil &#123; fmt.Println(err.Error() ) return &#125; reader := bytes.NewReader(bytesData) url := viper.GetString(&quot;dingding_url&quot;) request, err := http.NewRequest(&quot;POST&quot;, url, reader) if err != nil &#123; return &#125; request.Header.Set(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;) client := http.Client&#123;&#125; _, err = client.Do(request) if err != nil &#123; fmt.Println(err.Error()) return &#125; // 返回可自行处理，可重试，偷个懒不处理了&#125; 关键字12345678910111213141516171819202122232425262728293031323334353637383940414243// util/common.go// 就列了一些常见的，可自行扩展func UpdateKeywords() &#123; redis := model.RedisClient.Pipeline() key := KeyWords redis.HSet(model.Ctx, key, &quot;分钟后&quot;, &quot;1|60&quot;) redis.HSet(model.Ctx, key, &quot;时后&quot;, &quot;1|3600&quot;) redis.HSet(model.Ctx, key, &quot;天后&quot;, &quot;1|86400&quot;) redis.HSet(model.Ctx, key, &quot;每天&quot;, &quot;-1|1&quot;) redis.HSet(model.Ctx, key, &quot;每周一&quot;, &quot;2|0&quot;) redis.HSet(model.Ctx, key, &quot;每周二&quot;, &quot;2|1&quot;) redis.HSet(model.Ctx, key, &quot;每周三&quot;, &quot;2|2&quot;) redis.HSet(model.Ctx, key, &quot;每周四&quot;, &quot;2|3&quot;) redis.HSet(model.Ctx, key, &quot;每周五&quot;, &quot;2|4&quot;) redis.HSet(model.Ctx, key, &quot;每周六&quot;, &quot;2|5&quot;) redis.HSet(model.Ctx, key, &quot;每周日&quot;, &quot;2|6&quot;) redis.HSet(model.Ctx, key, &quot;周一&quot;, &quot;3|0&quot;) redis.HSet(model.Ctx, key, &quot;周二&quot;, &quot;3|1&quot;) redis.HSet(model.Ctx, key, &quot;周三&quot;, &quot;3|2&quot;) redis.HSet(model.Ctx, key, &quot;周四&quot;, &quot;3|3&quot;) redis.HSet(model.Ctx, key, &quot;周五&quot;, &quot;3|4&quot;) redis.HSet(model.Ctx, key, &quot;周六&quot;, &quot;3|5&quot;) redis.HSet(model.Ctx, key, &quot;周日&quot;, &quot;3|6&quot;) redis.HSet(model.Ctx, key, &quot;下周一&quot;, &quot;3|7&quot;) redis.HSet(model.Ctx, key, &quot;下周二&quot;, &quot;3|8&quot;) redis.HSet(model.Ctx, key, &quot;下周三&quot;, &quot;3|9&quot;) redis.HSet(model.Ctx, key, &quot;下周四&quot;, &quot;3|10&quot;) redis.HSet(model.Ctx, key, &quot;下周五&quot;, &quot;3|11&quot;) redis.HSet(model.Ctx, key, &quot;下周六&quot;, &quot;3|12&quot;) redis.HSet(model.Ctx, key, &quot;下周日&quot;, &quot;3|13&quot;) redis.HSet(model.Ctx, key, &quot;下星期一&quot;, &quot;3|7&quot;) redis.HSet(model.Ctx, key, &quot;下星期二&quot;, &quot;3|8&quot;) redis.HSet(model.Ctx, key, &quot;下星期三&quot;, &quot;3|9&quot;) redis.HSet(model.Ctx, key, &quot;下星期四&quot;, &quot;3|10&quot;) redis.HSet(model.Ctx, key, &quot;下星期五&quot;, &quot;3|11&quot;) redis.HSet(model.Ctx, key, &quot;下星期六&quot;, &quot;3|12&quot;) redis.HSet(model.Ctx, key, &quot;下星期日&quot;, &quot;3|13&quot;) redis.HSet(model.Ctx, key, &quot;今天&quot;, &quot;4|0&quot;) redis.HSet(model.Ctx, key, &quot;明天&quot;, &quot;4|1&quot;) redis.HSet(model.Ctx, key, &quot;后天&quot;, &quot;4|2&quot;) redis.HSet(model.Ctx, key, &quot;取消&quot;, &quot;0|0&quot;) redis.Exec(model.Ctx)&#125; 解析内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214func parseContent(form DingDingMsgContent) (err error) &#123; str := form.Text.Content redis := model.RedisClient // 要先绑定哟，不然无法@到对应的人 index := strings.Index(str, &quot;手机&quot;) if index &gt; -1 &#123; reg := regexp.MustCompile(&quot;1[0-9]&#123;10&#125;&quot;) res := reg.FindAllString(str, 1) if len(res) &lt; 1 || res[0] == &quot;&quot; &#123; err = errors.New(&quot;手机格式不正确&quot;) return &#125; redis.HSet(model.Ctx, util.KeyDingDingID, form.SenderId, res[0]) err = errors.New(&quot;绑定成功&quot;) return &#125; hExist := redis.HExists(model.Ctx, util.KeyDingDingID, form.SenderId) if !hExist.Val() &#123; err = errors.New(&quot;绑定手机号才能精确提醒哦，发送--手机 13456567878--@我即可&quot;) return &#125; index = strings.Index(util.StrSub(str, 0, 4), &quot;取消&quot;) if index &gt; -1 &#123; reg := regexp.MustCompile(&quot;[a-z0-9]&#123;32&#125;&quot;) res := reg.FindAllString(str, 1) if len(res) &lt; 1 &#123; err = errors.New(&quot;任务id不正确&quot;) return &#125; if er := util.CancelQueue(res[0], form.SenderId); er != nil &#123; err = er return &#125; err = errors.New(&quot;取消成功&quot;) return &#125; return tips(form) &#125;// 提醒内容func tips(form DingDingMsgContent) (err error) &#123; rd := model.RedisClient str := form.Text.Content mobile := rd.HGet(model.Ctx, util.KeyDingDingID, form.SenderId).Val() key := util.KeyWords list, _ := rd.HGetAll(model.Ctx, key).Result() now := time.Now().Unix() tipsType := 1 k := &quot;&quot; v := &quot;&quot; fmt.Println(&quot;str&quot;, str) index := 0 for key, value := range list &#123; index = util.UnicodeIndex(str, key) if index &gt; -1 &amp;&amp; util.StrLen(key) &gt; util.StrLen(k) &#123; fmt.Println(&quot;index&quot;, index, str, key, value) k = key v = value &#125; &#125; msg := &quot;&quot; var score int64 if k != &quot;&quot; &#123; kLen := util.StrLen(k) msg = util.StrSub(str, index+kLen) val := strings.Split(v, &quot;|&quot;) unit := val[1] units,_ := strconv.Atoi(unit) switch val[0] &#123; // 多少时间后 case &quot;1&quot;: reg := regexp.MustCompile(&quot;[0-9]&#123;1,2&#125;&quot;) res := reg.FindAllString(str, 1) minute, _ := strconv.Atoi(res[0]) score = now + int64(units*minute) // 每周 case &quot;2&quot;: reg := regexp.MustCompile(&quot;[0-9]&#123;1,2&#125;&quot;) res := reg.FindAllString(util.StrSub(msg, 0, 7), -1) hour := 9 minute := 0 if len(res) &gt; 0 &#123; hour, _ = strconv.Atoi(res[0]) &#125; if len(res) &gt; 1 &#123; minute, _ = strconv.Atoi(res[1]) &#125; now = util.GetWeekTS(int64(units)) score = now + int64(60*minute + 3600*hour) tipsType = 2 // 下周 case &quot;3&quot;: reg := regexp.MustCompile(&quot;[0-9]&#123;1,2&#125;&quot;) res := reg.FindAllString(util.StrSub(msg, 0, 7), -1) hour := 9 minute := 0 if len(res) &gt; 0 &#123; hour, _ = strconv.Atoi(res[0]) &#125; if len(res) &gt; 1 &#123; minute, _ = strconv.Atoi(res[1]) &#125; now = util.TodayTS() score = now + int64(60*minute + 3600*hour + units*86400) case &quot;4&quot;: reg := regexp.MustCompile(&quot;[0-9]&#123;1,2&#125;&quot;) res := reg.FindAllString(util.StrSub(msg, 0, 7), -1) hour := 9 minute := 0 if len(res) &gt; 0 &#123; hour, _ = strconv.Atoi(res[0]) &#125; if len(res) &gt; 1 &#123; minute, _ = strconv.Atoi(res[1]) &#125; now = util.GetWeekTS(int64(units)) score = now + int64(60*minute + 3600*hour) case &quot;-1&quot;: reg := regexp.MustCompile(&quot;[0-9]&#123;1,10&#125;&quot;) res := reg.FindAllString(util.StrSub(msg, 0, 7), -1) fmt.Println(&quot;res&quot;, res) hour := 9 minute := 0 if len(res) &gt; 0 &#123; hour, _ = strconv.Atoi(res[0]) &#125; if len(res) &gt; 1 &#123; minute, _ = strconv.Atoi(res[1]) &#125; now = util.TodayTS() + 86400 score = now + int64(60*minute + 3600*hour) fmt.Println(now, score, minute, hour) tipsType = 3 default: &#125; &#125; else &#123; reg := regexp.MustCompile(&quot;(([0-9]&#123;4&#125;)[-|/|年])?([0-9]&#123;1,2&#125;)[-|/|月]([0-9]&#123;1,2&#125;)日?&quot;) pi := reg.FindAllStringSubmatch(str, -1) if (len(pi) &gt; 0 ) &#123; date := pi[0] if date[2] == &quot;&quot; &#123; date[2] = &quot;2020&quot; &#125; location, _ := time.LoadLocation(&quot;Asia/Shanghai&quot;) tm2, _ := time.ParseInLocation(&quot;2006/01/02&quot;, fmt.Sprintf(&quot;%s/%s/%s&quot;, date[2], date[3], date[4]), location) score = util.GetZeroTime(tm2).Unix() msg = reg.ReplaceAllString(str, &quot;&quot;) fmt.Println(msg) &#125; else &#123; msg = str score = util.TodayTS() &#125; reg = regexp.MustCompile(&quot;[0-9]&#123;1,10&#125;&quot;) res := reg.FindAllString(util.StrSub(msg, 0, 7), -1) fmt.Println(&quot;res&quot;, res) hour := 9 minute := 0 if len(res) &gt;= 1 &#123; hour, _ = strconv.Atoi(res[0]) fmt.Println(&quot;hour&quot;, hour, minute) &#125; if len(res) &gt; 1 &#123; minute, _ = strconv.Atoi(res[1]) &#125; score += int64(60*minute + 3600*hour) &#125; if msg == &quot;&quot; &#123; err = errors.New(&quot;你说啥&quot;) return &#125; index = util.UnicodeIndex(msg, &quot;提醒我&quot;) if index &lt; 0 &#123; err = errors.New(&quot;大哥，要我提醒你干啥呢？请发送--下周一13点提醒我写作业&quot;) return &#125; msg = util.StrSub(msg, index+3) fmt.Println(msg, mobile) msg = util.StrCombine(msg, &quot;@&quot;, mobile) fmt.Println(score, msg, tipsType, err) if err != nil &#123; util.SendDD(err.Error()) return &#125; member := util.StrCombine(strconv.Itoa(tipsType), msg) rd.ZAdd(model.Ctx, util.KeyCrontab, &amp;redis.Z&#123; Score: float64(score), Member: member, &#125;) uniqueKey := util.Md5(member) rd.HSet(model.Ctx, util.StrCombine(util.KeyUserCron, form.SenderId), uniqueKey, member) util.SendDD(fmt.Sprintf(&quot;设置成功(取消请回复：取消任务%s)--%s提醒您%s&quot;, uniqueKey, time.Unix(score, 0).Format(&quot;2006/01/02 15:04:05&quot;), msg)) return &#125; 定时发送上面的代码能看出来，使用的是redis的有序集合，我们每分钟去取过期的集合内容就ok了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465func Cron() &#123; c := cron.New() spec := &quot;*/10 * * * * ?&quot; c.AddJob(spec, Queue&#123;&#125;) c.Start()&#125;type Queue struct &#123;&#125;func (q Queue) Run() &#123; now := time.Now().Unix() rd := model.RedisClient op := &amp;redis.ZRangeBy&#123; Min: &quot;0&quot;, Max: strconv.FormatInt(now, 10), &#125; ret, err := rd.ZRangeByScoreWithScores(model.Ctx, KeyCrontab, op).Result() if err != nil &#123; fmt.Printf(&quot;zrangebyscore failed, err:%v\\n&quot;, err) return &#125; for _, z := range ret &#123; fmt.Println(z.Member.(string), z.Score) QueueDo(z.Member.(string), z.Score) &#125;&#125;func QueueDo(msg string, score float64) &#123; msgType := msg[0:1] SendDD(msg[1:]) rd := model.RedisClient rd.ZRem(model.Ctx, KeyCrontab, msg) switch msgType &#123; case &quot;2&quot;: rd.ZAdd(model.Ctx, KeyCrontab, &amp;redis.Z&#123; Score: score + 7*86400, Member: msg, &#125;) case &quot;3&quot;: rd.ZAdd(model.Ctx, KeyCrontab, &amp;redis.Z&#123; Score: score + 86400, Member: msg, &#125;) default: rd.ZRem(model.Ctx, KeyCrontab, msg) &#125;&#125;func CancelQueue(uniqueKey string, SenderId string) (err error) &#123; rd := model.RedisClient member := rd.HGet(model.Ctx, StrCombine(KeyUserCron, SenderId), uniqueKey).Val() if member == &quot;&quot; &#123; fmt.Println(StrCombine(KeyUserCron, SenderId), uniqueKey) err = errors.New(&quot;没有此任务&quot;) return &#125; fmt.Println(member, &quot;member&quot;) rd.ZRem(model.Ctx, KeyCrontab, member) rd.HDel(model.Ctx, StrCombine(KeyUserCron, SenderId), uniqueKey) err = errors.New(&quot;取消成功&quot;) return &#125; 启动任务： 12util.UpdateKeywords()util.Cron() 代码中有用到很多函数，不理解的可下载代码查看。 直达gitee仓库","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"gin","slug":"gin","permalink":"http://github.13sai.com/tags/gin/"}]},{"title":"最近使用gin的总结","slug":"最近使用gin的总结","date":"2020-07-20T03:19:09.000Z","updated":"2021-04-13T07:29:12.075Z","comments":true,"path":"2020/07/20/261/","link":"","permalink":"http://github.13sai.com/2020/07/20/261/","excerpt":"","text":"最近有新项目是利用gin开发的，过程中遇到一些问题，总结一下，作为笔记，也希望能帮助到你。 跨域问题中间件： 1234567891011121314151617181920func Cors() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; // 这里可以用*，也可以用你指定的域名 c.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) // 允许头部参数 c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,AccessToken,X-CSRF-Token, Authorization, Token&quot;) // 允许的方法 c.Header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS&quot;) c.Header(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type&quot;) c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;) method := c.Request.Method //放行OPTIONS方法 if method == &quot;OPTIONS&quot; &#123; c.AbortWithStatus(http.StatusOK) &#125; // 处理请求 c.Next() &#125;&#125; 然后在路由中加入： 12// g : *gin.Engineg.Use(Cors()) 当然也可以在Nginx层配置，可自行查阅，我就不展开了。 使用多个中间件123// g : *gin.Engineg.Use(Cors())g.Use(Session()) 中间件终止请求12345678910111213func Auth() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; uid := c.MustGet(&quot;uid&quot;).(int) if uid == 0 &#123; c.Abort() controller.SendResponse(c, 401, &quot;未登录&quot;, nil) // return可忽略 return &#125; else &#123; c.Next() &#125; &#125;&#125; session使用123456789101112131415161718192021package utilimport ( &quot;github.com/gin-gonic/gin&quot; &quot;github.com/gin-contrib/sessions&quot; &quot;github.com/gin-contrib/sessions/redis&quot; redisGo &quot;github.com/gomodule/redigo/redis&quot; &quot;github.com/spf13/viper&quot;)// 启动sessionfunc SessionStart(g *gin.Engine, RedisClient *redisGo.Pool, key ...[]byte) &#123; store, _ := redis.NewStoreWithPool(RedisClient, []byte(viper.GetString(&quot;name&quot;))) redis.SetKeyPrefix(store, &quot;session_&quot;) g.Use(sessions.Sessions(viper.GetString(&quot;name&quot;), store))&#125;// 使用sessionsession := sessions.Default(c)session.Set(&quot;uid&quot;, uid)uid := session.Get(&quot;uid&quot;) 上传oss1234567891011121314151617181920212223242526272829import ( &quot;os&quot; &quot;github.com/aliyun/aliyun-oss-go-sdk/oss&quot; &quot;github.com/spf13/viper&quot;)func upload(localPath string, iType int, Name string) (path string) &#123; client, err := oss.New(viper.GetString(&quot;oss.end_point&quot;), viper.GetString(&quot;oss.access_key_id&quot;), viper.GetString(&quot;oss.access_key_secret&quot;)) if err != nil &#123; return &#125; // 获取存储空间。 bucket, err := client.Bucket(viper.GetString(&quot;oss.bucket&quot;)) if err != nil &#123; return &#125; // 上传本地文件。 ossPath := fmt.Sprintf(&quot;%s/%s&quot;, &quot;qiling&quot;, Name) err = bucket.PutObjectFromFile(ossPath, localPath) if err != nil &#123; return &#125; path = fmt.Sprintf(&quot;%s/%s&quot;, viper.GetString(&quot;oss.hosts&quot;), ossPath) os.Remove(localPath) return&#125; 几个实用的方法123456789101112131415161718192021222324252627282930import ( &quot;fmt&quot; &quot;crypto/md5&quot; &quot;bytes&quot; &quot;regexp&quot;)// md5func Md5(str string) string &#123; return fmt.Sprintf(&quot;%x&quot;, md5.Sum([]byte(str)));&#125;// 判断是不是真实手机号码func IsMobile(mobile string) bool &#123; result, _ := regexp.MatchString(`^(1\\d&#123;10&#125;)$`, mobile) if result &#123; return true &#125; else &#123; return false &#125;&#125;// 合并字符串func StrCombine(str ...string) string &#123; var bt bytes.Buffer for _, arg := range str &#123; bt.WriteString(arg) &#125; //获得拼接后的字符串 return bt.String()&#125; 大概就这些了，后面有可以分析的再补充。","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"gin","slug":"gin","permalink":"http://github.13sai.com/tags/gin/"}]},{"title":"使用vue-element-admin的一些总结","slug":"使用vue-element-admin的一些总结","date":"2020-07-14T03:28:52.000Z","updated":"2021-04-13T07:27:19.181Z","comments":true,"path":"2020/07/14/262/","link":"","permalink":"http://github.13sai.com/2020/07/14/262/","excerpt":"","text":"最近开发的项目后台基于vue-element-admin开发，在逐步完善的过程中遇到了一些问题，特此总结，希望能对你有所帮助。 先上链接，真的很好用，安利一下，链接如下： A magical vue admin 基本上常用的不常用的功能都有，就不多说了，有兴趣链接直达，正式开始正文。 修改菜单图标为elementUI图标官方的svg图标确实比较少，添加我也觉得繁琐，另外，既然集成了elementUI，直接用elementUI图标就好了。 改： 123456789修改菜单icon为elementUI图标：// 文件地址：src\\layout\\components\\Sidebar\\Item.vue// if (icon) &#123;// vnodes.push(&lt;svg-icon icon-class=&#123;icon&#125;/&gt;)// &#125;if (icon) &#123; vnodes.push(&lt;i class=&#123;icon&#125;&gt;&lt;/i&gt;)&#125; 关闭eslint官网已有答案 12// vue.config.jslintOnSave: false but，如果你使用的是git管理代码，会发现commit的时候依旧会触发eslint。 1234567// package.json &quot;lint-staged&quot;: &#123; &quot;src/**/*.&#123;js,vue&#125;&quot;: [ &quot;eslint --fix&quot;, // 删除这一行 &quot;git add&quot; ] &#125;, 增加本地环境变量12345// package.json &quot;scripts&quot;: &#123; &quot;local&quot;: &quot;vue-cli-service serve --mode local&quot;, ... &#125;, 复制.env.production为.env.local，自定义配置后，运行： 1yarn run local 缓存页面想缓存的页面： 123&lt;script&gt;export default &#123; name: &quot;cacheIndex&quot;, 加入cachedViews 1234567// src\\store\\modules\\tagsView.jsconst state = &#123; visitedViews: [], cachedViews: [ &#x27;cacheIndex&#x27; ]&#125; 最近开发的项目后台基于vue-element-admin开发，在逐步完善的过程中遇到了一些问题，特此总结，希望能对你有所帮助。 先上链接，真的很好用，安利一下，链接如下： A magical vue admin 基本上常用的不常用的功能都有，就不多说了，有兴趣链接直达，正式开始正文。 修改菜单图标为elementUI图标官方的svg图标确实比较少，添加我也觉得繁琐，另外，既然集成了elementUI，直接用elementUI图标就好了。 改： 123456789修改菜单icon为elementUI图标：// 文件地址：src\\layout\\components\\Sidebar\\Item.vue// if (icon) &#123;// vnodes.push(&lt;svg-icon icon-class=&#123;icon&#125;/&gt;)// &#125;if (icon) &#123; vnodes.push(&lt;i class=&#123;icon&#125;&gt;&lt;/i&gt;)&#125; 关闭eslint官网已有答案 12// vue.config.jslintOnSave: false but，如果你使用的是git管理代码，会发现commit的时候依旧会触发eslint。 1234567// package.json &quot;lint-staged&quot;: &#123; &quot;src/**/*.&#123;js,vue&#125;&quot;: [ &quot;eslint --fix&quot;, // 删除这一行 &quot;git add&quot; ] &#125;, 增加本地环境变量12345// package.json &quot;scripts&quot;: &#123; &quot;local&quot;: &quot;vue-cli-service serve --mode local&quot;, ... &#125;, 复制.env.production为.env.local，自定义配置后，运行： 1yarn run local 缓存页面想缓存的页面： 123&lt;script&gt;export default &#123; name: &quot;cacheIndex&quot;, 加入cachedViews 1234567// src\\store\\modules\\tagsView.jsconst state = &#123; visitedViews: [], cachedViews: [ &#x27;cacheIndex&#x27; ]&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://github.13sai.com/categories/vue/"}],"tags":[{"name":"ElementUI","slug":"ElementUI","permalink":"http://github.13sai.com/tags/ElementUI/"}]},{"title":"结合gin+gorm+go-Redis写一个基础 API（下篇）","slug":"结合 gin+gorm+go-Redis 写一个基础API（下篇）","date":"2020-06-15T13:49:28.000Z","updated":"2021-04-13T07:21:43.475Z","comments":true,"path":"2020/06/15/256/","link":"","permalink":"http://github.13sai.com/2020/06/15/256/","excerpt":"","text":"前两篇我们已经完成了gin+gorm部分，今天我们来补充go-Redis，并进行测试。 整合go-Redis我们把Redis相关也放在model下面，使用的是常见的go-redis： 123456789101112131415161718192021222324// redis.gopackage modelimport ( &quot;fmt&quot; &quot;github.com/spf13/viper&quot; &quot;github.com/go-redis/redis&quot;)var RedisClient *redis.Clientfunc RedisInit() &#123; RedisClient = redis.NewClient(&amp;redis.Options&#123; Addr: fmt.Sprintf(&quot;%s:%s&quot;, viper.GetString(&quot;redis.host&quot;), viper.GetString(&quot;redis.port&quot;)), Password: viper.GetString(&quot;redis.auth&quot;), DB: 0, &#125;) _, err := RedisClient.Ping().Result() if err != nil &#123; panic(&quot;redis ping error&quot;) &#125;&#125; 然后在连接Mysql的前面加入初始化redis连接的操作即可。 12// redis 初始化model.RedisInit() 你可以做一些简单操作，或者在redis.go做一些常用方法的封装，比较简单，就不赘述了，更多go-redis操作可见： go-redis github太慢就看这个 测试新建测试目录test，建立三个文件： 12345678910111213141516171819202122232425262728// index.gopackage testimport ( &quot;net/http&quot; &quot;io/ioutil&quot;)func Sum(a int, b int) int &#123; return a+b&#125;func HttpIndex() []byte &#123; resp, err := http.Get(&quot;http://127.0.0.1:8080/&quot;) if err != nil &amp;&amp; resp.StatusCode != 200 &#123; panic(err) &#125; //关闭连接 defer resp.Body.Close() //读取报文中所有内容 body, err := ioutil.ReadAll(resp.Body) if err != nil &#123; panic(err) &#125; //输出内容 return body&#125; 1234567891011121314151617181920212223242526272829303132// index_test.gopackage testimport ( &quot;testing&quot; &quot;encoding/json&quot; &quot;local.com/sai0556/gin-frame/controller&quot;)func TestSum(t *testing.T) &#123; ret := Sum(2, 7) if ret != 9 &#123; t.Error(&quot;Expected 9 ~wow~&quot;) &#125;&#125;func TestHttpIndex(t *testing.T) &#123; data := HttpIndex() target := controller.Response&#123;&#125; // json转换 if err := json.Unmarshal(data, &amp;target); err != nil &#123; t.Error(target) &#125; ret := controller.Response&#123;0, &quot;success&quot;, nil&#125; if target != ret &#123; t.Error(&quot;json error&quot;) &#125;&#125; 1234567891011121314151617181920// index_bench_test.gopackage testimport ( &quot;testing&quot;)func BenchmarkSum(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; Sum(2, 7) &#125;&#125;func BenchmarkHttpIndex(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; HttpIndex() &#125;&#125; 私以为go的测试相比其他语言还是比较简洁的，这里需要注意几点： 测试文件以_test结尾 基础测试方法名要以TEST开头 运行起来，看一下： 对图中做一些说明： 12345// -run=&quot;none&quot;不执行基础单元测试，bench指定基准测试方法go test -v -run=&quot;none&quot; -bench=&quot;Bench*&quot;// 最后一个BenchmarkHttpIndex-4后面测试结果表示一共执行了11010次，每次执行耗时107392ns（～0.107ms） test标准库 结后语文章很基础，主要是介绍了结合了gin+gorm+go-redis，并写了简单的测试，是相对基础的文章，但足以应付一些api接口了。希望对你有帮助，有问题可留言或私信。 点击查看项目DEMO","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"gin","slug":"gin","permalink":"http://github.13sai.com/tags/gin/"}]},{"title":"结合gin+gorm+go-Redis写一个基础 API（中篇）","slug":"结合 gin+gorm+go-Redis 写一个基础API（中篇）","date":"2020-06-11T12:19:38.000Z","updated":"2021-04-13T07:21:47.775Z","comments":true,"path":"2020/06/11/255/","link":"","permalink":"http://github.13sai.com/2020/06/11/255/","excerpt":"","text":"在上篇里，我介绍了读取配置，并尝试连接了数据库，那么这一篇呢，我们主要利用gin框架来写写简单的接口。 路由为了便于管理，还是将路由文件单独出来，新建routes： 123456789101112131415161718192021package routerimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot; &quot;local.com/sai0556/gin-frame/controller&quot;)func Load(g *gin.Engine) *gin.Engine &#123; g.Use(gin.Recovery()) // 404 g.NoRoute(func (c *gin.Context) &#123; c.String(http.StatusNotFound, &quot;404 not found&quot;); &#125;) g.GET(&quot;/&quot;, controller.Index) return g&#125; 控制器上面的代码中我们看到了controller，我们建一个目录controller： 先建base.go文件，用于写一些基础的方法，如SendResponse返回json。 123456789101112131415161718192021package controllerimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)type Response struct &#123; Code int `json:&quot;code&quot;` Message string `json:&quot;message&quot;` Data interface&#123;&#125; `json:&quot;data&quot;`&#125;func SendResponse(c *gin.Context, code int, message string, data interface&#123;&#125;) &#123; c.JSON(http.StatusOK, Response&#123; Code: code, Message: message, Data: data, &#125;)&#125; 再来写个index.go，处理逻辑。 12345678910package controllerimport ( &quot;github.com/gin-gonic/gin&quot;)func Index(c *gin.Context) &#123; SendResponse(c, 0, &quot;success&quot;, nil)&#125; 启动gin12345678// main.go// 在连接数据可后加入以下代码gin.SetMode(&quot;debug&quot;)g := gin.New()g = router.Load(g)g.Run(&quot;:8080&quot;) 不妨启动看看效果。 go run main.go -c=./conf/config.yaml 当然，这里的服务启动和停止可以写得再优雅一些。 推荐文章： Golang服务器热重启、热升级、热更新(safe and graceful hot-restart/reload http server)详解","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"gin","slug":"gin","permalink":"http://github.13sai.com/tags/gin/"}]},{"title":"结合gin+gorm+go-Redis写一个基础 API（上篇）","slug":"结合 gin+gorm+go-Redis 写一个基础API（上篇）","date":"2020-06-10T13:19:38.000Z","updated":"2021-04-13T07:21:39.726Z","comments":true,"path":"2020/06/10/254/","link":"","permalink":"http://github.13sai.com/2020/06/10/254/","excerpt":"","text":"初始化新建目录，初始化项目，运行： 12345go mod init sai0556/gin-frame// 使用本地modulego mod edit -require=local.com/sai0556/gin-frame@v1.0.0go mod edit -replace=local.com/sai0556/gin-frame@v1.0.0=$PWD 编码配置部分新建config目录，初始化并监听文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package configimport ( &quot;fmt&quot; &quot;github.com/fsnotify/fsnotify&quot; &quot;github.com/spf13/viper&quot;)type Config struct &#123; Name string&#125;// 初始化配置func Init(cfg string) error &#123; c := Config&#123; Name: cfg, &#125; if err := c.initConfig(); err != nil &#123; return err &#125; c.watchConfig() return nil&#125;func (c *Config) initConfig() error &#123; if c.Name != &quot;&quot; &#123; viper.SetConfigFile(c.Name) &#125; else &#123; // 默认配置文件是conf/config.yaml viper.AddConfigPath(&quot;conf&quot;) viper.SetConfigName(&quot;config&quot;) &#125; viper.SetConfigType(&quot;yaml&quot;) // viper解析配置文件 err := viper.ReadInConfig() if err != nil &#123; panic(fmt.Errorf(&quot;Fatal error config file: %s \\n&quot;, err)) &#125; fmt.Println(viper.GetString(&quot;name&quot;)) return nil&#125;func (c *Config) watchConfig() &#123; viper.WatchConfig() viper.OnConfigChange(func(e fsnotify.Event) &#123; fmt.Println(&quot;Config file changed:&quot;, e.Name) &#125;)&#125; conf/config.yaml，语法可自行研究下，比较简单。YAML入门 1234567name: gin-framedb: name: blog host: 127.0.0.1:3306 username: root password: 111111 charset: utf8mb4 数据库gorm连接数据库，构建连接池： 12345678910111213141516171819202122232425262728293031323334353637383940414243package modelimport ( &quot;fmt&quot; &quot;sync&quot; &quot;errors&quot; orm &quot;github.com/jinzhu/gorm&quot; _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot; &quot;github.com/spf13/viper&quot;)type MySqlPool struct &#123;&#125;var instance *MySqlPoolvar once sync.Oncevar db *orm.DBvar err error // 单例模式func GetInstance() *MySqlPool &#123; once.Do(func() &#123; instance = &amp;MySqlPool&#123;&#125; &#125;) return instance&#125;func (pool *MySqlPool) InitPool() (isSuc bool) &#123; dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s)/%s?charset=%s&quot;, viper.GetString(&quot;db.username&quot;), viper.GetString(&quot;db.password&quot;), viper.GetString(&quot;db.host&quot;), viper.GetString(&quot;db.name&quot;), viper.GetString(&quot;db.charset&quot;)) db, err = orm.Open(&quot;mysql&quot;, dsn) if err != nil &#123; panic(errors.New(&quot;mysql连接失败&quot;)) return false &#125; // 连接数配置也可以写入配置，在此读取 db.DB().SetMaxIdleConns(50) db.DB().SetMaxOpenConns(50) // db.LogMode(true) return true&#125; main.go我们完善一下main.go，初始化配置，并构建连接池： 1234567891011121314151617181920212223242526272829303132package main// import 这里我习惯把官方库，开源库，本地module依次列出import ( &quot;log&quot; &quot;os&quot; &quot;errors&quot; &quot;github.com/spf13/pflag&quot; &quot;local.com/sai0556/gin-frame/config&quot; &quot;local.com/sai0556/gin-frame/model&quot;)var ( conf = pflag.StringP(&quot;config&quot;, &quot;c&quot;, &quot;&quot;, &quot;config filepath&quot;))func main() &#123; pflag.Parse() // 初始化配置 if err := config.Init(*conf); err != nil &#123; panic(err) &#125; // 连接mysql数据库 isSuc := model.GetInstance().InitPool() if !isSuc &#123; log.Println(&quot;init database pool failure...&quot;) panic(errors.New(&quot;init database pool failure&quot;)) &#125;&#125; 写完不妨运行一下，看看效果吧！ 1go run main.go -c=./conf/config.yaml 参考：基于 Go 语言构建企业级的 RESTful API 服务","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"gin","slug":"gin","permalink":"http://github.13sai.com/tags/gin/"}]},{"title":"PHP的构成和生命周期","slug":"PHP的构成和生命周期","date":"2020-06-03T08:05:37.000Z","updated":"2021-04-13T07:37:28.374Z","comments":true,"path":"2020/06/03/253/","link":"","permalink":"http://github.13sai.com/2020/06/03/253/","excerpt":"","text":"PHP的源码构成 SAPI（PHP的应用接口层） main（主要代码，输入/输出，web通信以及PHP框架的初始化操作等） ZendVM（PHP解析器的主要实现，代码的解释和执行，核心部分） Extension（可分为PHP和Zend扩展） 生命周期 模块初始化（PHP框架，Zend引擎的初始化操作） 请求初始化（对于FPM而言，是在worker进程accept一个请求并读取/解析完请求数据后的一个阶段） 执行脚本阶段（PHP代码的编译、执行，PHP脚本经历从源代码到抽象语法树再到opline指令，opline指令也就是Zend引擎可识别的执行指令） 请求关闭阶段（flush输出内容，发送HTTP应答header头，清理全局变量、关闭编译器、关闭执行器等，resgister_shutdown_function也是在此执行） 模块关闭阶段（SAPI关闭时执行） 根据不同SAPI的实现，会有一些差别。比如命令行模式，每执行一次脚本都要经历这五个阶段；而FastCGI模式下，只在启动时执行一次模块初始化，然后请求只经历请求初始化，执行脚本和请求关闭几个阶段。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"利用ElementUI的table和calendar制作一个价格日历","slug":"利用ElementUI的table和calendar制作一个价格日历","date":"2020-05-04T11:43:59.000Z","updated":"2021-04-13T07:22:40.711Z","comments":true,"path":"2020/05/04/250/","link":"","permalink":"http://github.13sai.com/2020/05/04/250/","excerpt":"","text":"项目中需要做一个价格日历，便于展示和修改日期价格，我们先看下最终效果，然后利用ElementUI的table 和 calendar 实现一下。 来看看主要代码（代码仅保留了主要代码和属性，并不完整，可以自行根据实际情况修改）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309&lt;template&gt; &lt;div class=&quot;calendar-list-container&quot;&gt; &lt;!--expand-row-keys设置了row-key也要设置， expand-change 当用户对某一行展开或者关闭的时候会触发该事件（展开行时，回调的第二个参数为 expandedRows；树形表格时第二参数为 expanded） row, (expandedRows | expanded)--&gt; &lt;el-table ref=&quot;table&quot; key=&quot;id&quot; v-loading=&quot;listLoading&quot; :data=&quot;list&quot; element-loading-text=&quot;loading&quot; row-key=&quot;id&quot; :expand-row-keys=&quot;expands&quot; @expand-change=&quot;expandChange&quot; &gt; &lt;el-table-column align=&quot;center&quot; type=&quot;expand&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;!--价格日历渲染 --&gt; &lt;el-calendar v-loading=&quot;calendarLoad&quot; element-loading-text=&quot;loading&quot; &gt; &lt;template slot=&quot;dateCell&quot; slot-scope=&quot;&#123;date, data&#125;&quot; &gt; &lt;!--今日及之后的价格可设置setPrice --&gt; &lt;div :class=&quot;nowDay &lt;= data.day.replace(/-/g, &#x27;&#x27;)? &#x27;calendar-div&#x27; : &#x27;calendar-div calendar-prev&#x27;&quot; @click=&quot;nowDay &lt;= data.day.replace(/-/g, &#x27;&#x27;) &amp;&amp; setPrice(data, date)&quot; &gt; &lt;div&gt;&#123;&#123; data.day.slice(-2) &#125;&#125;&lt;/div&gt; &lt;div v-if=&quot;data.type == &#x27;current-month&#x27; &amp;&amp; refreshPrice(data)&quot; class=&quot;price &quot; &gt; 预订价：&#123;&#123; priceList[data.day.slice(-2) -1] &#125;&#125;元 &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;/el-calendar&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column align=&quot;center&quot; label=&quot;名称&quot; class-name=&quot;overflow-on&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.name &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column align=&quot;center&quot; label=&quot;图片&quot; width=&quot;210&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;img :src=&quot;scope.row.imageList[0]&quot; style=&quot;width:150px&quot; &gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column align=&quot;center&quot; label=&quot;今日价格&quot; max-width=&quot;200&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span&gt;&#123;&#123; scope.row.price &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column align=&quot;center&quot; label=&quot;原价&quot; max-width=&quot;200&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span&gt;&#123;&#123; scope.row.original_price &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column align=&quot;center&quot; label=&quot;操作&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;handleCheck(scope.row)&quot; &gt; 价格设置 &lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-dialog title=&quot;设置价格&quot; :visible.sync=&quot;dialogPriceVisible&quot; &gt; &lt;el-form class=&quot;small-space&quot; :model=&quot;temp&quot; label-position=&quot;left&quot; label-width=&quot;100px&quot; style=&quot;width: 500px; margin-left:50px;&quot; &gt; &lt;el-form-item label=&quot;名称&quot;&gt; &lt;el-input v-model=&quot;temp.name&quot; disabled /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;时间段&quot;&gt; &lt;el-date-picker v-model=&quot;temp.date&quot; type=&quot;daterange&quot; range-separator=&quot;至&quot; start-placeholder=&quot;开始日期&quot; end-placeholder=&quot;结束日期&quot; :picker-options=&quot;pickerBeginDateBefore&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;分时计价&quot; prop=&quot;is_part&quot; required &gt; &lt;el-radio v-model=&quot;temp.is_part&quot; :label=&quot;0&quot; &gt; 不分平时周末 &lt;/el-radio&gt; &lt;el-radio v-model=&quot;temp.is_part&quot; :label=&quot;1&quot; &gt; 区分周末 &lt;/el-radio&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;平时价&quot;&gt; &lt;el-input v-model=&quot;temp.normal_price&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item v-if=&quot;temp.is_part == 1&quot; label=&quot;周末价&quot; &gt; &lt;el-input v-model=&quot;temp.week_price&quot; /&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot; &gt; &lt;el-button @click=&quot;dialogPriceVisible = false&quot;&gt; 取 消 &lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;putPrice&quot; &gt; 确 定 &lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; fetchList, setRoomPrice, getRoomPrice &#125; from &quot;@/api&quot;;import moment from &#x27;moment&#x27;;export default &#123; name: &quot;room&quot;, data() &#123; return &#123; pickerBeginDateBefore:&#123; disabledDate(time) &#123; return time.getTime() &lt; Date.now() - 86400*1000; &#125; &#125;, schedule: [], list: [], dialogPriceVisible: false, dialogFormVisible: false, priceDate: &#x27;2020-01-01&#x27;, nowDate: 1, nowMonth: 1, nowDay: 0, nowYear: 2020, calendarMonth: 1, priceList: [], expands: [],//只展开一行放入当前行id room: &#123;&#125;, listLoading:false, calendarLoad: false, &#125;; &#125;, created() &#123; this.priceDate = new Date(); this.nowDate = this.priceDate.getDate(); this.nowMonth = this.priceDate.getMonth(); this.calendarMonth = this.nowMonth; this.nowYear = this.priceDate.getFullYear(); this.nowDay = this.priceDate.getFullYear()*10000+ (1+this.priceDate.getMonth())*100+ this.priceDate.getDate(); &#125;, methods: &#123; refreshPrice (data) &#123; // console.log(data); if (!data.isSelected) &#123; return true; &#125; if (data.day.slice(5, 7) == this.calendarMonth + 1) &#123; return true; &#125; this.calendarMonth = data.day.slice(5, 7) - 1; var that = this; getRoomPrice(that.room.id, &#123;&#x27;date&#x27;: data.day&#125;).then(response =&gt; &#123; var arr = []; response.data.priceList.forEach((item,index,array)=&gt;&#123; arr[index] = item? item : that.room.price; &#125;) that.priceList = arr &#125;); that.$forceUpdate() &#125;, getRowKeys(row) &#123; // console.log(row.id) return row.id //这里看这一行中需要根据哪个属性值是id &#125;, selectDate(type) &#123; // consoloe.log(type) &#125;, expandChange(row, expandedRows) &#123; // console.log(this.expands) var that = this; that.room = row; // 每次只展开一行 if (expandedRows.length) &#123; that.calendarLoad = true; getRoomPrice(row.id, &#123;&#x27;date&#x27;: this.priceDate&#125;).then(response =&gt; &#123; that.calendarLoad = false; var arr = []; response.data.priceList.forEach((item,index,array)=&gt;&#123; arr[index] = item? item : row.price; &#125;) that.priceList = arr that.expands = [row.id] &#125;); &#125; else &#123; // 收起价格日历 that.expands = [] &#125; &#125;, setPrice(data, date) &#123; if (this.nowDay &gt; data.day.replace(/-/g, &#x27;&#x27;)) &#123; return false; &#125; var that = this; this.temp = &#123; name: that.room.name, date: [date, date], is_part: 0, &#125;; this.dialogPriceVisible = true; &#125;, putPrice() &#123; this.dialogPriceVisible = true; setRoomPrice(this.room.id, this.temp).then(res =&gt; &#123; if (res.code == 0) &#123; this.$message.success(&quot;编辑成功&quot;); this.dialogPriceVisible = !this.dialogPriceVisible; var that = this; getRoomPrice(that.room.id, &#123;&#x27;date&#x27;: this.temp.date[0]&#125;).then(response =&gt; &#123; var arr = []; response.data.priceList.forEach((item,index,array)=&gt;&#123; arr[index] = item? item : that.room.price; &#125;) that.priceList = arr &#125;); fetchList(that.params).then(response =&gt; &#123; that.list = response.data; &#125;); that.resetTemp(); that.$forceUpdate() &#125; else &#123; this.$message.error(res.msg); &#125; &#125;); &#125;, // 用于可展开表格与树形表格，切换某一行的展开状态，如果使用了第二个参数，则是设置这一行展开与否（expanded 为 true 则展开） handleCheck(row) &#123; const $table = this.$refs.table $table.toggleRowExpansion(row) &#125; &#125;&#125;;&lt;/script&gt; 价格日历返回数据格式： 12345678910111213&#123; &quot;status&quot;: &quot;success&quot;, &quot;code&quot;: 0, &quot;msg&quot;: &quot;操作成功&quot;, &quot;data&quot;: &#123; &quot;room&quot;: &#123; &quot;name&quot;: &quot;大床房&quot;, &quot;price&quot;: 299, &quot;original_price&quot;: 289 &#125;, &quot;priceList&quot;: [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, 209, 219, false, false, false, false, false], &#125;&#125; priceList是本月价格，false表示未设置。 table的功能比较强大，部分属性函数并不常用，可以自行打印出来看看，研究一下即可。calendar是2.8版本新增的组件，如果版本过低，可以尝试升级到新版本。","categories":[{"name":"vue","slug":"vue","permalink":"http://github.13sai.com/categories/vue/"}],"tags":[{"name":"ElementUI","slug":"ElementUI","permalink":"http://github.13sai.com/tags/ElementUI/"}]},{"title":"利用Laravel中间件给后台加个操作日志","slug":"利用Laravel中间件给后台加个操作日志","date":"2020-04-29T12:48:08.000Z","updated":"2021-04-13T07:19:48.541Z","comments":true,"path":"2020/04/29/248/","link":"","permalink":"http://github.13sai.com/2020/04/29/248/","excerpt":"","text":"项目后台角色及人员变多，需要加下日志，方便查询，不妨利用中间件实现下。 方案： 中间件判断是否需要记录，写入队列 队列写入数据库 表设计 12345678910CREATE TABLE `admin_log` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL, `path` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `method` varchar(10) COLLATE utf8mb4_unicode_ci NOT NULL, `ip` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `input` text COLLATE utf8mb4_unicode_ci NOT NULL, `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC; 新建中间件AdminLogMiddleware，在后台路由中加入此中间件即可， 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php/** * Author: sai * Date: 2020/4/1 * Time: 16:19 */namespace App\\Http\\Middleware;use App\\Jobs\\OperationLogJob;use Closure;use Auth;class AdminLogMiddleware&#123; /** * 处理传入的参数 * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @param string $role * @return mixed */ public function handle($request, Closure $next, $role) &#123; // 剔除GET，OPTIONS请求 if (!in_array($method = $request-&gt;getMethod(), [&#x27;GET&#x27;, &#x27;OPTIONS&#x27;])) &#123; $data = [ &#x27;user_id&#x27; =&gt; Auth::guard(&#x27;admin&#x27;)-&gt;id(), &#x27;path&#x27; =&gt; $request-&gt;getPathInfo(), &#x27;method&#x27; =&gt; $method, &#x27;ip&#x27; =&gt; $request-&gt;getClientIp(), &#x27;input&#x27; =&gt; \\json_encode($request-&gt;all(), JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE), ]; // 异步写入，提高操作流畅性 $job = (new OperationLogJob($data)); dispatch($job); &#125; return $next($request); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace App\\Jobs;use App\\Models\\AdminLog;use Illuminate\\Bus\\Queueable;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Foundation\\Bus\\Dispatchable;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Queue\\SerializesModels;class OperationLogJob implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; /** * Create a new job instance. * * @return void */ public function __construct($data) &#123; // $this-&gt;queue = &#x27;adminLog&#x27;; $this-&gt;data = $data; &#125; private $data; /** * Execute the job. * * @return void */ public function handle() &#123; // AdminLog::create($this-&gt;data); &#125;&#125; 执行队列： 1php artisan queue:work --queue=adminLog 当然，也可以不写入数据库，写在log文件里，这里就不展开了。 另外，为了方便，也可以给后台统一加入AdminLogMiddleware中间件，把不需要做记录的路由加入配置文件，在中间件加入判断，省去在路由配置去区分是否需要记录。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://github.13sai.com/tags/Laravel/"}]},{"title":"ElementUI中table表格自定义表头Tooltip文字提示","slug":"ElementUI中table表格自定义表头Tooltip文字提示","date":"2020-04-29T08:18:28.000Z","updated":"2021-04-26T03:35:57.636Z","comments":true,"path":"2020/04/29/247/","link":"","permalink":"http://github.13sai.com/2020/04/29/247/","excerpt":"","text":"table表格需要增加提示文案说明，没有现成的属性添加，我们可以通过render-header来渲染表头。 代码如下： 123456789&lt;el-table-column align=&quot;center&quot; label=&quot;价格&quot; :render-header=&quot;renderTipsHeader&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.amount &#125;&#125; &lt;/template&gt;&lt;/el-table-column&gt; renderTipsHeader： 12345678910111213141516171819renderTipsHeader (h,&#123;column&#125;) &#123; return h( &#x27;div&#x27;,[ h(&#x27;span&#x27;, column.label), h(&#x27;el-tooltip&#x27;,&#123; props:&#123; effect:&#x27;dark&#x27;, content:&#x27;提示文案&#x27;, placement:&#x27;top&#x27; &#125;, &#125;,[ h(&#x27;i&#x27;, &#123; class:&#x27;el-icon-question&#x27;, style:&#x27;color:#409EFF;margin-left:5px;&#x27; &#125;) ]) ] ); &#125; 效果如图： 12render-header 列标题 Label 区域渲染使用的 Function Function(h, &#123; column, $index &#125;) 感兴趣可以打印出来看看，这里还有更复杂的应用–https://github.com/Darkerxi/ElementUI-Table-column_render-header 参考文章：element-ui自定义table表头，修改标题样式、添加tooltip及 :render-header使用简介","categories":[{"name":"vue","slug":"vue","permalink":"http://github.13sai.com/categories/vue/"}],"tags":[{"name":"ElementUI","slug":"ElementUI","permalink":"http://github.13sai.com/tags/ElementUI/"}]},{"title":"分享按日执行的脚本","slug":"分享按日执行的脚本","date":"2020-04-25T09:55:07.000Z","updated":"2020-12-09T10:33:39.836Z","comments":true,"path":"2020/04/25/246/","link":"","permalink":"http://github.13sai.com/2020/04/25/246/","excerpt":"","text":"项目中要做一些按日进行的统计，之前的任务都没跑，写个脚本执行下。 plus.sh 1234567891011121314#!/bin/bashSTART_DATE=$1END_DATE=$2EXEC_COMMAND=$3echo &#x27;start_date: &#x27;$START_DATEecho &#x27;end_date: &#x27;$END_DATEi=$START_DATEwhile [[ $i &lt; `date -d &quot;+1 day $END_DATE&quot; +%Y%m%d` ]] do echo $i $EXEC_COMMAND $i i=`date -d &quot;+1 day $i&quot; +%Y%m%d`done 执行 ./plus.sh 2020-03-01 2020-04-24 ‘php artisan command:test’","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://github.13sai.com/tags/shell/"}]},{"title":"Laravel6配合MaatwebsiteExcel实现Excel导入","slug":"Laravel6配合MaatwebsiteExcel实现Excel导入","date":"2020-04-05T02:52:58.000Z","updated":"2021-04-13T07:32:11.610Z","comments":true,"path":"2020/04/05/245/","link":"","permalink":"http://github.13sai.com/2020/04/05/245/","excerpt":"","text":"前一段需要项目中需要通过Excel导入用户，之前用过phpexcel，总感觉太过繁琐，印象中phpexcel也很久没更新，看到项目中有使用Maatwebsite\\Excel，便尝试使用一下。 安装1composer require maatwebsite/excel 导入生成导入类1php artisan make:import AdminsImport --model=Admin 会看到app下面生成了Imports文件夹。 完善业务逻辑12345678910111213141516171819202122232425262728&lt;?phpnamespace App\\Imports;use App\\Models\\Admin;use function EasyWeChat\\Kernel\\Support\\str_random;use Maatwebsite\\Excel\\Concerns\\ToModel;class AdminsImport implements ToModel&#123; /** * @param array $row * * @return \\Illuminate\\Database\\Eloquent\\Model|null */ public function model(array $row) &#123; //过滤表头和空行，我这边表头的第一个单元格是id，具体自行调整 if (empty($row[0]) || $row[0] == &#x27;id&#x27;) &#123; return null; &#125; return new Admin([ &#x27;username&#x27; =&gt; $row[2], &#x27;password&#x27; =&gt; bcrypt($row[3]), &#x27;api_token&#x27; =&gt; str_random(60), ]); &#125;&#125; 导入任务123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace App\\Console\\Commands;use App\\Imports\\AdminsImport;use Illuminate\\Console\\Command;use Maatwebsite\\Excel\\Facades\\Excel;class ImportAdmin extends Command&#123; /** * The name and signature of the console command. * * @var string */ protected $signature = &#x27;importAdmin&#x27;; /** * The console command description. * * @var string */ protected $description = &#x27;导入admin&#x27;; /** * Create a new command instance. * * @return void */ public function __construct() &#123; parent::__construct(); &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; Excel::import(new AdminsImport(), storage_path(&#x27;files/export.xlsx&#x27;)); $this-&gt;info($this-&gt;description.&#x27;完成&#x27;); &#125;&#125; 其他逻辑当然，可能业务必不仅仅是写入数据，可能有一些设计具体业务的操作，那么你可以这样操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace App\\Imports;use App\\Models\\Admin;use function EasyWeChat\\Kernel\\Support\\str_random;use Maatwebsite\\Excel\\Concerns\\ToCollection;use Illuminate\\Support\\Collection;class AdminsImport implements ToCollection&#123; public function collection(Collection $rows) &#123; //如果需要去除表头 unset($rows[0]); //$rows 是数组格式 return $this-&gt;createData($rows); &#125; public function createData($rows) &#123; $success = 0; foreach ($rows as $row) &#123; $row[0] = (int) $row[0]; if (empty($row[0])) &#123; continue; &#125; (new Admin())-&gt;create( [ &#x27;username&#x27; =&gt; $row[2], &#x27;name&#x27; =&gt; $row[2], &#x27;password&#x27; =&gt; bcrypt($row[3]), &#x27;api_token&#x27; =&gt; str_random(60), ] ); // 其他业务代码 $success++; &#125; return $success.&#x27;-&#x27;.count($rows); &#125;&#125; 执行1php7.2 artisan importAdmin 总的来说，使用起来还是简单明了的。 more具体导入实现可以搜索Maatwebsite\\Excel\\Excel查看，里面还有导出、以队列方式导入等，支持的格式也是多种多样，具体代码如下，功能还是很强大的，足够应付日常需求了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&lt;?phpnamespace Maatwebsite\\Excel;use Illuminate\\Support\\Collection;use Maatwebsite\\Excel\\Files\\Filesystem;use Maatwebsite\\Excel\\Files\\TemporaryFile;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Foundation\\Bus\\PendingDispatch;use Maatwebsite\\Excel\\Helpers\\FileTypeDetector;class Excel implements Exporter, Importer&#123; use RegistersCustomConcerns; const XLSX = &#x27;Xlsx&#x27;; const CSV = &#x27;Csv&#x27;; const TSV = &#x27;Csv&#x27;; const ODS = &#x27;Ods&#x27;; const XLS = &#x27;Xls&#x27;; const SLK = &#x27;Slk&#x27;; const XML = &#x27;Xml&#x27;; const GNUMERIC = &#x27;Gnumeric&#x27;; const HTML = &#x27;Html&#x27;; const MPDF = &#x27;Mpdf&#x27;; const DOMPDF = &#x27;Dompdf&#x27;; const TCPDF = &#x27;Tcpdf&#x27;; /** * @var Writer */ protected $writer; /** * @var QueuedWriter */ protected $queuedWriter; /** * @var Filesystem */ protected $filesystem; /** * @var Reader */ private $reader; /** * @param Writer $writer * @param QueuedWriter $queuedWriter * @param Reader $reader * @param Filesystem $filesystem */ public function __construct( Writer $writer, QueuedWriter $queuedWriter, Reader $reader, Filesystem $filesystem ) &#123; $this-&gt;writer = $writer; $this-&gt;reader = $reader; $this-&gt;filesystem = $filesystem; $this-&gt;queuedWriter = $queuedWriter; &#125; /** * &#123;@inheritdoc&#125; */ public function download($export, string $fileName, string $writerType = null, array $headers = []) &#123; return response()-&gt;download( $this-&gt;export($export, $fileName, $writerType)-&gt;getLocalPath(), $fileName, $headers )-&gt;deleteFileAfterSend(true); &#125; /** * &#123;@inheritdoc&#125; */ public function store($export, string $filePath, string $diskName = null, string $writerType = null, $diskOptions = []) &#123; if ($export instanceof ShouldQueue) &#123; return $this-&gt;queue($export, $filePath, $diskName, $writerType, $diskOptions); &#125; $temporaryFile = $this-&gt;export($export, $filePath, $writerType); $exported = $this-&gt;filesystem-&gt;disk($diskName, $diskOptions)-&gt;copy( $temporaryFile, $filePath ); $temporaryFile-&gt;delete(); return $exported; &#125; /** * &#123;@inheritdoc&#125; */ public function queue($export, string $filePath, string $disk = null, string $writerType = null, $diskOptions = []) &#123; $writerType = FileTypeDetector::detectStrict($filePath, $writerType); return $this-&gt;queuedWriter-&gt;store( $export, $filePath, $disk, $writerType, $diskOptions ); &#125; /** * &#123;@inheritdoc&#125; */ public function raw($export, string $writerType) &#123; $temporaryFile = $this-&gt;writer-&gt;export($export, $writerType); $contents = $temporaryFile-&gt;contents(); $temporaryFile-&gt;delete(); return $contents; &#125; /** * &#123;@inheritdoc&#125; */ public function import($import, $filePath, string $disk = null, string $readerType = null) &#123; $readerType = FileTypeDetector::detect($filePath, $readerType); $response = $this-&gt;reader-&gt;read($import, $filePath, $readerType, $disk); if ($response instanceof PendingDispatch) &#123; return $response; &#125; return $this; &#125; /** * &#123;@inheritdoc&#125; */ public function toArray($import, $filePath, string $disk = null, string $readerType = null): array &#123; $readerType = FileTypeDetector::detect($filePath, $readerType); return $this-&gt;reader-&gt;toArray($import, $filePath, $readerType, $disk); &#125; /** * &#123;@inheritdoc&#125; */ public function toCollection($import, $filePath, string $disk = null, string $readerType = null): Collection &#123; $readerType = FileTypeDetector::detect($filePath, $readerType); return $this-&gt;reader-&gt;toCollection($import, $filePath, $readerType, $disk); &#125; /** * &#123;@inheritdoc&#125; */ public function queueImport(ShouldQueue $import, $filePath, string $disk = null, string $readerType = null) &#123; return $this-&gt;import($import, $filePath, $disk, $readerType); &#125; /** * @param object $export * @param string|null $fileName * @param string $writerType * * @throws \\PhpOffice\\PhpSpreadsheet\\Exception * @return TemporaryFile */ protected function export($export, string $fileName, string $writerType = null): TemporaryFile &#123; $writerType = FileTypeDetector::detectStrict($fileName, $writerType); return $this-&gt;writer-&gt;export($export, $writerType); &#125;&#125; 最后，感谢下面这一篇站内文章让我快速上手。 maatwebsite/Excel 3.1 使用教程 （导入篇） 最后，附上Laravel Excel 文档： Laravel Excel","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://github.13sai.com/tags/Laravel/"}]},{"title":"go的类型转换","slug":"go的类型转换","date":"2020-03-29T14:34:45.000Z","updated":"2021-04-13T07:30:47.528Z","comments":true,"path":"2020/03/29/243/","link":"","permalink":"http://github.13sai.com/2020/03/29/243/","excerpt":"","text":"类型转换是经常使用到的，汇总了一些比较常见的用法，分享给你～ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package main/** 变量类型转换*/import ( &quot;fmt&quot; &quot;reflect&quot; &quot;strconv&quot;)func main() &#123; v := &quot;hello world&quot; fmt.Println(typeofFmt(v)) fmt.Println(typeofReflect(v)) str := &quot;1245&quot; fmt.Println(stringToInt(str)) fmt.Println(stringToInt64(str)) a := 3545; var b int64; b = 98; fmt.Println(int64ToString(b)) fmt.Println(intToString(a)) var f float64 f = 3.45 fmt.Println(floatToString(f)) str = &quot;1.24&quot; fmt.Println(stringToFloat(str)) //int到int64 fmt.Println(int64(1234)) //int 转化为 float score := 100 fmt.Println(float64(score))&#125;// 利用fmtfunc typeofFmt(v interface&#123;&#125;) string &#123; return fmt.Sprintf(&quot;%T&quot;, v)&#125;// 利用reflectfunc typeofReflect(v interface&#123;&#125;) string &#123; return reflect.TypeOf(v).String()&#125;// string转intfunc stringToInt(a string) int &#123; d,_ := strconv.Atoi(a) return d&#125;//Atoi是ParseInt(s, 10, 0)的简写。// string转int64func stringToInt64(a string) int64 &#123; d, _ := strconv.ParseInt(a, 10, 64) return d&#125;/**func ParseInt(s string, base int, bitSize int) (i int64, err error)返回字符串表示的整数值，接受正负号。base指定进制（2到36），如果base为0，则会从字符串前置判断，&quot;0x&quot;是16进制，&quot;0&quot;是8进制，否则是10进制；bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。*/// int转stringfunc intToString(a int) string &#123; str := strconv.Itoa(a) return str&#125;// int64转stringfunc int64ToString(a int64) string &#123; str := strconv.FormatInt(a,10) return str&#125;/**func FormatInt(i int64, base int) string返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母&#x27;a&#x27;到&#x27;z&#x27;表示大于10的数字。*/// float转stringfunc floatToString (f float64) string &#123; return strconv.FormatFloat(f,&#x27;f&#x27;,-1,32)&#125;/**func FormatFloat(f float64, fmt byte, prec, bitSize int) stringbitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。fmt表示格式：&#x27;f&#x27;（-ddd.dddd）、&#x27;b&#x27;（-ddddp±ddd，指数为二进制）、&#x27;e&#x27;（-d.dddde±dd，十进制指数）、&#x27;E&#x27;（-d.ddddE±dd，十进制指数）、&#x27;g&#x27;（指数很大时用&#x27;e&#x27;格式，否则&#x27;f&#x27;格式）、&#x27;G&#x27;（指数很大时用&#x27;E&#x27;格式，否则&#x27;f&#x27;格式）。prec控制精度（排除指数部分）：对&#x27;f&#x27;、&#x27;e&#x27;、&#x27;E&#x27;，它表示小数点后的数字个数；对&#x27;g&#x27;、&#x27;G&#x27;，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。*/// string转floatfunc stringToFloat(s string) float64 &#123; f,_ := strconv.ParseFloat(s,64) return f&#125;/**func ParseFloat(s string, bitSize int) (f float64, err error)解析一个表示浮点数的字符串并返回其值。如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。*/ 更多类型转换相关可查看标准库：- strconv 技术文章也发布在自己的公众号【爱好历史的程序员】，欢迎扫码关注，谢谢！","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"Redis持久化","slug":"Redis持久化","date":"2020-03-24T13:16:09.000Z","updated":"2020-04-05T12:40:34.542Z","comments":true,"path":"2020/03/24/242/","link":"","permalink":"http://github.13sai.com/2020/03/24/242/","excerpt":"","text":"持久化的功能:Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令) 从内存保存到硬盘。 当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。 Redis持久化 分为RDB持久化和AOF持久化，前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘。 RDB RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。 ，触发 RDB 持久化过程分为手动触发和自动触发。 触发机制save 命令:阻塞当前 Redis 服务器，直到 RDB 过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。 bgsave 命令:Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。 显然 bgsave 命令是针对 save阻塞问题做的优化。因此 Redis 内部所有的涉及 RDB 的操作都采用 bgsave 的方式。 除了执行命令手动触发之外，Redis 内部还存在自动触发 RDB 的持久化机制，例如以下场景: 使用 save 相关配置，如“save m n”。表示 m 秒内数据集存在 n 次修改时，自动触发 bgsave。 如果从节点执行全量复制操作，主节点自动执行 bgsave 生成 RDB 文件并发送给从节点。 执行 debug reload 命令重新加载 Redis 时，也会自动触发 save 操作。 默认情况下执行 shutdown 命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave。 bgsave流程 执行 bgsave 命令，Redis 父进程判断当前是否存在正在执行的子进程，如 RDB/AOF 子进程，如果存在 bgsave 命令直接返回。 父进程执行 fork 操作创建子进程，fork操作过程中父进程会阻塞，通过 info stats命令查看 latest_fork_usec选项，可以获取最近一个 fork 操作的耗时，单位为微秒。 父进程 fork 完成后，bgsave 命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。 子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行 lastsave 命令可以获取最后一次生成 RDB 的时间，对应 info 统计的 rdb_last_save_time 选项。 进程发送信号给父进程表示完成，父进程更新统计信息，具体见 info Persistence 下的 rdb_* 相关选项。 配置文件（流程类似bgsave）12345678# 900s内至少达到一条写命令 save 900 1# 300s内至少达至10条写命令 save 300 10# 60s内至少达到10000条写命令 save 60 10000 RDB 文件的处理1. 保存:RDB 文件保存在 dir 配置指定的目录下，文件名通过 dbfilename 配置指定。可以通过执行 config set dir{newDir}和 config setdbfilename{newFileName}运行期动态执行，当下次运行时 RDB 文件会保存到新目录。当遇到坏盘或磁盘写满等情况时，可以通过 config set dir{newDir}在线修改文件路径到可用的磁盘路径，之后执行 bgsave 进行磁盘切换，同样适用于 AOF 持久化文件。 2. 压缩:Redis 默认采用 LZF 算法对生成的 RDB 文件做压缩处理，压缩后的文件远远小于内存大小，默认开启，可以通过参数 config setrdbcompression{yes|no}动态修改。虽然压缩 RDB 会消耗 CPU，但可大幅降低文件的体积，方便保存到硬盘或通过网络发送给从节点，因此线上建议开启。 RDB方式的优点 RDB 是一个非常紧凑的文件，它保存了 Redis 在某个时间点上的数据集。这种文件非常适合用于进行备份: 比如说，你可以在最近的 24小时内，每小时备份一次 RDB文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。 RDB 可以最大化 Redis 的性能:父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存 工作，父进程无须执行任何磁盘 I/O 操作。 RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 RDB方式 的缺点 RDB 方式数据没办法做到实时持久化/秒级持久化 如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。 使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。 AOF AOF(append only file)持久化:与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令到日志当中，并将这些写操作 以Redis协议追加保存到以后缀为aof文件末尾 配置redis.conf 123456789appendonly yes #启用aof持久化方式 appendfsync always/no/everysec设置为always时，会极大消弱Redis的性能，因为这种模式下每次write后都会调用fsync（Linux为调用fdatasync）。如果设置为no，则write后不会有fsync调用，由操作系统自动调度刷磁盘，性能是最好的。everysec为最多每秒调用一次fsync，这种模式性能并不是很糟糕，一般也不会产生毛刺，这归功于Redis引入了BIO线程，所有fsync操作都异步交给了BIO线程。 流程 所有的写入命令会追加到 aof_buf(缓冲区)中。 AOF 缓冲区根据对应的策略向硬盘做同步操作。 随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。 当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。 重写机制 AOF将客户端的每一个写操作都追加到aof文件末尾，随着命令不断写入 AOF，文件会越来越大，为了解决这个问题，Redis 引入 AOF 重写机制压缩文 件体积。AOF 文件重写是把 Redis 进程内的数据转化为写命令同步到新 AOF 文件的过程。 比如:多条写命令可以合并为一个，如:lpush list a、lpush list b、lpush list c 可以转化为:lpush list a b c。 AOF 重写降低了文件占用空间，除此之外，另一个目的是:更小的 AOF 文件可以更快地被 Redis 加载。 重写流程 执行 AOF 重写请求。 如果当前进程正在执行 AOF 重写，请求不执行并返回如下响应: ERR Background append only file rewriting already in progress 父进程执行 fork 创建子进程，开销等同于 bgsave 过程。 主进程 fork 操作完成后，继续响应其他命令。所有修改命令依然写入 AOF 缓冲区并根据 appendfsync 策略同步到硬盘，保证原有 AOF 机制正确 性。 由于 fork 操作运用写时复制技术，子进程只能共享 fork 操作时的内存数据。由于父进程依然响应命令，Redis 使用“AOF 重写缓冲区”保存这部 分新数据，防止新 AOF 文件生成期间丢失这部分数据。 子进程根据内存快照，按照命令合并规则写入到新的 AOF 文件。每次批量写入硬盘数据量由配置 aof-rewrite-incremental-fsync 控制，默认为 32MB，防止单 次刷盘数据过多造成硬盘阻塞。1234.1)新 AOF 文件写入完成后，子进程发送信号给父进程，父进程更新统计信息，具体见 info persistence 下的 aof_*相关统计。 4.2)父进程把 AOF 重写缓冲区的数据写入到新的 AOF 文件。4.3)使用新 AOF 文件替换老文件，完成 AOF 重写。 触发重写 手动触发:直接调用 bgrewriteaof 命令。 自动触发:根据 auto-aof-rewrite-min-size和auto-aof-rewrite-percentage 参数确定自动触发时机。 12345auto-aof-rewrite-min-size:表示运行 AOF 重写时文件最小体积，默认为 64MB。auto-aof-rewrite-percentage:代表当前 AOF 文件空间(aof_current_size)和上一次重写后 AOF 文件空间(aof_base_size)的比值。示例:auto-aof-rewrite-percentage:100 auto-aof-rewrite-min-size:64mb默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发 异常处理AOF文件损坏在写入aof日志文件时，如果Redis服务器宕机，则aof日志文件文件会出格式错误，在重启Redis服务器时，Redis服务器会拒绝载入这个aof文件， 可以通过命令修复aof并恢复数据 redis-check-aof -fix file.aof AOF的优点 AOF可以设置 完全不同步、每秒同步、每次操作同，默认是每秒同步。因为AOF是操作指令的追加，所以可以频繁的大量的同步。 AOF文件是一个值追加日志的文件，即使服务宕机为写入完整的命令，也可以通过redis-check-aof工具修复这些问题。 如果AOF文件过大，Redis会在后台自动地重写AOF文件。重写后会使AOF文件压缩到最小所需的指令集。 AOF文件是有序保存数据库的所有写入操作，易读，易分析。即使如果不小心误操作数据库，也很容易找出错误指令，恢复到某个数据节点。例如不 小心FLUSHALL，可以非常容易恢复到执行命令之前。 AOF的缺点 相同数据量下，AOF的文件通常体积会比RDB大。因为AOF是存指令的，而RDB是所有指令的结果快照。但AOF在日志重写后会压缩一些空间。 在大量写入和载入的时候，AOF的效率会比RDB低。因为大量写入，AOF会执行更多的保存命令，载入的时候也需要大量的重执行命令来得到最后的结 果。RDB对此更有优势。 配置汇总12345678910save 60 1000:60s内至少达到1000条写命令appendonly no:是否开启AOFappendfilename &quot;appendonly.aof&quot;:AOF文件名dir ./:RDB文件和AOF文件所在目录appendfsync everysec:fsync持久化策略no-appendfsync-on-rewrite no:AOF重写期间是否禁止fsync;如果开启该选项，可以减轻文件重写时CPU和硬盘的负载(尤其是硬盘)，但是可能会丢 失AOF重写期间的数据;需要在负载和安全性之间进行平衡auto-aof-rewrite-percentage 100:文件重写触发条件之一auto-aof-rewrite-min-size 64mb:文件重写触发提交之一aof-load-truncated yes:如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件","categories":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"}]},{"title":"Redis常用类型及应用场景","slug":"Redis常用类型及应用场景","date":"2020-03-22T13:36:48.000Z","updated":"2020-03-24T13:38:09.134Z","comments":true,"path":"2020/03/22/230/","link":"","permalink":"http://github.13sai.com/2020/03/22/230/","excerpt":"","text":"主要类型 字符串（strings，bitmaps） 散列（hashes） 列表（lists） 集合（sets） 有序集合（sorted sets） hyperloglogs 发布订阅（pub/sub） 地理空间（geospatial） Stream（5.0版本新增） 关于命令我推荐看这两个： http://doc.redisfans.com/ http://www.redis.cn/commands.html 应用场景strings 缓存 分布式锁（setnx） 签到统计（setbit） 计数（incr） hashes 缓存 用户标签 lists 队列 sets 交集并集 数据去重 zset 排行榜 延时任务 限流 hyperloglogs uv统计（ip统计） pub/sub 发布订阅（不是特别可靠） geospatial 附近的人 Stream 队列 发布订阅 其他利用事务实现秒杀以php代码为例： WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值） 1234567891011121314151617181920212223242526272829303132// 库存为5//实例化redis$redis = new Redis();//连接$redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379);$key = &#x27;sale&#x27;;$redis-&gt;setnx($key, 0); // 此项不预定义亦可，保证key唯一就行$redis-&gt;watch($key); //监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。$sale_num = $redis-&gt;get($key);if ($sale_num &gt; 4) &#123; exit();&#125;$redis-&gt;multi(); //标记事务$redis-&gt;incr($key); //销量+1sleep(1); //模拟真实环境$ret = $redis-&gt;exec(); // 事务块内所有命令的返回值，按命令执行的先后顺序排列。if ($ret) &#123; // 自定义的一个基于medoo的dbclass include &#x27;db.php&#x27;; $db = new db([ &#x27;database_type&#x27; =&gt; &#x27;mysql&#x27;, &#x27;database_name&#x27; =&gt; &#x27;test&#x27;, &#x27;server&#x27; =&gt; &#x27;13sai&#x27;, &#x27;username&#x27; =&gt; &#x27;13sai&#x27;, &#x27;password&#x27; =&gt; &#x27;*&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27; ]); $db-&gt;update(&#x27;goods&#x27;, [&quot;stock_num[-]&quot; =&gt; 1], [&#x27;id&#x27; =&gt; 1]);&#125; 布隆过滤器 布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。 php实现推荐看看这篇文章： https://github.13sai.com/2019/05/21/188/ 当然，Redis自己也有第三方模块： https://github.com/RedisBloom/RedisBloom 123456git clone https://github.com/RedisBloom/RedisBloom.gitcd redisbloommake/path/to/redis-server --loadmodule ./redisbloom.so Bloom：向过滤器添加新项,如果尚不存在，则会为您创建一个新的过滤器 12127.0.0.1:6379&gt; BF.ADD newFilter foo(integer) 1 Bloom：检查过滤器中是否存在项 12345127.0.0.1:6379&gt; BF.EXISTS newFilter foo(integer) 1127.0.0.1:6379&gt; BF.EXISTS newFilter notpresent(integer) 0 限流Redis-cell123456// 提前安装rust哟git clone https://github.com/brandur/redis-cell.gitcd redis-cellcargo build --releasecp target/release/libredis_cell.dylib /path/to/modules/redis-server --loadmodule /path/to/modules/libredis_cell.so 该模块只有1条指令cl.throttle，它的参数和返回值都略显复杂，接下来让我们来看看这个指令具体该如何使用。 123456&gt; cl.throttle limitThrot 15 30 60 1 ▲ ▲ ▲ ▲ ▲ | | | | └───── need 1 quota (可选参数，默认值也是1) | | └──┴─────── 30 operations / 60 seconds 这是漏水速率 | └───────────── 15 capacity 这是漏斗容量&gt; └─────────────────── key 上面这个指令的意思是允许频率为每 60s 最多 30 次(漏水速率)，漏斗的初始容量为 15，也就是说一开始可以取 15 个，然后才开始受漏水速率的影响。我们看到这个指令中漏水速率变成了 2 个参数，替代了之前的单个浮点数。用两个参数相除的结果来表达漏水速率相对单个浮点数要更加直观一些。 123456&gt; cl.throttle limitThrot 15 30 60 11) (integer) 0 # 0 表示允许，1表示拒绝2) (integer) 15 # 漏斗容量capacity3) (integer) 14 # 漏斗剩余空间left_quota4) (integer) -1 # 如果拒绝了，需要多长时间后再试(漏斗有空间了，单位秒)5) (integer) 2 # 多长时间后，漏斗完全空出来(left_quota==capacity，单位秒) 基本上常见的场景就是这些了，各位周末愉快！","categories":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"}]},{"title":"MySQL是如何做到不丢数据","slug":"MySQL是如何做到不丢数据","date":"2020-03-18T03:36:48.000Z","updated":"2021-04-13T07:33:18.975Z","comments":true,"path":"2020/03/18/240/","link":"","permalink":"http://github.13sai.com/2020/03/18/240/","excerpt":"","text":"本文为极客时间专栏《MySQL实战45讲》笔记，文中部分图文来自该专栏。附上专栏链接，有兴趣可点击订阅：https://time.geekbang.org/column/intro/139 MySQL是如何做到数据不丢失呢？ 我们先来介绍下WAL。 WAL(Write-Ahead Loggin)机制WAL 是预写式日志, 关键点在于先写日志再写磁盘. MySQL在对数据页进行修改时, 通过将”修改了什么”这个操作记录在日志中, 而不必马上将更改内容刷新到磁盘上, 从而将随机写转换为顺序写, 提高了性能。 这种机制一方面提高了MySQL的吞吐量，另一方面也实现了数据的高可靠性。 binlog的写入机制事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。 一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了binlog cache的保存问题。 系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。 事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。 可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。 图中的write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。 图中的fsync，才是将数据持久化到磁盘的操作。 write 和fsync的时机，是由参数sync_binlog控制的： sync_binlog=0的时候，表示每次提交事务都只write，不fsync； sync_binlog=1的时候，表示每次提交事务都会执行fsync； sync_binlog=N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。 因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。 但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。 redo log先说说说redo log的三种状态： 红色：存在redo log buffer中，物理上是在MySQL进程内存中 黄色：写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面 绿色：持久化到磁盘，对应的是hard disk 为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参 数，它有三种可能取值: 0，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ; 1，表示每次事务提交时都将 redo log 直接持久化到磁盘; 2 ，表示每次事务提交时都只是把 redo log 写到 page cache。 InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写 到文件系统的 page cache，然后调用 fsync 持久化到磁盘。 实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。 121. redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时 候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。2. 并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁 盘。假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另 外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么 按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时 候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。 既然MySQL能保证redo log和binlog能可靠性写入磁盘，那么在他们两者直接如何保证可靠转换的呢？ 两阶段提交redo log 先 prepare，再写 binlog，最后再把 redo log commit。利用这个两阶段提交机制，MySQL保证了redo log和binlog的可靠传输。 最后我们来看下整体简图： 配置建议 innodb_flush_log_at_trx_commit=1。表示每次事务的redolog都直接持久化到磁盘，保证mysql重启后数据不丢失。 sync_binlog=1。表示每次事务的binlog都直接持久化到磁盘，保证mysql重启后binlog记录是完整的。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"MySQL主从","slug":"MySQL主从","date":"2020-03-17T13:46:08.000Z","updated":"2021-04-13T07:33:32.301Z","comments":true,"path":"2020/03/17/239/","link":"","permalink":"http://github.13sai.com/2020/03/17/239/","excerpt":"","text":"本文为极客时间专栏《MySQL实战45讲》笔记，文中部分图文来自该专栏。附上专栏链接，有兴趣可点击订阅：https://time.geekbang.org/column/intro/139 昨天的文章我们操作了主从复制，那么你有仔细想一想工作原理吗？ 主从同步复制原理复制简单分成三步： master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）； slave将master的binary log events拷贝到它的中继日志(relay log)； slave重做中继日志中的事件，将改变反映它自己的数据。 当然，其中的细节是很复杂的，我们可以看下极客时间《MySQL实战45讲》专栏的图： 主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。 而备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接。一个事务日志同步的完整过程是这样的： 在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。 在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。 主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。 备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。 sql_thread读取中转日志，解析出日志里的命令，并执行。 binlog里记录的是什么？那么介绍了工作原理，之前也有文章介绍过binlog，那么binlog里到底记录的是什么呢？ binlog根据配置记录的内容是不一样的，我们看表格： format 定义 优点 缺点 statement 记录的是修改SQL语句 日志文件小，节约IO，提高性能 准确性差，对一些系统函数不能准确复制或不能复制，如now()、uuid()等 row 记录的是每行实际数据的变更 准确性强，能准确复制数据的变更 日志文件大，较大的网络IO和磁盘IO mixed statement和row模式的混合 准确性强，文件大小适中 有可能发生主从不一致问题 推荐使用的是row模式，准确性高，虽然说文件大，但是现在有SSD和万兆光纤网络，这些磁盘IO和网络IO都是可以接受的。 mixed格式的意思是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。也就是说，mixed格式可以利用statment格式的优点，同时又避免了数据不一致的风险。那么，为什么不推荐使用mixed模式，我们可以举例说明（数据恢复）： 我们就分别从delete、insert和update这三种SQL语句的角度，来看看数据恢复的问题。 即使执行的是delete语句，row格式的binlog也会把被删掉的行的整行信息保存起来。所以，如果你在执行完一条delete语句以后，发现删错数据了，可以直接把binlog中记录的delete语句转成insert，把被错删的数据插入回去就可以恢复了。 如果你是执行错了insert语句呢？那就更直接了。row格式下，insert语句的binlog里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这时，你直接把insert语句转成delete语句，删除掉这被误插入的一行数据就可以了。 如果执行的是update语句的话，binlog里面会记录修改前整行的数据和修改后的整行数据。所以，如果你误执行了update语句的话，只需要把这个event前后的两行信息对调一下，再去数据库里面执行，就能恢复这个更新操作了。 其实，由delete、insert或者update语句导致的数据操作错误，需要恢复到操作之前状态的情况，也时有发生。 查看binlogbinlog本身是一类二进制文件。二进制文件更省空间，写入速度更快，是无法直接打开来查看的。因此mysql提供了命令mysqlbinlog进行查看。一般的statement格式的二进制文件，用下面命令就可以 1mysqlbinlog mysql-bin.000001 如果是row格式，加上-v或者-vv参数就行，如 1mysqlbinlog -vv mysql-bin.000001 配置参数 参数名 含义 log_bin = {on | off | base_name} 指定是否启用记录二进制日志或者指定一个日志路径 sql_log_bin ={ on | off } 指定是否启用记录二进制日志 expire_logs_days 指定自动删除二进制日志的时间，即日志过期时间 log_bin_index 指定mysql-bin.index文件的路径 binlog_format = { mixed | row | statement } 指定二进制日志基于什么模式记录 max_binlog_size 指定二进制日志文件最大值 binlog_cache_size 指定事务日志缓存区大小 max_binlog_cache_size 指定二进制日志缓存最大大小 sync_binlog = { 0 | n } 指定写缓冲多少次，刷一次盘 之前是介绍一些概念的东西，今天我们来换换口味，实际操作一下啊，操作内容是搭建我们经常用到的MySQL主从。 前提已经安装好了主数据库和从数据库，并新建database为test，假如一些数据。（因为是测试，单机器上开两个MySQL示例也可以） master123GRANT REPLICATION SLAVE, REPLICATION CLIENT ON . TO repl@&#x27;127.0.0.1&#x27; IDENTIFIED BY &#x27;111111&#x27;; //分配账号 grant all on . to repl@&#x27;127.0.0.1&#x27;; //授权 查看状态 12SHOW MASTER STATUS;//记住这里的file和position。 修改配置 123[mysqld] log-bin=mysql-bin server-id=1 重启 slave修改配置，注意server_id要与主库，其他从库不一样，可以设置成ip 123456[mysqld] log_bin = mysql-bin server_id = 2 relay_log = mysql-relay-bin log_slave_updates = 1 read_only = 1 重启后，建议先进行重置操作。 1reset slave 连接master 1CHANGE MASTER TO MASTER_HOST=&#x27;127.0.0.1&#x27;,MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;111111&#x27;, MASTER_LOG_FILE=&#x27;mysql-bin.000051&#x27;,master_log_pos=8694; master_log_file和master_log_pos就是上面记住的file和position，具体自行修改。 开启并查看状态 1start slave show slave status 如果Slave_IO_Running和Slave_SQL_Running都显示Yes，一般就成功了。 失败一般就是master_log_pos，master_log_file配置有问题，重新配置下就行了。 可以在master插入修改数据，测试slave是否相应变化。 注意如果master已有数据，可以锁定master（flush tables with read lock），然后导出同步到slave，配置完成后释放master（unlock tables）。 参考文章 【原创】研发应该懂的binlog知识(上) https://www.cnblogs.com/rjzheng/p/9721765.html","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"MySQL的count","slug":"MySQL的count","date":"2020-03-15T13:25:48.000Z","updated":"2020-12-09T10:45:31.615Z","comments":true,"path":"2020/03/15/237/","link":"","permalink":"http://github.13sai.com/2020/03/15/237/","excerpt":"","text":"本文为极客时间专栏《MySQL实战45讲》笔记，文中部分图文来自该专栏。 count(*)语句应该是我们开发中很经常用到的,n那么你有仔细研究过吗？ 实现方式 MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count()的时候会直接返回这个数，效率很高；如果加了where 条件的话，MyISAM表也是不能返回得这么快的。而InnoDB引擎就麻烦了，它执行count()的时候，需要把数据一行一行地从引擎里面读出来，然后判断not null累积计数。 那你就问了，为什么InnoDB不跟MyISAM一样，也把数字存起来呢？ 这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。 假设表t中现在有10000条记录，我们设计了三个用户并行的会话。 会话A先启动事务并查询一次表的总行数； 会话B启动事务，插入一行后记录后，查询表的总行数； 会话C先启动一个单独的语句，插入一行记录后，查询表的总行数。 我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。 你会看到，在最后一个时刻，三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不同。 这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。 当然，现在这个看上去笨笨的MySQL，在执行count(*)操作的时候还是做了优化的。 InnoDB支持的是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。 在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。 如果你用过show table status 命令的话，就会发现这个命令的输出结果里面也有一个TABLE_ROWS用于显示这个表当前有多少行，这个命令执行挺快的，那这个TABLE_ROWS能代替count(*)吗？ 而索引统计的值是通过采样来估算的，实际上，TABLE_ROWS就是从这个采样估算得来的，因此它也不是很准。有多不准呢，官方文档说误差可能达到40%到50%。所以，show table status命令显示的行数也不能直接使用。 MyISAM表虽然count(*)很快，但是不支持事务；show table status命令虽然返回很快，但是不准确；InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。 那么，如果你现在有一个页面经常要显示记录总数，到底应该怎么办呢？ 有时候，我们未必就只能纠结于count，我们可以自己额外计数。 计数方法缓存计数对于更新很频繁的库来说，你可能会第一时间想到，用缓存系统来支持，比如Redis。 我们可以用一个Redis服务来保存这个表的总行数，读和更新操作都很快。 当然，使用Redis存储计数是有一些问题的。 首先，无法保证Redis完全可用，假如异常挂掉，我们无法保证MySQL和Redis数据的一致性。 其次，即使Redis正常可用，计数也并不精确，因为MySQL和Redis存储必然有先后之分，在高并发场景下，多个会话从Redis和MySQL读到的数据很可能是不一致的，我们可以看看图片，就不展开说明了。 当然了，在某些场景下，我们可以这么做，因为业务并不要保证数据每时每刻都是精确的，那就无需考虑这些问题，Redis异常后我们可以从计算表行数去更新。 数据库计数我们也可以用MySQl新建一张表去计数。那么针对缓存计数的两个问题，我们来分析下： 首先，这解决了崩溃丢失的问题，InnoDB是支持崩溃恢复不丢数据的。 然后，我们再看看能不能解决计数不精确的问题。当然，我们有“事务”这个大杀器，可以保证数据一致性。 不同的count用法对比 count(主键id)：InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为null，就按行累加。 count(1)：InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为null，按行累加，显然这比上面的效率要高一些。 count(字段)：如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。 count()：是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count()肯定不是null，按行累加。 按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(*)，所以我建议你，尽量使用count(*)。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"MySQL的锁","slug":"MySQL的锁","date":"2020-03-14T13:52:16.000Z","updated":"2021-04-13T07:32:59.505Z","comments":true,"path":"2020/03/14/236/","link":"","permalink":"http://github.13sai.com/2020/03/14/236/","excerpt":"","text":"本文为极客时间专栏《MySQL实战45讲》笔记，文中部分图文来自该专栏。 锁是MySQL中经常用到的，根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。 全局锁顾名思义，全局锁就是对整个数据库实例加锁。 MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。 当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 典型使用场景是，做全库逻辑备份。 官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。 表锁MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。 表锁的语法是 lock tables … read/write。 与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。 举个例子, 如果在某个线程A中执行 lock tables t1 read, t2 write 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。 在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。 另一类表级的锁是MDL（metadata lock)。 MDL不需要显式使用，在访问一个表的时候会被自动加上。 MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。 因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。 虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。 行锁MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。 在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。 死锁 所谓死锁: 是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB. 当出现死锁以后，有两种策略： 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。 加锁规则加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。 原则1：加锁的基本单位是next-key lock，lock是前开后闭区间。 原则2：查找过程中访问到的对象才会加锁。 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"MySQL事务隔离","slug":"MySQL事务隔离","date":"2020-03-13T14:32:23.000Z","updated":"2021-04-13T07:33:14.609Z","comments":true,"path":"2020/03/13/235/","link":"","permalink":"http://github.13sai.com/2020/03/13/235/","excerpt":"","text":"本文为极客时间专栏《MySQL实战45讲》笔记，文中部分图文来自该专栏。 提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。 SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 123456我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。 查看隔离级别： show variables like ‘transaction_isolation’; 事务启动 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。 建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。 事务隔离的实现理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。 在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。 假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。 当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。 同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。 你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。 什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。 基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这事需要注意的。 相关语法12345678910111213START TRANSACTION [transaction_characteristic [, transaction_characteristic] ...]transaction_characteristic: &#123; WITH CONSISTENT SNAPSHOT | READ WRITE | READ ONLY&#125;BEGIN [WORK]COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]SET autocommit = &#123;0 | 1&#125; 这些语句提供对事务使用的控制 ： START TRANSACTION或 BEGIN开始新交易。 COMMIT 提交当前事务，使其更改永久生效。 ROLLBACK 回滚当前事务，取消其更改。 SET autocommit 禁用或启用当前会话的默认自动提交模式。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"MySQL中几个重要的日志","slug":"MySQL中几个重要的日志","date":"2020-03-12T07:24:48.000Z","updated":"2021-04-13T07:33:28.498Z","comments":true,"path":"2020/03/12/233/","link":"","permalink":"http://github.13sai.com/2020/03/12/233/","excerpt":"","text":"本文为极客时间专栏《MySQL实战45讲》笔记，文中部分图文来自该专栏。 几个日志的作用 重做日志（redo log）：确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。 回滚日志（undo log）：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），即非锁定读 二进制日志（binlog）：用于复制和备份，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。 也可基于时间点做数据库的的还原。 redo log在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。 具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。 另外，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。 write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。 write pos和checkpoint之间的是空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。 有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。 undo log在数据修改的时候，不仅记录了redo log，还记录了相对应的undo log，如果因为某些原因导致事务失败或回滚了，可以借助undo log进行回滚。 undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。 当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。 undo log是采用段(segment)的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。 另外，undo log也会产生redo log，因为undo log也要实现持久性保护。 binlogMySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。 我想你肯定会问，为什么会有两份日志呢？ 因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。 这两种日志有以下三点不同。 redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。 redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。 redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。 执行器生成这个操作的binlog，并把binlog写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。 这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。 参考文章：详细分析MySQL事务日志(redo log和undo log)-https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_14","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"MySQL执行流程说明","slug":"MySQL执行流程说明","date":"2020-03-11T07:24:48.000Z","updated":"2021-04-13T07:33:25.245Z","comments":true,"path":"2020/03/11/232/","link":"","permalink":"http://github.13sai.com/2020/03/11/232/","excerpt":"","text":"MySQL的执行流程示意图： 大体来说，MySQL可以分为Server层和存储引擎层两部分。 Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 而存储引擎层负责数据的存储和提取，常见的有InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，从MySQL 5.5.5版本开始它成为了默认存储引擎。 从图中不难看出，不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。 我们依次看下每个组件的作用。 连接器连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的： 1mysql -h $ip -P $port -u $user -p 输完命令之后，你就需要在交互对话里面输入密码。 连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。 如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。 如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要进行重连操作，然后再执行请求。 连接注意点： 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。 短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。 建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。 但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。 怎么解决这个问题呢？你可以考虑以下两种方案。 定期主动断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。 MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。 如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样： mysql&gt; select SQL_CACHE * from T where ID=10； 需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。 分析器如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。 分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。 MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。 做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。 如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。 123mysql&gt; elect * from t where id=1;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * from t where ID=1&#x27; at line 1 一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。 优化器经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。 优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。 执行器MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。 开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。 123mysql&gt; select * from T where ID=10;ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27; 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。 比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的： 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 至此，这个语句就执行完成了。 对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"ElementUI多图拖拽","slug":"ElementUI多图拖拽","date":"2020-02-27T01:33:48.000Z","updated":"2021-04-26T03:35:50.892Z","comments":true,"path":"2020/02/27/228/","link":"","permalink":"http://github.13sai.com/2020/02/27/228/","excerpt":"","text":"准备 yarn add vuedraggableornpm i -S vuedraggable 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257&lt;template&gt; &lt;div&gt; &lt;el-row style=&quot;margin-top: 20px;&quot;&gt; &lt;el-col :span=&quot;20&quot; :offset=&quot;2&quot;&gt; &lt;el-form-item label=&quot;预览&quot; prop=&quot;desc&quot;&gt; &lt;div class=&quot;image-list&quot;&gt; &lt;draggable v-model=&quot;showImgList&quot; @change=&quot;dragChange&quot;&gt; &lt;div v-for=&quot;(image, index) in showImgList&quot; :key=&quot;index&quot; class=&quot;image-wrap&quot;&gt; &lt;img :src=&quot;image&quot; :style=&quot;imgStyle&quot; /&gt; &lt;div class=&quot;icon-wrap&quot; @click.stop=&quot;removeFile(index)&quot;&gt; &lt;i class=&quot;el-icon-delete&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;el-upload ref=&quot;imageListUpload&quot; :action=&quot;$uploadPicUrl&quot; :headers=&quot;header&quot; :before-upload=&quot;beforeUpload&quot; :on-success=&quot;uploadSuccess&quot; class=&quot;image-uploader&quot; :on-error=&quot;onError&quot; multiple :show-file-list=&quot;false&quot; accept=&quot;image/*&quot;&gt; &lt;i :class=&quot;loading ? &#x27;el-icon-loading&#x27; : &#x27;el-icon-plus&#x27;&quot; :style=&quot;imgStyle&quot;&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/draggable&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.ql-container .ql-editor&#123; height:400px;&#125;.avatar-uploader .el-upload &#123; height: 180px; width: 180px; overflow: hidden;&#125;.avatar-uploader img &#123; height: 180px; width: 180px;&#125;.avatar-uploader .avatar-uploader-icon &#123; border: 1px dashed #d9d9d9; border-radius: 6px; cursor: pointer; font-size: 28px; color: #8c939d; width: 178px; height: 178px; line-height: 178px; text-align: center;&#125;#video .video &#123; max-width: 300px; max-height: 200px;&#125;.avatar &#123; width: 178px; height: 178px; display: block;&#125;.avatar-uploader img &#123; height: 180px; width: 180px;&#125;.ql-editor&#123; height:400px;&#125;.ql-snow .ql-picker &#123; height: auto;&#125;.image-list,.image-item &#123; display: flex;&#125;.image-list .image-wrap,.image-item .image-wrap &#123; position: relative; display: inline-block; box-sizing: content-box; margin: 0 8px 8px 0; vertical-align: top;&#125;.image-list .image-wrap:hover .icon-wrap,.image-item .image-wrap:hover .icon-wrap &#123; opacity: 1;&#125;.image-list .image-wrap .icon-wrap,.image-item .image-wrap .icon-wrap &#123; position: absolute; left: 0; bottom: 0; width: 100%; height: 30px; cursor: default; text-align: center; color: #fff; opacity: 0; font-size: 20px; background-color: rgba(0, 0, 0, 0.7); transition: opacity .3s;&#125;.image-list .image-wrap .icon-wrap .el-icon-zoom-in,.image-item .image-wrap .icon-wrap .el-icon-zoom-in &#123; cursor: pointer; margin-right: 8px;&#125;.image-list .image-wrap .icon-wrap .el-icon-delete,.image-item .image-wrap .icon-wrap .el-icon-delete &#123; cursor: pointer;&#125;.image-item &#123; display: inline-flex;&#125;.image-uploader &#123; display: inline-block;&#125;.image-uploader .el-upload &#123; border: 1px dashed #d9d9d9; border-radius: 6px; cursor: pointer; position: relative; overflow: hidden;&#125;.image-uploader .el-upload [class^=&quot;el-icon&quot;] &#123; font-size: 28px; color: #8c939d; text-align: center;&#125;.image-uploader .el-upload:hover &#123; border-color: #409EFF;&#125;&lt;/style&gt;&lt;script&gt;import draggable from &#x27;vuedraggable&#x27;export default &#123; components: &#123; draggable, &#125;, data() &#123; return &#123; showImgList: [], loading: false, &#125; &#125;, created() &#123; if (this.$route.params.id &gt; 0) &#123; this.getInfo(this.$route.params.id) this.goodsForm.id = this.$route.params.id; &#125; else &#123; this.responseVisible = false; &#125; &#125;, computed: &#123; imgStyle() &#123; return &#123; width: &#x27;180px&#x27;, height: &#x27;180px&#x27;, lineHeight: &#x27;180px&#x27;, &#125; &#125; &#125;, mounted() &#123; // 为图片ICON绑定事件 getModule 为编辑器的内部属性 // this.$refs.myQuillEditor.quill.getModule(&#x27;toolbar&#x27;).addHandler(&#x27;image&#x27;, this.imgHandler) // this.$refs.myQuillEditor.quill.getModule(&#x27;toolbar&#x27;).addHandler(&#x27;video&#x27;, this.insertVideo) // 为视频ICON绑定事件 &#125;, methods: &#123; beforeUpload(file) &#123; if (file.type.split(&#x27;/&#x27;)[0] === &#x27;image&#x27;) &#123; let tempSize = file.size / 1024 / 1024 / 2; if (tempSize &gt; 1) &#123; this.$message.error(&#x27;图片尺寸不得大于2M！&#x27;); return false; &#125; &#125; else &#123; this.$message.error(&#x27;请上传图片格式（jpg、png、gif）&#x27;); return false; &#125; &#125;, getInfo(id) &#123; var _self = this; projectInfo(id).then(function(res)&#123; _self.goodsForm = res.data.data; _self.goodsForm.start_time = timestampToDate(_self.goodsForm.start_time); _self.goodsForm.over_time = timestampToDate(_self.goodsForm.over_time); _self.showImgList = _self.goodsForm.desc.split(&quot;|&quot;); _self.responseVisible = false; &#125;).catch(function(error)&#123; console.log(error); &#125;) &#125;, handleRemove(file, fileList) &#123; console.log(file, fileList); &#125;, uploadSuccess(response, file, fileList) &#123; try &#123; for (let fileInfo of fileList) &#123; if (this.type === &#x27;image&#x27;) &#123; this.imgUrl = response.key this.$emit(&#x27;update:data&#x27;, response.key) &#125; else &#123; if (this.showImgList.length &gt;= this.limit) &#123; // 限制图片张数 this.showImgList.length = this.limit throw(new Error(`最多上传 $&#123;this.limit&#125; 张图片`)) &#125; this.showImgList.push(response.data.filepath) this.$emit(&#x27;update:data&#x27;, this.showImgList) &#125; &#125; &#125; catch (error) &#123; this.$message.error(error.message) &#125; finally &#123; this.loading = false this.$refs.imageListUpload &amp;&amp; this.$refs.imageListUpload.clearFiles() this.$refs.imageUpload &amp;&amp; this.$refs.imageUpload.clearFiles() &#125; &#125;, removeFile(index) &#123; this.$confirm(&#x27;确定删除该图片吗?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; if (this.type === &#x27;image&#x27;) &#123; this.$emit(&#x27;update:data&#x27;, typeof this.data === &#x27;object&#x27; ? &#123;&#125; : &#x27;&#x27;) &#125; else &#123; this.showImgList.splice(index, 1) this.$emit(&#x27;update:data&#x27;, this.showImgList) &#125; &#125;) &#125;, onError() &#123; this.$message.error(&#x27;上传文件失败&#x27;) &#125;, dragChange(ele) &#123; console(ele.moved) &#125;, handleRemove(file, fileList) &#123; let imgList = fileList.map(item =&gt; &#123; return item.response.key &#125;) this.$emit(&#x27;update:data&#x27;, imgList) &#125;, &#125;&#125;&lt;/script&gt; 注意务必注册引入组件 12345678import draggable from &#x27;vuedraggable&#x27;export default &#123; ... components: &#123; draggable, &#125;, ...","categories":[{"name":"vue","slug":"vue","permalink":"http://github.13sai.com/categories/vue/"}],"tags":[{"name":"ElementUI","slug":"ElementUI","permalink":"http://github.13sai.com/tags/ElementUI/"}]},{"title":"系列文章---应用篇：2.延时任务","slug":"系列文章-应用篇：2-延时任务","date":"2020-02-22T06:35:57.000Z","updated":"2021-04-26T03:43:55.127Z","comments":true,"path":"2020/02/22/244/","link":"","permalink":"http://github.13sai.com/2020/02/22/244/","excerpt":"","text":"git项目地址 PHP DIY系列–一起手写一个api框架 延时任务有别于定时任务，定时任务往往是固定周期的，有明确的触发时间。而延时任务一般没有固定的开始时间，它常常是由一个事件触发的，而在这个事件触发之后的一段时间内触发另一个事件。 我们不妨来设定一个实际的场景，电商系统下单成功之后如果15分钟未支付成功，就系统自动取消订单。 我们先来实现代码，然后再来详细说明： 1234567891011121314151617181920212223242526272829303132333435363738394041// 我们定义一个abstract，定义两个方法，startAfter和startAt&lt;?phpabstract class DelayTask&#123; const DELAY_TASK = &#x27;delayTask&#x27;; /** * 延时时间，在触发时间后多久执行 * @param $pushDelayTime */ public function startAfter(int $pushDelayTime) &#123; RedisManager::getRedis()-&gt;zAdd(self::DELAY_TASK, time() + $pushDelayTime, serialize($this)); &#125; /** * 定时时间，在未来某时刻执行 * @param $pushDelayAt */ public function startAt(int $pushDelayAt) &#123; RedisManager::getRedis()-&gt;zAdd(self::DELAY_TASK, $pushDelayAt, serialize($this)); &#125; abstract function run();&#125;class TestDelayTask extends DelayTask&#123; public function __construct($id) &#123; $this-&gt;id = $id; &#125; public function run() &#123; $file = &#x27;text.txt&#x27;;//要写入文件的文件名（可以是任意文件名），如果文件不存在，将会创建一个 $content = &quot;写入的内容&quot;.time().&quot;\\n&quot;; if($f = file_put_contents($file, $content,FILE_APPEND))&#123;// 这个函数支持版本(PHP 5) echo &quot;写入成功。&lt;br /&gt;&quot;; &#125; &#125;&#125; RedisManager是封装的一个单例模式实现的redis类，我们也贴出代码，然后再对上面的代码做一些说明。 12345678910111213141516171819202122232425262728293031&lt;?phpclass RedisManager&#123; private static $instance = null; private function __construct() &#123; self::$instance = new \\Redis(); $config = require &#x27;redis.config.php&#x27;; self::$instance-&gt;connect($config[&#x27;host&#x27;], $config[&#x27;port&#x27;], $config[&#x27;timeout&#x27;]); if (isset($config[&#x27;password&#x27;])) &#123; self::$instance-&gt;auth($config[&#x27;password&#x27;]); &#125; &#125; /** * 获取静态实例 */ public static function getRedis() &#123; if (!self::$instance) &#123; new self; &#125; return self::$instance; &#125; /** * 禁止clone */ private function __clone() &#123; &#125;&#125; 有序集合1234567891011121314redis 127.0.0.1:6379&gt; ZADD saif 1 redis(integer) 1redis 127.0.0.1:6379&gt; ZADD saif 2 mongodb(integer) 1redis 127.0.0.1:6379&gt; ZADD saif 4 mysql(integer) 0redis 127.0.0.1:6379&gt; ZRANGE saif 0 10 WITHSCORES1) &quot;redis&quot;2) &quot;1&quot;3) &quot;mongodb&quot;4) &quot;2&quot;5) &quot;mysql&quot;6) &quot;4&quot; 如果你有redis可视化工具，你会发现有序集合存储的结构是这样： row value score 1 redis 1 2 mongodb 2 3 mysql 4 我们再来看一下代码，我们使用时间戳作为分值，使用对象作为值，存储到Redis有序集合。 file_put_contents ( string $filename , mixed $data [, int $flags = 0 [, resource $context ]] ) : int — 将一个字符串写入文件 执行12345678我们先尝试写入任务：(new TestDelayTask(4))-&gt;startAfter(900);(new TestDelayTask(4))-&gt;startAfter(120);(new TestDelayTask(4))-&gt;startAfter(600);(new TestDelayTask(3))-&gt;startAt(158120384);(new TestDelayTask(3))-&gt;startAt(158420380);(new TestDelayTask(3))-&gt;startAt(158120900); 执行代码： 12345678910111213141516171819202122232425262728class DelayTaskTask&#123; const QueneName = &#x27;delayTask&#x27;; private $currentTime; private $once = 5; public function run() &#123; $this-&gt;currentTime = time(); error_reporting(error_reporting() &amp; ~E_WARNING); while (true) &#123; // 每次取出5条 $list = RedisManager::getRedis()-&gt;zRange(self::QueneName, 0, $this-&gt;once, true); if (!empty($list)) &#123; foreach ($list as $val=&gt;$score) &#123; if ($score &lt; $this-&gt;currentTime) &#123; unserialize($val)-&gt;run(); RedisManager::getRedis()-&gt;zDelete(self::QueneName, $val); &#125; else &#123; break 2; &#125; &#125; &#125; else &#123; break; &#125; &#125; &#125;&#125;(new DelayTaskTask())-&gt;run(); 我们可以设置一个定时任务，每分钟执行一次上述代码。 我们执行之后，会发现一旦过了我们设定的时间，text.txt就不断有文字写入了。 代码比较杂，我有一个demo代码，大家可以查看。 DelayTask-基于redis的延时任务 这样，我们就利用Redis有序集合，完成了一个很基础的延时任务。 问题 加入run方法代码执行时间过长，一分钟执行一次有什么问题吗？ 每分钟执行一次，间隔有点长，能不能优化呢？","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---应用篇：1.分布式锁","slug":"系列文章-应用篇：1-分布式锁","date":"2020-02-22T02:35:57.000Z","updated":"2020-12-09T10:38:34.830Z","comments":true,"path":"2020/02/22/243/","link":"","permalink":"http://github.13sai.com/2020/02/22/243/","excerpt":"","text":"git项目地址 PHP DIY系列–一起手写一个api框架 含义 为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。 分析 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行 高可用的获取锁与释放锁 高性能的获取锁与释放锁 具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误） 具备锁失效机制，防止死锁 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败 实现方式常见的有： 基于Redis 基于mysql 基于Zookeeper 具体实现考虑到我们使用的PHP语言，简单结合Redis来实现一下分布式锁。 我们来画个简单的原理图： 原理十分简单，那么我们如何实现呢？ 这里我们用到两个知识点： Redis的setnx方法 php的register 12345678910111213function processLock($redis, $key, $ttl = 5)&#123; $ret = $redis-&gt;setnx($key, 1); if ($ret) &#123; $redis-&gt;expire($key, $ttl); register_shutdown_function(function () use ($redis, $key)&#123; $redis-&gt;del($key); &#125;); &#125; return $ret;&#125; demo里的$redis是一个redis实例，我们在前面已经实现过，不多说明。 加锁我们使用的setnx命令，senx表示“SET if Not eXists”，如果key不存在，则set，如果存在，则不set 123456redis&gt; SETNX mykey &quot;Hello&quot;(integer) 1redis&gt; SETNX mykey &quot;World&quot;(integer) 0redis&gt; GET mykey&quot;Hello&quot; 解锁使用的是del，即删除这个key。这里结合了 register_shutdown_function — 注册一个会在php中止时执行的函数，设置了之后我们就可以不必手动去解锁 锁超时这里给锁加了一个expire过期时间5秒，目的是防止使用这个方法之后的执行了“神奇”代码抛出了语法错误，导致register_shutdown_function里的代码没有执行，虽然请求结束，但是加锁后，没有解锁，影响了后续请求。 问题 加入setnx之后expire之前程序异常了怎么办？","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---框架篇：9.设计模式","slug":"系列文章-框架篇：9-设计模式","date":"2020-02-16T07:35:57.000Z","updated":"2020-12-09T10:38:30.501Z","comments":true,"path":"2020/02/16/242/","link":"","permalink":"http://github.13sai.com/2020/02/16/242/","excerpt":"","text":"git项目地址 PHP DIY系列–一起手写一个api框架 框架的开发基本结束了，这一节我们来探讨一下设计模式。 谈设计模式，首先要来简单聊聊面向对象。 面向对象 面向对象程序设计（Object-Oriented Programming, OOP）是一种程序设计范型，同时也是一种程序开发方法。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和可扩展性。它和面向过程、函数式编程被称为编程语言中的三大范式。 概念知识 面向对象的核心思想是对象、封装、可重用性、可扩展性。 面向对象三要素：封装、继承和多态。 面向对象设计的五大原则：单一职责原则、接口隔离原则、开放封闭原则、替换原则、依赖倒置原则。 关于这些概念的更详细解释，我推荐大家阅读《PHP核心技术与最佳实践》这本书关于关于面向对象的部分。 设计模式上述所述的面向对象知识，尤其是面向对象设计的五大原则，是诸多设计模式的基础。 设计模式有很多，我们可以简单列出来： 有强调实例化过程的创建型设计模式 抽象工厂 生成器 工厂方法 原型 单例 又有组合对象和类构成更大结构的结构型设计模式 适配器模式 桥接模式 组合模式 装饰器模式 外观模式 享元模式 代理模式 还有行为型设计模式 职责链模式 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 模板授权模式 访问者模式 说到这里你有没有蒙圈？ 其实我们无需一下子去了解那么多设计模式，在实际开发过程中我们可能也是混合使用设计模式的。我们不妨可以就框架里用到的几个典型的设计模式做一些分析。 单例模式是否还记得我们使用Redis代替Session那一节，我们就用到了单例模式。 我们来简化一下代码： 123456789101112131415161718class RedisSession&#123; private $redis; private function getRedisInstance() &#123; if (empty($this-&gt;redis)) &#123; $redis = new \\Redis(); $redis-&gt;connect($this-&gt;_config[&#x27;host&#x27;], $this-&gt;_config[&#x27;port&#x27;], $this-&gt;_config[&#x27;timeout&#x27;]); if (!$this-&gt;_config[&#x27;auth&#x27;]) &#123; $redis-&gt;auth($this-&gt;_config[&#x27;auth&#x27;]); &#125; $this-&gt;redis = $redis; &#125; return $this-&gt;redis; &#125;&#125; 一般我们还会在类里面加入一个魔术方法__clone，防止实例创建后被clone 单例模式有显而易见的优点：提高可重用性，减少开销。框架里使用Redis时都可以使用此方法来获取redis，也减少redis的连接数和多次连接时间。 策略模式还记得依赖注入那一节么，我们举例的那个Travel就是一个很好的策略模式Demo： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061interface Travel&#123; public function travelAlgorithm();&#125;/** *具体策略类(ConcreteStrategy) *1：乘坐飞机 */class AirPlanelStrategy implements Travel&#123; public function travelAlgorithm() &#123; echo&quot;travelbyAirPlain\\r\\n&quot;; &#125;&#125;/** *具体策略类(ConcreteStrategy) *2：乘坐火车 */class TrainStrategy implements Travel&#123; public function travelAlgorithm() &#123; echo&quot;travelbyTrain\\r\\n&quot;; &#125;&#125;/** * *环境类(Context): *用一个ConcreteStrategy对象来配置。 *维护一个对Travel对象的引用。可定义一个接口来让Strategy访问它的数据。 *算法解决类，以提供客户选择使用何种解决方案： */class PersonContext&#123; private $strategy = null; public function __construct(Travel $travel) &#123; $this-&gt;strategy=$travel; &#125; /** *旅行 */ public function travel() &#123; return$this-&gt;strategy-&gt;travelAlgorithm(); &#125;&#125;// 乘坐火车旅行$person = new PersonContext(new TrainStrategy());$person-&gt;travel();// 改乘飞机$person =PersonContext(new AirPlanelStrategy());$person-&gt;travel(); 策略模式降低了代码耦合度，可以使得我们下层代码依赖上层，替换下层代码即可简单实现功能的替换。 工厂方法我们在路由解析创建控制器那里使用了工厂方法，只不过与路由解析代码糅合在一起，我们简化一下： 123456789101112131415class Factory&#123; public function createController($controllerName) &#123; $controllerName = rtrim($controllerName,&#x27;\\\\&#x27;).&#x27;Controller&#x27;; if (!class_exists($controllerName)) &#123; throw new NotFoundException(&quot;未找到控制器&quot;); &#125; return new $controllerName; &#125; ···&#125; 工厂方法是很常见的一种设计模式，像Model经常能用到。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---框架篇：8.依赖注入与控制反转","slug":"系列文章-框架篇：8-依赖注入与控制反转","date":"2020-02-15T04:35:57.000Z","updated":"2020-12-09T10:38:26.592Z","comments":true,"path":"2020/02/15/241/","link":"","permalink":"http://github.13sai.com/2020/02/15/241/","excerpt":"","text":"git项目地址 PHP DIY系列–一起手写一个api框架 依赖倒置原则（Dependence Inversion Principle）DIP是面向对象设计原则之一。传统软件设计中，上层代码依赖于下层代码，当下层出现变动时， 上层代码也要相应变化，维护成本较高。而DIP的核心思想是上层定义接口，下层实现这个接口， 从而使得下层依赖于上层，降低耦合度，提高整个系统的弹性。这是一种经实践证明的有效策略。 控制反转（Inversion of Control）IoC则是DIP的一种具体思路，DIP只是一种理念、思想，而IoC是一种实现DIP的方法。 IoC的核心是将类（上层）所依赖的单元（下层）的实例化过程交由第三方来实现。 当调用者需要被调用者的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例，但在这里，创建被调用者的工作不再由调用者来完成，而是将被调用者的创建移到调用者的外部，从而反转被调用者的创建，消除了调用者对被调用者创建的控制，因此称为控制反转。 依赖注入（Dependence Injection）DI是IoC的一种设计模式，按照DI的模式，就可以实现IoC。 DI的实质就是把一个类不可能更换的部分和可更换的部分分离开来，通过注入的方式来使用，从而达到解耦的目的。 这里我们举个例子（旅行的接口）说明一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657interface Travel&#123; public function travelAlgorithm();&#125;/** *乘坐飞机 */class AirPlanelStrategy implements Travel&#123; public function travelAlgorithm() &#123; echo&quot;travelbyAirPlain\\r\\n&quot;; &#125;&#125;/** *乘坐火车 */class TrainStrategy implements Travel&#123; public function travelAlgorithm() &#123; echo&quot;travelbyTrain\\r\\n&quot;; &#125;&#125;/** * *算法解决类，以提供客户选择使用何种解决方案： */class PersonContext&#123; private $strategy = null; public function __construct(Travel $travel) &#123; $this-&gt;strategy=$travel; &#125; /** *旅行 */ public function travel() &#123; return$this-&gt;strategy-&gt;travelAlgorithm(); &#125;&#125;// 乘坐火车旅行$person = new PersonContext(new TrainStrategy());$person-&gt;travel();// 改乘飞机$person =PersonContext(new AirPlanelStrategy());$person-&gt;travel(); 当我们更换交通工具时，只需要去增加Travel接口的实现，修改下实现的代码接口，无需去改动核心代码。 控制反转容器（IoC Container）当项目比较大时，依赖关系可能会十分复杂。 而IoC Container提供了动态地创建、注入依赖单元，映射依赖关系等功能，方便开发者使用，并大大缩减了许多代码量。 因为我们的框架比较简单，我们不妨实现下Ioc容器(主要参考了Yii的di容器)。 代码实现用到了PHP的反射Api，有疑问的不妨先看看手册： PHP反射 还记得PSR吗？PSR11是关于依赖注入容器接口规范： 然后我们利用composer执行 composer require psr/container 我们在library/Components新建Container实现ContainerInterface，在library/Exceptions下新建ContainerException实现Psr\\Container\\ContainerExceptionInterface，新建ContainerNotFoundException实现Psr\\Container\\NotFoundExceptionInterface。 我们主要来实现一下Container代码，我们预先定义三个属性，用以保存对象、依赖及依赖的定义信息。 123456789101112131415161718192021222324252627282930&lt;?phpnamespace Library\\Components;use Library\\Exceptions\\ContainerException;use Library\\Exceptions\\ContainerNotFoundException;use Psr\\Container\\ContainerInterface;use ReflectionClass;class Container implements ContainerInterface&#123; // 用于保存依赖的定义，以对象名称为键 private $definitions = []; // 用于缓存ReflectionClass对象，以对象名称为键 private $reflections = []; // 用于缓存依赖信息，以对象名称为键 private $dependencies = []; public function has($class) &#123; return isset($this-&gt;definitions[$class]); &#125; public function get($class) &#123; ... &#125;&#125; 我们先添加一个set方法，用以定义， 1234567891011121314151617181920212223242526272829303132public function set($class, $definition = [])&#123; $this-&gt;definitions[$class] = $this-&gt;normalizeDefinition($class, $definition); return $this;&#125;protected function normalizeDefinition($class, $definition)&#123; // $definition 是空的转换成 [&#x27;class&#x27; =&gt; $class] 形式 if (empty($definition)) &#123; return [&#x27;class&#x27; =&gt; $class]; // $definition 是字符串，转换成 [&#x27;class&#x27; =&gt; $definition] 形式 &#125; elseif (is_string($definition)) &#123; return [&#x27;class&#x27; =&gt; $definition]; // $definition 是对象，则直接将其作为依赖的定义 &#125; elseif (is_object($definition)) &#123; return $definition; // $definition 是数组则确保该数组定义了 class 元素 &#125; elseif (is_array($definition)) &#123; if (!isset($definition[&#x27;class&#x27;])) &#123; $definition[&#x27;class&#x27;] = $class; &#125; return $definition; // 这也不是，那也不是，那就抛出异常算了 &#125; else &#123; throw new ContainerException( &quot;不支持的类型： \\&quot;$class\\&quot;: &quot; . gettype($definition)); &#125;&#125; 知识点： gettype — 获取变量的类型 然后我们重点实现get方法： 1234567891011121314151617181920212223242526public function get($class)&#123; // 加入未作set操作，我们依旧可以构建 if (!isset($this-&gt;definitions[$class])) &#123; return $this-&gt;build($class); &#125; $definition = $this-&gt;definitions[$class]; if (is_array($definition)) &#123; $concrete = $definition[&#x27;class&#x27;]; unset($definition[&#x27;class&#x27;]); if ($concrete === $class) &#123; $object = $this-&gt;build($class, $definition); &#125; else &#123; $object = $this-&gt;get($concrete); &#125; &#125; elseif (is_object($definition)) &#123; return $this-&gt;_singletons[$class] = $definition; &#125; else &#123; throw new ContainerNotFoundException(&#x27;不能识别的对象类型: &#x27; . gettype($definition)); &#125; return $object;&#125; build方法如下，主要是构建出对象并实现注入， 1234567891011121314151617public function build($class, $params = [])&#123; try &#123; // 通过反射api获取对象 $reflector = $this-&gt;getReflectionClass($class); // 获取依赖关系数组 $dependencies = $this-&gt;getDependencies($class, $reflector); // 创建一个类的新实例,给出的参数将传递到类的构造函数. $reflector = $reflector-&gt;newInstanceArgs($dependencies); return $reflector; &#125; catch (\\Throwable $t) &#123; throw new ContainerException(&#x27;反射出错&#x27;); &#125;&#125; 获取对象： 12345678910111213public function getReflectionClass($class)&#123; if (isset($this-&gt;reflections[$class])) &#123; return $this-&gt;reflections[$class]; &#125; $reflector = new ReflectionClass($class); if (!$reflector-&gt;isInstantiable()) &#123; throw new ContainerException(&quot;不能实例化&quot;.$class); &#125; return $this-&gt;reflections[$class] = $reflector;&#125; 获取依赖关系： 1234567891011121314151617181920212223242526272829303132333435363738394041public function getDependencies($class, $reflector)&#123; // 判断是否有缓存依赖关系 if (isset($this-&gt;dependencies[$class])) &#123; return $this-&gt;dependencies[$class]; &#125; $constructor = $reflector-&gt;getConstructor(); #如果没有构造函数， 直接实例化并返回 if (is_null($constructor)) &#123; return $this-&gt;dependencies[$class] = []; &#125; $parameters = $constructor-&gt;getParameters(); $dependencies = []; foreach ($parameters as $className) &#123; $dependency = $className-&gt;getClass(); if (is_null($dependency)) &#123; $dependencies[] = $this-&gt;resolveNoneClass($className); &#125; else &#123; // 先取出容器中绑定的类 否则自动绑定 $dependencies[] = $this-&gt;get($dependency-&gt;getName()); &#125; &#125; $this-&gt;dependencies[$class] = $dependencies; return $dependencies;&#125;public function resolveNoneClass($class)&#123; // 有默认值则返回默认值 if ($class-&gt;isDefaultValueAvailable()) &#123; return $class-&gt;getDefaultValue(); &#125; throw new ContainerException(&#x27;不能解析参数&#x27;);&#125; 到这里，我们基本就完成了一个完整的IOC Container的代码。 我们来写一个demo： 12345678&lt;?phpnamespace App\\Https\\Controllers;class C&#123;&#125; 1234567891011&lt;?phpnamespace App\\Https\\Controllers;class B&#123; public function __construct(C $c) &#123; $this-&gt;ccc = $c; &#125;&#125; 123456789101112&lt;?phpnamespace App\\Https\\Controllers;class A&#123; public function __construct(B $b, C $c) &#123; $this-&gt;bbb = $b; $this-&gt;ccc = $c; &#125;&#125; 12345678910111213141516&lt;?phpnamespace App\\Https\\Controllers;use Library\\Components\\Container;use Library\\Https\\Controller;class IndexController extends Controller&#123; public function index() &#123; $contain = new Container(); $contain-&gt;set(&#x27;App\\\\Https\\\\Controllers\\\\A&#x27;); p($contain-&gt;get(&#x27;App\\\\Https\\\\Controllers\\\\A&#x27;)); &#125;&#125; 我们可以看到的结果： 是不是代码简洁很多了，不愿因为需要创建一个A对象，而先去实例化B和C，这些都是由我们完成的IOC Container去实现了。 总结这一节我们实现了IOC容器，然而你如果仔细去想，我们会发现我们可以让容器更加强大，比如单例对象的实现，比如依赖的扩展（兼容对象参数注入，数组参数注入等）。这些你可以自行实现，我也在源代码做了简单的扩展，大家可以思考试着实现一下，当然也可以看看开源框架Laravel、Yii的服务容器的实现。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---框架篇：7.使用redis加速session读写","slug":"系列文章-框架篇：7-使用redis加速session读写","date":"2020-02-15T03:15:52.000Z","updated":"2020-12-09T10:38:22.155Z","comments":true,"path":"2020/02/15/240/","link":"","permalink":"http://github.13sai.com/2020/02/15/240/","excerpt":"","text":"git项目地址 PHP DIY系列–一起手写一个api框架 大家都知道，默认的session是存储在文件里的，一般情况下这是没什么问题的，然而一旦访问很多，session的使用就会频繁读写文件，必然会影响应用的性能。另外，假如是多机部署，session的共享也是个问题。 既然我们知道有Redis这个利器，而PHP也是支持session自定义的，那么为何不要性能更好又能实现共享session的Redis呢？ Redis是什么？Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key - value 数据库 Redis数据结构 string hash set sorted set pub/sub list 另外还有HyperLogLog，geo…. Redis的优势 性能极佳，官网显示QPS能达到100k/s 数据结构丰富，不止于字符串，hash 稳定性不错，持久化 支持集群 社区不错，使用率高，对于PHP程序员，除了LNMP/LAMP，然后应该就是Redis了 Redis应用 缓存 分布式锁 计数器 队列 geo …… Redis命令 点击查看Redis命令 使用redis存储session我介绍两种方法给大家： session_start带参 session_set_save_handler托管session 下面我们里一一说明： session_startsession_start ([ array $options = array() ] ) : bool —— 启动新会话或者重用现有会话（点击查看更多参数） 来看demo： 123456789session_start([ &#x27;save_path&#x27; =&gt; &#x27;tcp://127.0.0.1:6379&#x27;, &#x27;save_handler&#x27; =&gt; &#x27;redis&#x27;,]);$_SESSION[&#x27;user_id&#x27;] = 10001;$_SESSION[&#x27;userInfo&#x27;] = [&#x27;name&#x27; =&gt; &#x27;sai&#x27;];p($_SESSION[&#x27;user_id&#x27;]);p($_SESSION[&#x27;userInfo&#x27;]); 输出如下： 10001 Array ( [name] => sai ) 我们可以使用redis-cli连接查看： redis-cli -h 127.0.0.1 -p 6379// 如设置密码再输入（auth 你设置的密码）即可 我们可以看到redis里有了PHPREDIS_SESSION:nmo65igogqnq8ur2gia94jt15u，里面存储了我们的session信息。 session_set_save_handler建议session.serialize_handler = php_serialize，默认php写入和读取略微繁琐。 这里说明我们成功了将session信息通过Redis进行了读写。下面我们使用session_set_save_handler来实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phpnamespace Library\\Sessions;use SessionHandler;class RedisSession extends SessionHandler&#123; private $redis; private $lifeTime = 7200; private $config; private $prefix = &#x27;PHPREDIS_SESSION:&#x27;; public function __construct($config) &#123; $this-&gt;config = $config; &#125; private function getRedisInstance() &#123; if (empty($this-&gt;redis)) &#123; $redis = new \\Redis(); $redis-&gt;connect($this-&gt;config[&#x27;host&#x27;], $this-&gt;config[&#x27;port&#x27;], $this-&gt;config[&#x27;timeout&#x27;]); if (!$this-&gt;config[&#x27;auth&#x27;]) &#123; $redis-&gt;auth($this-&gt;config[&#x27;auth&#x27;]); &#125; $this-&gt;redis = $redis; &#125; return $this-&gt;redis; &#125; public function read($id) &#123; return $this-&gt;getRedisInstance()-&gt;get($this-&gt;prefix.$id); &#125; public function write($id, $data) &#123; if ($this-&gt;getRedisInstance()-&gt;setex($this-&gt;prefix.$id, $this-&gt;lifeTime, $data)) &#123; return true; &#125; return false; &#125; public function destroy($id) &#123; if($this-&gt;getRedisInstance()-&gt;delete($id))&#123;//删除redis中的指定记录 return true; &#125; return false; &#125; public function gc($maxlifetime) &#123; return true; &#125; public function __destruct() &#123; session_write_close(); &#125;&#125;$handler = new RedisSession([ &#x27;host&#x27; =&gt; &#x27;127.0.0.1&#x27;, &#x27;port&#x27; =&gt; 6379, &#x27;auth&#x27; =&gt; null, &#x27;timeout&#x27; =&gt; 5, ]);session_set_save_handler($handler, true);session_start();$_SESSION[&#x27;user_id&#x27;] = 10001;$_SESSION[&#x27;userInfo&#x27;] = [&#x27;name&#x27; =&gt; &#x27;sai&#x27;];p($_SESSION[&#x27;user_id&#x27;]);p($_SESSION[&#x27;userInfo&#x27;]); 知识点： 这里需要注意下read方法，里面需要加一下serialize，以便于我们存储复杂的session结构。如果不加会报错（Warning: session_start(): Failed to read session data: user (path: )）这是因为Redis无法直接存储array结构，需要转化为string类型存储。 我们也来看看Redis客户端存储情况： 通用我们也看到redis存储了session，与前面略有不同的只是存储的key不一样。但是我们可以定义一个私有属性： private $prefix = ‘PHPREDIS_SESSION:’; 然后做一下调整即可： 12345678910111213public function read($id)&#123; return serialize($this-&gt;getRedisInstance()-&gt;get($this-&gt;prefix.$id));&#125;public function write($id,$data)&#123; if ($this-&gt;getRedisInstance()-&gt;setex($this-&gt;prefix.$id, $this-&gt;lifeTime, $data)) &#123; return true; &#125; return false;&#125; 运行后会发现把之前第一种设置的session覆盖掉。 当然我比较建议使用第二种方法，便于我们定制化编码。 总结总的来说，两种方法配置都比较简单，个人建议使用第二种方式实现，这样也比较适合集成到框架，后期我们可以在进行扩展。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---框架篇：6.简单测试","slug":"系列文章-框架篇：6-简单测试","date":"2020-02-13T11:15:59.000Z","updated":"2020-12-09T10:38:18.102Z","comments":true,"path":"2020/02/13/239/","link":"","permalink":"http://github.13sai.com/2020/02/13/239/","excerpt":"","text":"git项目地址 PHP DIY系列–一起手写一个api框架 虽然框架基本完成，但我们还没有测试过。 我们使用postman作为接口测试工具（http://saif.com/test）。 1234567891011121314151617181920212223// 自定义路由return [ &#x27;debug&#x27; =&gt; false, &#x27;route&#x27; =&gt; [ &#x27;&#x27; =&gt; &#x27;demo/welcome&#x27;, &#x27;test&#x27; =&gt; &#x27;demo/test&#x27;, ],];class DemoController extends Controller&#123; public function welcome($params) &#123; return $this-&gt;response-&gt;json([&#x27;hello&#x27; =&gt; &#x27;welcome&#x27;]); &#125; public function test($params) &#123; return $this-&gt;response-&gt;json($params); &#125;&#125; 我们测试下： 我们发现能正常获取获取GET参数，但没有获取到POST参数。 debug： 我们发现Content-Type输出是： multipart/form-data; boundary=--------------------------498010462598077868347660 我们优化一下代码： 123456789101112public function getBodyParams()&#123; $contentType = strtolower($this-&gt;getHeader(&#x27;Content-Type&#x27;)); // p($contentType); if (strpos($contentType, &#x27;multipart/form-data&#x27;) === false) &#123; $this-&gt;_bodyParams = \\json_decode(file_get_contents(&quot;php://input&quot;), true); &#125; else &#123; $this-&gt;_bodyParams = $_POST; &#125; return $this-&gt;_bodyParams?? [];&#125; 另外我们发现getHeader方法有点问题： 12345678910111213public function getHeader($name, $defaultValue = null)&#123; $name = ucfirst($name); if (function_exists(&#x27;apache_request_headers&#x27;)) &#123; $headers = apache_request_headers(); p($headers); return $headers[$name]?? $defaultValue; &#125; // $_SERVER使用下划线 $name = strtoupper(str_replace(&#x27;-&#x27;, &#x27;_&#x27;, $name)); // 部分自定义参数需要加上HTTP_ return $_SERVER[$name]?? ($_SERVER[&#x27;HTTP_&#x27;.$name] ?? $defaultValue);&#125; 测试正常。 另外，做一下说明，我们可以使用public function test($params)，是源于我们Request，将参数注入到方法里。 123456public function runAction($route)&#123; ... 省略代码 return $controller-&gt;$action(array_merge($this-&gt;getQueryParams(), $this-&gt;getBodyParams()));&#125; 性能测试 我们使用的是wrk压测 wrk 1234&gt; git clone https://github.com/wg/wrk&gt; cd wrk &gt; make&gt; ln -s ./wrk /usr/bin/wrk 12345678910wrk参数：-c, --connections（连接数）: total number of HTTP connections to keep open with each thread handling N = connections/threads-d, --duration（测试持续时间）: duration of the test, e.g. 2s, 2m, 2h-t, --threads（线程）: total number of threads to use-s, --script（脚本）: LuaJIT script, see SCRIPTING-H, --header（头信息）: HTTP header to add to request, e.g. &quot;User-Agent: wrk&quot; --latency（响应信息）: print detailed latency statistics --timeout（超时时间）: record a timeout if a response is not received within this amount of time.-v, --version（版本信息） Print version details 我们仅仅在控制返回空信息，然后对比yii2（返回字符串“yii2”），laravel5.5（返回字符串“laravel5.5”）。 因为我们的框架没有中间件、组件之类的，所以性能对比yii2、laravel，QPS要高很多。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---框架篇：5.自定义配置与路由","slug":"系列文章-框架篇：5-自定义配置与路由","date":"2020-02-09T00:31:50.000Z","updated":"2020-12-09T10:38:13.470Z","comments":true,"path":"2020/02/09/238/","link":"","permalink":"http://github.13sai.com/2020/02/09/238/","excerpt":"","text":"git项目地址 PHP DIY系列–一起手写一个api框架 我们已经开发完成，但我们还需要更多。比如自定义配置和路由。 app文件夹下新建Config.php 1234567891011&lt;?php/** *自定义配置 */return [ &#x27;debug&#x27; =&gt; false, &#x27;route&#x27; =&gt; [ &#x27;&#x27; =&gt; &#x27;demo/welcome&#x27;, &#x27;test&#x27; =&gt; &#x27;demo/test&#x27;, ],]; 新建DemoController（app/Https/Controllers目录下） 12345678910111213141516171819202122&lt;?php/** * Demo控制器 */namespace App\\Https\\Controllers;use Library\\Https\\Controller;class DemoController extends Controller&#123; public function welcome($params) &#123; return $this-&gt;response-&gt;json([&#x27;hello&#x27; =&gt; &#x27;welcome&#x27;]); &#125; public function test($params) &#123; return $this-&gt;response-&gt;json($params); &#125;&#125; 修改入口文件index.php,加入加载配置代码： 123456789101112... 省略代码// 加载配置$config = require SF_LIBRARY_PATH.&#x27;Config.php&#x27;;$appConfig = file_exists($appConfigPath = SF_APP_PATH.&#x27;Config.php&#x27;) ? require $appConfigPath : [];$config = array_merge($config, $appConfig);$config[&#x27;debug&#x27;] = ($config[&#x27;debug&#x27;]?? SF_DEBUG);...省略代码 解析路由部分也加入自定义路由处理： 1234567891011121314151617181920212223242526272829303132// Application...省略代码public function handleRequest(Request $request)&#123; $route = $request-&gt;resolve($this-&gt;_config[&#x27;route&#x27;]??[]); $response = $request-&gt;runAction($route); /** * 执行结果赋值给$response-&gt;data，并返回给response对象 */ if ($response instanceof Response) &#123; return $response; &#125; throw new SaiException(&#x27;Content format error&#x27;);&#125;...省略代码// Request...省略代码public function runAction($route)&#123; if (array_key_exists($route, $this-&gt;_route)) &#123; $route = $this-&gt;_route[$route]; &#125; $match = explode(&#x27;/&#x27;, $route); $match = array_filter($match); ...省略代码 保存后打开浏览器看看效果： 这里虽然有自定义路由，但是我们有时候需要禁止默认路由，所以我们不妨增加配置参数defaultRoute，用来控制是否开启默认路由。 我们修改一下路由解析的代码： 123456789101112131415161718192021//Application...省略代码public function handleRequest(Request $request)&#123; $route = $request-&gt;resolve($this-&gt;_config[&#x27;route&#x27;]??[]); $response = $request-&gt;runAction($route, $this-&gt;_config[&#x27;defaultRoute&#x27;]??true); /** * 执行结果赋值给$response-&gt;data，并返回给response对象 */ if ($response instanceof Response) &#123; return $response; &#125; throw new SaiException(&#x27;Content format error&#x27;);&#125;...省略代码 123456789101112...省略代码public function runAction($route, $defaultRoute)&#123; if (array_key_exists($route, $this-&gt;_route)) &#123; $route = $this-&gt;_route[$route]; &#125; elseif (!$defaultRoute) &#123; throw new NotFoundException(&quot;route not found:&quot;.$route); &#125; ...省略代码 我们在app下面的Config，加入： 12345678return [ &#x27;debug&#x27; =&gt; false, &#x27;route&#x27; =&gt; [ &#x27;&#x27; =&gt; &#x27;demo/welcome&#x27;, &#x27;test&#x27; =&gt; &#x27;demo/test&#x27;, ], &#x27;defaultRoute&#x27; =&gt; false,]; 我们打开浏览器输入http://saif.com/login 报错如下： Array ( [line] =&gt; 137 [msg] =&gt; route not found:login [code] =&gt; 404 [file] =&gt; library/Https/Request.php )","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---框架篇：4.入口文件","slug":"系列文章-框架篇：4-入口文件","date":"2020-02-08T05:31:08.000Z","updated":"2020-12-09T10:38:07.127Z","comments":true,"path":"2020/02/08/237/","link":"","permalink":"http://github.13sai.com/2020/02/08/237/","excerpt":"","text":"git项目地址 PHP DIY系列–一起手写一个api框架 回顾上一节我们完成了从路由解析到数据输出的过程，并且之前已经完成了Request的编写，这一节我们写完入口文件，真正的将我们的web应用跑起来了。 入口文件里需要做些什么呢？ 还记得那个流程图吗？ 我们需要加载配置，实例化Application并运行，并且引入后面可能遇到的一些常量。 123456789101112131415161718192021&lt;?phprequire __DIR__.DIRECTORY_SEPARATOR.&#x27;..&#x27;.DIRECTORY_SEPARATOR.&#x27;library&#x27;.DIRECTORY_SEPARATOR.&#x27;System.php&#x27;;// 加载配置$config = require SF_LIBRARY_PATH.&#x27;Config.php&#x27;;$config[&#x27;debug&#x27;] = ($config[&#x27;debug&#x27;]?? SF_DEBUG);if ($config[&#x27;debug&#x27;]) &#123; ini_set(&quot;display_errors&quot;, &quot;On&quot;); error_reporting(E_ALL);&#125;// composer自动加载require __DIR__ . &#x27;/../vendor/autoload.php&#x27;;// 实例化应用并运行$app = new Library\\Application(new Library\\Https\\Request() ,$config);$app-&gt;run(); 知识点： __DIR__是PHP的一个魔术常量，可以理解成当前文件所在路径。DIRECTORY_SEPARATOR是一个显示系统分隔符的命令，DIRECTORY_SEPARATOR是PHP的内部常量，不需要任何定义与包含即可直接使用。 ini_set — 为一个配置选项设置值 error_reporting — 设置应该报告何种 PHP 错误 12345678910111213141516171819202122232425&lt;?php// Turn off all error reportingerror_reporting(0);// Report simple running errorserror_reporting(E_ERROR | E_WARNING | E_PARSE);// Reporting E_NOTICE can be good too (to report uninitialized// variables or catch variable name misspellings ...)error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);// Report all errors except E_NOTICEerror_reporting(E_ALL &amp; ~E_NOTICE);// Report all PHP errors (see changelog)error_reporting(E_ALL);// Report all PHP errorserror_reporting(-1);// Same as error_reporting(E_ALL);ini_set(&#x27;error_reporting&#x27;, E_ALL);?&gt; System.php12345678910111213&lt;?php// debug默认开启defined(&#x27;SF_DEBUG&#x27;) or define(&#x27;SF_DEBUG&#x27;, true);// 框架开始运行时间defined(&#x27;SF_START_TIME&#x27;) or define(&#x27;SF_START_TIME&#x27;, microtime(true));// 核心文件目录defined(&#x27;SF_LIBRARY_PATH&#x27;) or define(&#x27;SF_LIBRARY_PATH&#x27;, __DIR__.DIRECTORY_SEPARATOR);// 应用目录defined(&#x27;SF_APP_PATH&#x27;) or define(&#x27;SF_APP_PATH&#x27;, __DIR__.DIRECTORY_SEPARATOR.&#x27;..&#x27;.DIRECTORY_SEPARATOR.&#x27;app&#x27;.DIRECTORY_SEPARATOR);// 入口目录defined(&#x27;SF_PUBLIC_PATH&#x27;) or define(&#x27;SF_PUBLIC_PATH&#x27;, __DIR__.DIRECTORY_SEPARATOR.&#x27;..&#x27;.DIRECTORY_SEPARATOR.&#x27;public&#x27;.DIRECTORY_SEPARATOR); Config.php1234567&lt;?php/** * 系统配置 */return [ &#x27;debug&#x27; =&gt; true, // 建议开发过程中开启]; 到这里，我们的框架已经可以运行起来了。 运行应用配置Nginx 12345678910111213141516171819202122232425server &#123; listen 80; server_name saif.com; # 框架根目录 root /Users/sai/Work/www/saif/public; location / &#123; index index.html index.htm index.php; try_files $uri $uri/ /index.php?$query_string; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; location ~ \\.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 浏览器输入http://saif.com。 你会看到返回的json数组： 备注：前面3行请忽略，是我浏览器的插件自动加入的。 到这里，我们已经完成了基础API框架的开发。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---框架篇：3.路由解析","slug":"系列文章-框架篇：3-路由解析","date":"2020-02-08T02:35:57.000Z","updated":"2021-04-26T03:43:51.968Z","comments":true,"path":"2020/02/08/236/","link":"","permalink":"http://github.13sai.com/2020/02/08/236/","excerpt":"","text":"git项目地址 PHP DIY系列–一起手写一个api框架 回顾上一节我们介绍了编写了如何处理请求与输出数据，这一节我们开始编写路由模块。 正文还记得我们之前建立的Application在哪里吗？ 我们先思考一下Application应该具备哪些功能？ 首先很重要的，我们要让应用运行起来，姑且就先定义run方法。另外我们需要处理请求并且输出数据，我们再定义一个handleRequest方法。当然，我们的应用是有一些配置信息（config）的。 因为，我们不难编写出以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace Library;use Library\\Exceptions\\SaiException;use Library\\Https\\Request;use Library\\Https\\Response;class Application&#123; private $config; private $request; public function __construct(Request $request, $config = []) &#123; $this-&gt;config = $config; $this-&gt;request = $request; &#125; /** * 运行应用并输出数据 * @return bool */ public function run() &#123; try &#123; $response = $this-&gt;handleRequest($this-&gt;request); $response-&gt;send(); return $response-&gt;exitStatus; &#125; catch (SaiException $e) &#123; $e-&gt;response($e-&gt;getCode(), [ &#x27;line&#x27; =&gt; $e-&gt;getLine(), &#x27;msg&#x27; =&gt; $e-&gt;getMessage(), &#x27;code&#x27; =&gt; $e-&gt;getCode(), &#x27;file&#x27; =&gt; $e-&gt;getFile(), ]); return false; &#125; &#125; /** * 处理请求 * @param Request $request * @return mixed * @throws SaiException */ public function handleRequest(Request $request) &#123; // todo // 返回Response对象 return $response; &#125;&#125; 这里我们看到handleRequest方法还有一部分代码为完成，回想以下流程图，这里就是我们比较核心的部分，路由处理模块。 路由解析路由解析我们使用非常简单而常见的处理方式，不妨看几个url例子来理解一下： route controller method http://blog.13sai.com/ IndexController index http://blog.13sai.com/admin AdminController index http://blog.13sai.com/admin/test AdminController test http://blog.13sai.com/admin/index/test Admin\\IndexController test 有没有看出规律，我们会以斜杠/分割路由为几个部分，最后两部分分别是对应的控制器名称和方法名称，少于两部分默认用index，多余两部分的作为控制器的命名空间。然后我们要根据路由找到控制器构建出控制器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 控制器处理 * @param $route * @return mixed * @throws NotFoundException */public function runAction($route)&#123; $match = explode(&#x27;/&#x27;, $route); $match = array_filter($match); // 处理$route=/ if (empty($match)) &#123; $match = [&#x27;index&#x27;]; $controller = $this-&gt;createController($match); $action = &#x27;index&#x27;; // 处理$route=index &#125; elseif (count($match) &lt; 2) &#123; $controller = $this-&gt;createController($match); $action = &#x27;index&#x27;; &#125; else &#123; $action = array_pop($match); $controller = $this-&gt;createController($match); if (!method_exists($controller, $action)) &#123; throw new NotFoundException(&quot;method not found:&quot;.$action); &#125; &#125; // 将get和post注入控制器方法中 return $controller-&gt;$action(array_merge($this-&gt;getQueryParams(), $this-&gt;getBodyParams()));&#125;// app应用控制器命名空间private $controllerNameSpace = &#x27;App\\\\Https\\\\Controllers\\\\&#x27;;// 之前定义的基类控制器private $baseController = &#x27;Library\\\\Https\\\\Controller&#x27;;public function createController($match)&#123; $controllerName = $this-&gt;controllerNameSpace; foreach ($match as $namespace) &#123; $controllerName .= ucfirst($namespace).&#x27;\\\\&#x27;; &#125; $controllerName = rtrim($controllerName,&#x27;\\\\&#x27;).&#x27;Controller&#x27;; if (!class_exists($controllerName)) &#123; if ($controllerName == $this-&gt;controllerNameSpace.&#x27;IndexController&#x27;) &#123; return new $this-&gt;baseController; &#125; throw new NotFoundException(&quot;controller not found:&quot;.$controllerName); &#125; return new $controllerName;&#125; 上面是寻找控制器和方法的过程，但我们需要提前获得页面地址以解析路由。 知识点： 反斜杠：反斜线有多种用法。首先，如果紧接着是一个非字母数字字符，表明取消 该字符所代表的特殊涵义。这种将反斜线作为转义字符的用法在字符类 内部和外部都可用。 array_filter ( array $array [, callable $callback [, int $flag = 0 ]] ) : array——依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。代码中是过滤value为空的单元。 获取页面地址123456789101112131415161718192021222324/** * 返回不含参数的REQUEST_URI地址 */public function resolve()&#123; return $this-&gt;getPathUrl();&#125;private $pathUrl;/** * 获取请求地址 * @return bool|mixed|string */public function getPathUrl()&#123; if (is_null($this-&gt;pathUrl)) &#123; $url = trim($_SERVER[&#x27;REQUEST_URI&#x27;], &#x27;/&#x27;); $index = strpos($url, &#x27;?&#x27;); $this-&gt;pathUrl = ($index &gt; -1) ? substr($url, 0, $index) : $url; &#125; return $this-&gt;pathUrl;&#125; 我们尽量让Application变得简洁，而路由解析又和Request关联度较高，因此我们不妨把这些方法抛出到Request对象。 知识点： strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ) : int——返回 needle 在 haystack 中首次出现的数字位置，如果没找到 needle，将返回 FALSE。 上面已经解析好路由并且找到了控制器和方法。这样我们就可以完善Application的代码了。 处理请求1234567891011121314public function handleRequest(Request $request)&#123; $route = $request-&gt;resolve(); $response = $request-&gt;runAction($route); /** * 执行结果赋值给$response-&gt;data，并返回给response对象 */ if ($response instanceof Response) &#123; return $response; &#125; throw new SaiException(&#x27;输出的内容格式错误&#x27;);&#125; 再次需要说明的是，我们在这里仅做了json格式输出，如果有兴趣，你可以自己动手拓展一下。 另：NotFoundException继承自SaiException，代码： 123456789&lt;?phpnamespace Library\\Exceptions;class NotFoundException extends SaiException&#123; protected $code = 404;&#125;","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---框架篇：2.请求与输出","slug":"系列文章-框架篇：2-请求与输出","date":"2020-02-04T06:05:41.000Z","updated":"2020-12-09T10:37:38.897Z","comments":true,"path":"2020/02/04/235/","link":"","permalink":"http://github.13sai.com/2020/02/04/235/","excerpt":"","text":"PHP DIY系列–一起手写一个api框架 我们在library\\Https目录下新建Request、Response，开始编写请求和输出的代码。 Request我们实现几个常用的方法，get、post、method等，这里主要用$_SERVER实现，为了复用我们定义了三个私有属性存储get参数、post参数和method。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?php/** * 处理请求 */namespace Library\\Https;use Library\\Components\\Base;class Request extends Base&#123; /** * 获取请求方法 * @return string */ public function getMethod() &#123; if (isset($_SERVER[&#x27;REQUEST_METHOD&#x27;])) &#123; return strtoupper($_SERVER[&#x27;REQUEST_METHOD&#x27;]); &#125; return &#x27;GET&#x27;; &#125; /** * 请求头 * @param $name * @param null $defaultValue * @return mixed|null */ public function getHeader($name, $defaultValue = null) &#123; $name = ucfirst($name); if (function_exists(&#x27;apache_request_headers&#x27;)) &#123; $headers = apache_request_headers(); return $headers[$name]?? $defaultValue; &#125; $name = strtoupper($name); return $_SERVER[$name]?? $defaultValue; &#125; /** * 获取get参数 * @param null $name * @param null $defaultValue * @return |null */ public function get($name = null, $defaultValue = null) &#123; if ($name === null) &#123; return $this-&gt;getQueryParams(); &#125; return $this-&gt;getQueryParam($name, $defaultValue); &#125; public function getQueryParam($name, $defaultValue = null) &#123; $params = $this-&gt;getQueryParams(); return isset($params[$name]) ? $params[$name] : $defaultValue; &#125; public function getQueryParams() &#123; if (empty($this-&gt;queryParams)) &#123; return $this-&gt;queryParams = $_GET; &#125; return $this-&gt;queryParams; &#125; /** * 获取post参数 * @param null $name * @param null $defaultValue * @return array|mixed|null */ public function post($name = null, $defaultValue = null) &#123; if ($name === null) &#123; return $this-&gt;getBodyParams(); &#125; return $this-&gt;getBodyParam($name, $defaultValue); &#125; public function getBodyParam($name, $defaultValue = null) &#123; $params = $this-&gt;getBodyParams(); if (is_object($params)) &#123; try &#123; return $params-&gt;&#123;$name&#125;; &#125; catch (\\Exception $e) &#123; return $defaultValue; &#125; &#125; return isset($params[$name]) ? $params[$name] : $defaultValue; &#125; public function getBodyParams() &#123; $contentType = strtolower($this-&gt;getHeader(&#x27;Content-Type&#x27;)); if ($contentType == &#x27;multipart/form-data&#x27;) &#123; $this-&gt;bodyParams = $_POST; &#125; else &#123; $this-&gt;bodyParams = \\json_decode(file_get_contents(&quot;php://input&quot;), true); &#125; return $this-&gt;bodyParams?? []; &#125; /** * get参数数组 */ private $queryParams = []; /** * post参数数组 */ private $bodyParams = []; private $method;&#125; 知识点： 获取请求头部信息的方式nginx和apache不同 apache可以使用apache_request_headers nginx使用$_SERVER，并且需要注意的是的是自定义信息等参数会在前面自动加上http_，并且会转换为大写 post参数获取的方式 当Content-Type是application/x-www-data-urlencoded或multipart/form-data时，数据会放进$_POST中； 除了Coentent-Type为multipart/form-data的情况，数据都可以通过file_get_contents(“php://input”)取到； 不建议使用$GLOBALS[‘HTTP_RAW_POST_DATA’] ResponseResponse默认以使用广泛的json输出，暂时也只考虑json格式输出的情况。 1234567891011121314151617181920212223242526272829303132333435&lt;?php/** * 数据输出 */namespace Library\\Https;use Library\\Components\\Base;class Response extends Base&#123; public $code = 0; public $result = []; public $msg = &quot;success&quot;; public function send() &#123; header(&#x27;Content-Type:application/json; charset=utf-8&#x27;); echo \\json_encode([ &#x27;data&#x27; =&gt; $this-&gt;result, &#x27;msg&#x27; =&gt; $this-&gt;msg, &#x27;code&#x27; =&gt; $this-&gt;code, &#x27;timestamp&#x27; =&gt; time() ]); &#125; public function json($data = []) &#123; $this-&gt;result = array_merge($this-&gt;result, $data); return $this; &#125;&#125; 知识点： header() 用于发送原生的 HTTP 头。 json_encode ( mixed $value [, int $options = 0 [, int $depth = 512 ]] ) : string — 对变量进行 JSON 编码，options可以预定义常量，如 JSON_UNESCAPED_UNICODE，JSON_UNESCAPED_SLASHES。 Controller结合输出对象，我们在创建一个基类控制器，也放在相同的Https目录，我们控制创建一个构造函数，实例化一个Response，并实现一个通用的json： 12345678910111213141516171819202122232425262728293031323334353637&lt;?php/** * 基类控制器 * 预定义json方法，便于其他控制器使用 * 返回格式 &#123; &quot;data&quot;: [], &quot;msg&quot;: &quot;success&quot;, &quot;code&quot;: 0, &quot;timestamp&quot;: 1572231957&#125; */namespace Library\\Https;class Controller&#123; protected $response; protected $code = 200; public function __construct() &#123; $this-&gt;response = new Response(); &#125; public function json($data = []) &#123; return $this-&gt;response-&gt;json($data); &#125; public function index($params) &#123; return $this-&gt;response-&gt;json([&#x27;hello&#x27; =&gt; &#x27;saif&#x27;]); &#125;&#125; app应用里的控制器都必须继承这个基类控制器。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---框架篇：1.框架目录与辅助","slug":"系列文章-框架篇：1-框架目录与辅助","date":"2020-02-02T02:55:21.000Z","updated":"2020-12-09T10:37:34.437Z","comments":true,"path":"2020/02/02/234/","link":"","permalink":"http://github.13sai.com/2020/02/02/234/","excerpt":"","text":"PHP DIY系列–一起手写一个api框架 那么就利用composer来开始我们的项目吧。 新建目录并进入目录，输入命令： composer init 命令行会跟你确认以下信息（以下信息可以自行DIY） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 1. 输入项目命名空间# 注意&lt;vendor&gt;/&lt;name&gt; 必须要符合 [a-z0-9_.-]+/[a-z0-9_.-]+Package name (&lt;vendor&gt;/&lt;name&gt;) yourname/projectname# 2. 项目描述Description []:这是一个测试composer init 项目# 3. 输入作者信息Author [13sai &lt;sai0556@qq.com&gt;, n to skip]:# 4. 输入最低稳定版本，stable, RC, beta, alpha, devMinimum Stability []:dev# 5. 输入项目类型Package Type (e.g. library, project, metapackage, composer-plugin) []:project# 6. 输入授权类型License []:MITDefine your dependencies.# 7. 输入依赖信息Would you like to define your dependencies (require) interactively [yes]?# 7.1. 如果需要依赖，则输入要安装的依赖Search for a package:php# 7.2. 输入版本号Enter the version constraint to require (or leave blank to use the latest version): &gt;=5.4.0# 如需多个依赖，则重复以上两个步骤(7.1/7.2)Search for a package:# 8. 是否需要require-dev，Would you like to define your dev dependencies (require-dev) interactively [yes]?&#123; &quot;name&quot;: &quot;sai/saif&quot;, &quot;description&quot;: &quot;php framework&quot;, &quot;type&quot;: &quot;project&quot;, &quot;require&quot;: &#123; &#125;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;13sai&quot;, &quot;email&quot;: &quot;sai0556@qq.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;&#125;# 9. 是否生成composer.jsonDo you confirm generation [yes]?# 现在安装依赖项吗Would you like to install dependencies now [yes]? 我们的目录下会生成composer.json。 然后我们来思考一个问题： 你觉得一个基础的API框架需要什么模块呢？ 下面是我的思考结果： 路由 请求 数据响应 异常处理 日志系统… 当然，你可能觉得还应该有： 配置 session 缓存 验证 模型 服务层 文件上传… 也许你想到更多： 任务调度 队列 用户验证 锁 … 那么这么些我们如何取舍呢？手心手背都是肉啊。 这里需要做一下说明，我们所做的框架无需考虑太多的功能，是做一个简单可用的API接口框架，我们接受get/post请求，返回json数据，并且路由好用，这是我们的初衷，其他的暂且就“断舍离”吧。 我们先画一个极简的流程图。 我们一切从简，所以我们定义以下几个模块： 路由 控制器 请求 数据响应 配置 异常处理 … 基于这些，我们新建目录，app和library，public app web应用 library 核心代码 public 入口目录 出于简单安全考虑，我们的入口单独放在public目录，并在目录下新建index.php作为我们的入口文件。 library下面新建几个目录和文件 Components 常用组件 Exceptions 异常模块 Https http应用模块 Sessions session模块 Application.php 应用文件 Config.php 配置文件 Functions.php 常用函数 System.php 框架自定义常量 对应的我们在composer.json中加入一些autoload配置，用以自动加载，省去我们实现自动加载。 123456789&quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Library\\\\&quot;: &quot;library/&quot;, &quot;App\\\\&quot;: &quot;app/&quot; &#125;, &quot;files&quot;: [ &quot;library/Functions.php&quot; ]&#125; 执行一下，composer install或者composer dump-autoload即可。 这里简单说明一下autoload的四种方式： autoload的四种方式 PSR-4 在psr-4键下，定义了相对于包根目录从名称空间到路径的映射。当自动加载一个类（如foo\\bar\\baz）时，指向src/目录的名称空间前缀foo\\，意味着自动加载程序将查找一个名为src/bar/baz.php的文件，并包括它（如果存在）。注意，与旧的psr-0样式相反，前缀（foo\\）不在文件路径中。 命名空间前缀必须以“\\”结尾，以避免类似前缀之间的冲突。例如，foo将匹配foobar名称空间中的类，因此后面的反斜杠可以解决问题：foo\\，foobar\\。 该数组可以在生成的文件vendor/composer/autoload_psr4.php中找到。 PSR-0 在 psr-0 key 下你定义了一个命名空间到实际路径的映射（相对于包的根目录）。注意，这里同样支持 PEAR-style 方式的约定（与命名空间不同，PEAR 类库在类名上采用了下划线分隔）。 请注意，命名空间的申明应该以 \\ 结束，以确保 autoloader 能够准确响应。例： Foo 将会与 FooBar 匹配，然而以反斜杠结束就可以解决这样的问题， Foo\\ 和 FooBar\\ 将会被区分开来。 PSR-0 引用都将被结合为一个单一的键值对数组，存储至 vendor/composer/autoload_namespaces.php 文件中。 classmap 你可以用 classmap 生成支持支持自定义加载的不遵循 PSR-0/4 规范的类库。要配置它指向需要的目录，以便能够准确搜索到类文件。 classmap 引用的所有组合会存储到 vendor/composer/autoload_classmap.php 文件中。这个 map 是经过扫描指定目录（同样支持直接精确到文件）中所有的 .php 和 .inc 文件里内置的类而得到的。 files 如果你想要明确的指定，在每次请求时都要载入某些文件，那么你可以使用 ‘files’ autoloading。通常作为函数库的载入方式（而非类库）。files 引用的文件会存储到 vendor/composer/autoload_files.php 文件中 点击查看autoload说明与实例 我们先不着急进行核心代码编写，不妨先做一下辅助工作，常用方法，异常处理等。 常用函数Functions编写常用函数 1234567891011121314151617181920212223242526272829&lt;?php/** * 常用函数 */ if (!function_exists(&quot;p&quot;)) &#123; function p($var) &#123; if (is_bool($var)) &#123; var_dump($var); &#125; elseif (is_null($var)) &#123; var_dump(null); &#125; else &#123; die(&quot;&lt;meta charset=&#x27;utf-8&#x27;/&gt;&lt;pre style=&#x27;position:relative;z-index:999;padding:10px;border-radius:5px;background:#f5f5f5;border:1px solid #aaa;font-size:14px;line-height:18px;opacity:0.8;&#x27;&gt;&quot;.print_r($var, true).&quot;&lt;/pre&gt;&quot;); &#125; &#125;&#125;······ 异常处理在Exceptions目录下，定义一个最基础的异常SaiException： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?phpnamespace Library\\Exceptions;class SaiException extends \\Exception&#123; const CODE_MAPPING = [ 100 =&gt; &#x27;Continue&#x27;, 101 =&gt; &#x27;Switching Protocols&#x27;, 102 =&gt; &#x27;Processing&#x27;, 200 =&gt; &#x27;OK&#x27;, 201 =&gt; &#x27;Created&#x27;, 202 =&gt; &#x27;Accepted&#x27;, 203 =&gt; &#x27;Non-Authoritative Information&#x27;, 204 =&gt; &#x27;No Content&#x27;, 205 =&gt; &#x27;Reset Content&#x27;, 206 =&gt; &#x27;Partial Content&#x27;, 207 =&gt; &#x27;Multi-Status&#x27;, 226 =&gt; &#x27;IM Used&#x27;, 300 =&gt; &#x27;Multiple Choices&#x27;, 301 =&gt; &#x27;Moved Permanently&#x27;, 302 =&gt; &#x27;Found&#x27;, 303 =&gt; &#x27;See Other&#x27;, 304 =&gt; &#x27;Not Modified&#x27;, 305 =&gt; &#x27;Use Proxy&#x27;, 306 =&gt; &#x27;Reserved&#x27;, 307 =&gt; &#x27;Temporary Redirect&#x27;, 400 =&gt; &#x27;Bad Request&#x27;, 401 =&gt; &#x27;Unauthorized&#x27;, 402 =&gt; &#x27;Payment Required&#x27;, 403 =&gt; &#x27;Forbidden&#x27;, 404 =&gt; &#x27;Not Found&#x27;, 405 =&gt; &#x27;Method Not Allowed&#x27;, 406 =&gt; &#x27;Not Acceptable&#x27;, 407 =&gt; &#x27;Proxy Authentication Required&#x27;, 408 =&gt; &#x27;Request Timeout&#x27;, 409 =&gt; &#x27;Conflict&#x27;, 410 =&gt; &#x27;Gone&#x27;, 411 =&gt; &#x27;Length Required&#x27;, 412 =&gt; &#x27;Precondition Failed&#x27;, 413 =&gt; &#x27;Request Entity Too Large&#x27;, 414 =&gt; &#x27;Request-URI Too Long&#x27;, 415 =&gt; &#x27;Unsupported Media Type&#x27;, 416 =&gt; &#x27;Requested Range Not Satisfiable&#x27;, 417 =&gt; &#x27;Expectation Failed&#x27;, 422 =&gt; &#x27;Unprocessable Entity&#x27;, 423 =&gt; &#x27;Locked&#x27;, 424 =&gt; &#x27;Failed Dependency&#x27;, 426 =&gt; &#x27;Upgrade Required&#x27;, 429 =&gt; &#x27;Too Many Request&#x27;, 500 =&gt; &#x27;Internal Server Error&#x27;, 501 =&gt; &#x27;Not Implemented&#x27;, 502 =&gt; &#x27;Bad Gateway&#x27;, 503 =&gt; &#x27;Service Unavailable&#x27;, 504 =&gt; &#x27;Gateway Timeout&#x27;, 505 =&gt; &#x27;HTTP Version Not Supported&#x27;, 506 =&gt; &#x27;Variant Also Negotiates&#x27;, 507 =&gt; &#x27;Insufficient Storage&#x27;, 510 =&gt; &#x27;Not Extended&#x27;, 1001 =&gt; &#x27;LACK PARAMS&#x27;, 1002 =&gt; &#x27;RETRY TOO MANY&#x27;, ]; /** * 输出指定HTTP状态码的响应头信息 * @param int $code * @param $data * @return void */ public function response($code, $data)&#123; $code = array_key_exists($code, self::CODE_MAPPING)? $code : 500; $desc = self::CODE_MAPPING[$code]; $protocol = $_SERVER[&#x27;SERVER_PROTOCOL&#x27;]; if ( &#x27;HTTP/1.1&#x27; != $protocol &amp;&amp; &#x27;HTTP/1.0&#x27; != $protocol ) $protocol = &#x27;HTTP/1.0&#x27;; $header = &quot;$protocol $code $desc&quot;; header($header); p($data); &#125;&#125; 几乎后面所有Exception的类都会继承这个异常类。 在Components目录下新建基础的类Base： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace Library\\Components;class Base implements \\ArrayAccess&#123; private $_container; public function __get($name) &#123; if (method_exists($this, $method = &#x27;get&#x27;.ucfirst($name))) &#123; return $this-&gt;$method($name); &#125; return null; &#125; public function __set($name, $value) &#123; if (method_exists($this, $method = &#x27;set&#x27;.ucfirst($name))) &#123; return $this-&gt;$method($name, $value); &#125; &#125; public function offsetSet($offset, $value) &#123; if (is_null($offset)) &#123; $this-&gt;_container[] = $value; &#125; else &#123; $this-&gt;_container[$offset] = $value; &#125; &#125; public function offsetExists($offset) &#123; return isset($this-&gt;_container[$offset]); &#125; public function offsetUnset($offset) &#123; unset($this-&gt;_container[$offset]); &#125; public function offsetGet($offset) &#123; return isset($this-&gt;_container[$offset]) ? $this-&gt;_container[$offset] : null; &#125;&#125; 这里有两个知识点： ArrayAccess数组式访问接口（提供像访问数组一样访问对象的能力的接口。） 魔术方法__set和__get（在给不可访问属性赋值时__set() 会被调用;读取不可访问属性的值时__get() 会被调用。） 如果想了解更多，可看官方文档： ArrayAccess接口 魔术方法","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---基础篇：3.反射","slug":"系列文章-基础篇：3-反射","date":"2020-02-01T10:14:31.000Z","updated":"2020-12-09T10:37:30.427Z","comments":true,"path":"2020/02/01/233/","link":"","permalink":"http://github.13sai.com/2020/02/01/233/","excerpt":"","text":"PHP DIY系列–一起手写一个api框架 反射，直观理解就是根据到达地找到出发地和来源。 反射指在PHP运行状态中，扩展分析PHP程序，导出或提出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取信息以及动态调用对象方法的功能称为反射API。 不妨先来看一个demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php/** * Author: sai * Date: 2019/10/21 * Time: 10:59 */function p($msg, $var)&#123; echo(&quot;&lt;pre style=&#x27;position:relative;z-index:999;padding:10px;border-radius:5px;background:#f5f5f5;border:1px solid #aaa;font-size:14px;line-height:18px;opacity:0.8;&#x27;&gt;&quot;.$msg.&quot;:&quot;.print_r($var, true).&quot;&lt;/pre&gt;&quot;);&#125;class Demo&#123; private $id; protected $name; public $skills = []; public function __construct($id, $name, $skills = []) &#123; $this-&gt;id = $id; $this-&gt;name = $name; $this-&gt;skills = $skills; &#125; public function getName() &#123; return $this-&gt;name; &#125; public function getSkill() &#123; p(&#x27;skill&#x27;, $this-&gt;skills); &#125;&#125;$ref = new ReflectionClass(&#x27;Demo&#x27;);if ($ref-&gt;isInstantiable()) &#123; p(&#x27;检查类是否可实例化isInstantiable&#x27;, null );&#125;$constructor = $ref-&gt;getConstructor();p(&#x27;获取构造函数getConstructor&#x27;, $constructor);$parameters = $constructor-&gt;getParameters();foreach ($parameters as $param) &#123; p(&#x27;获取参数getParameters&#x27;, $param);&#125;if ($ref-&gt;hasProperty(&#x27;name&#x27;)) &#123; $attr = $ref-&gt;getProperty(&#x27;name&#x27;); p(&#x27;获取属性getProperty&#x27;, $attr);&#125;$attributes = $ref-&gt;getProperties();foreach ($attributes as $row) &#123; p(&#x27;获取属性列表getProperties&#x27;, $row-&gt;getName() );&#125;if ($ref-&gt;hasMethod(&#x27;getSkill&#x27;)) &#123; $method = $ref-&gt;getMethod(&#x27;getSkill&#x27;); p(&#x27;获取方法getMethod&#x27;, $method);&#125;$methods = $ref-&gt;getMethods();foreach ($methods as $row) &#123; p(&#x27;获取方法列表getMethods&#x27;, $row-&gt;getName());&#125;$instance = $ref-&gt;newInstanceArgs([1, &#x27;sai&#x27;, [&#x27;php&#x27;, &#x27;js&#x27;]]);p(&#x27;newInstanceArgs&#x27;, $instance); 输出： 检查类是否可实例化isInstantiable: 获取构造函数getConstructor:ReflectionMethod Object ( [name] => __construct [class] => Demo ) 获取参数getParameters:ReflectionParameter Object( [name] => id)获取参数getParameters:ReflectionParameter Object( [name] => name)获取参数getParameters:ReflectionParameter Object( [name] => skills)获取属性getProperty:ReflectionProperty Object( [name] => name [class] => Demo)获取属性列表getProperties:id获取属性列表getProperties:name获取属性列表getProperties:skills获取方法getMethod:ReflectionMethod Object( [name] => getSkill [class] => Demo)获取方法列表getMethods:__construct获取方法列表getMethods:getName获取方法列表getMethods:getSkillnewInstanceArgs:Demo Object( [id:Demo:private] => 1 [name:protected] => sai [skills] => Array ( [0] => php [1] => js ) ) demo里面就有使用了ReflectionClass类，当然ReflectionClass类不止于这些方法。 更多方法ReflectionClass类还有更多方法： 方法 说明 ReflectionClass::__construct 初始化 ReflectionClass 类 ReflectionClass::export 导出一个类 ReflectionClass::getConstant 获取定义过的一个常量 ReflectionClass::getConstants 获取一组常量 ReflectionClass::getConstructor 获取类的构造函数 ReflectionClass::getDefaultProperties 获取默认属性 ReflectionClass::getDocComment 获取文档注释 ReflectionClass::getEndLine 获取最后一行的行数 ReflectionClass::getExtension 根据已定义的类获取所在扩展的 ReflectionExtension 对象 ReflectionClass::getExtensionName 获取定义的类所在的扩展的名称 ReflectionClass::getFileName 获取定义类的文件名 ReflectionClass::getInterfaceNames 获取接口（interface）名称 ReflectionClass::getInterfaces 获取接口 ReflectionClass::getMethod 获取一个类方法的 ReflectionMethod。 ReflectionClass::getMethods 获取方法的数组 ReflectionClass::getModifiers 获取类的修饰符 ReflectionClass::getName 获取类名 ReflectionClass::getNamespaceName 获取命名空间的名称 ReflectionClass::getParentClass 获取父类 ReflectionClass::getProperties 获取一组属性 ReflectionClass::getProperty 获取类的一个属性的 ReflectionProperty ReflectionClass::getReflectionConstant Gets a ReflectionClassConstant for a class’s constant ReflectionClass::getReflectionConstants Gets class constants ReflectionClass::getShortName 获取短名 ReflectionClass::getStartLine 获取起始行号 ReflectionClass::getStaticProperties 获取静态（static）属性 ReflectionClass::getStaticPropertyValue 获取静态（static）属性的值 ReflectionClass::getTraitAliases 返回 trait 别名的一个数组 ReflectionClass::getTraitNames 返回这个类所使用 traits 的名称的数组 ReflectionClass::getTraits 返回这个类所使用的 traits 数组 ReflectionClass::hasConstant 检查常量是否已经定义 ReflectionClass::hasMethod 检查方法是否已定义 ReflectionClass::hasProperty 检查属性是否已定义 ReflectionClass::implementsInterface 接口的实现 ReflectionClass::inNamespace 检查是否位于命名空间中 ReflectionClass::isAbstract 检查类是否是抽象类（abstract） ReflectionClass::isAnonymous 检查类是否是匿名类 ReflectionClass::isCloneable 返回了一个类是否可复制 ReflectionClass::isFinal 检查类是否声明为 final ReflectionClass::isInstance 检查类的实例 ReflectionClass::isInstantiable 检查类是否可实例化 ReflectionClass::isInterface 检查类是否是一个接口（interface） ReflectionClass::isInternal 检查类是否由扩展或核心在内部定义 ReflectionClass::isIterable Check whether this class is iterable ReflectionClass::isIterateable 检查是否可迭代（iterateable） ReflectionClass::isSubclassOf 检查是否为一个子类 ReflectionClass::isTrait 返回了是否为一个 trait ReflectionClass::isUserDefined 检查是否由用户定义的 ReflectionClass::newInstance 从指定的参数创建一个新的类实例 ReflectionClass::newInstanceArgs 从给出的参数创建一个新的类实例。 ReflectionClass::newInstanceWithoutConstructor 创建一个新的类实例而不调用它的构造函数 ReflectionClass::setStaticPropertyValue 设置静态属性的值 ReflectionClass::__toString 返回 ReflectionClass 对象字符串的表示形式。 除去强大的ReflectionClass，还有Reflection、ReflectionClassConstant 、ReflectionMethod 、ReflectionFunctionAbstract等等。建议查看手册： PHP反射 反射的实际应用 反射可以用于文档、文件生成。可以用它对文件里的类进行扫描，逐个生成描述文档; 既然反射可以探知类的内部结构，那么可以用它做hook实现插件功能； 可以用于做动态代理，在未知或者不确定类名的情况下，动态生成和实例化一些类和执行方法； 依赖注入。对于多次继承的类，我们可以通过多次反射探索到基类的结构，或者采用递归的形式反射，实现实例化所有继承类，这也是PHP依赖注入的原理。 反射的优点 支持反射的语言提供了一些在低级语言中难以实现的运行时特性。 可以在一定程度上避免硬编码，提供灵活性和通用性。 可以作为一个第一类对象发现并修改源代码的结构（如代码块、类、方法、协议等）。 可以在运行时像对待源代码语句一样计算符号语法的字符串（类似JavaScript的eval()函数），进而可将跟class或function匹配的字符串转换成class或function的调用或引用。 可以创建一个新的语言字节码解释器来给编程结构一个新的意义或用途。 反射的缺点 学习成本高。面向反射的编程需要较多的高级知识，包括框架、关系映射和对象交互，以利用更通用的代码执行 同样因为反射的概念和语法都比较抽象，过多地滥用反射技术会使得代码难以被其他人读懂，不利于合作与交流 反射在提高了代码灵活性的同时，牺牲了一点点运行效率，有一定的消耗 反射也会破坏类的封装性，把本不该暴露的方法或属性暴露了出来 在平时的开发中，我们用到反射其实不多，为什么把它拿到这里来说呢？一来是我们后面会使用到反射去实现Ioc容器，二来反射也是PHP核心功能之一，在我们流行的框架中十分常见，理解它是很有必要的。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---基础篇：2.composer","slug":"系列文章-基础篇：2-composer","date":"2020-02-01T03:04:31.000Z","updated":"2020-12-09T10:37:26.091Z","comments":true,"path":"2020/02/01/232/","link":"","permalink":"http://github.13sai.com/2020/02/01/232/","excerpt":"","text":"PHP DIY系列–一起手写一个api框架 上一节我们介绍了我们需要遵循的规范，这一节我们来介绍一下我们的项目中需要用到的一个依赖管理工具——Composer。 Composer 是 PHP 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。 如果你是前端工程师，你应该用过npm；如果你是pyhton开发者，你应该用过pip，简单说你可以这样理解composer。 composer在小册中可能经常会被提及，我们来学习一下安装和常用命令。 安装 Linux composer的安装比较简单，不建议使用yum等管理包直接install，因为有可能会修改你的默认php版本。我们可以跳过以下方式安装： curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer Windows 下载并且运行 Composer-Setup.exe，它将安装最新版本的 Composer ，建议加入系统的环境变量，这样你就可以在任何目录下直接使用 composer 命令。 修改镜像源默认镜像源国内下载比较慢，建议更换镜像源 composer config -g repo.packagist composer https://packagist.phpcomposer.com 也可以使用阿里的镜像源(推荐) composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ config -g/–global 表示全局配置 composer常用命令init初始化12345678参数：--name: 包的名称。--description: 包的描述。--author: 包的作者。--homepage: 包的主页。--require: 需要依赖的其它包，必须要有一个版本约束。并且应该遵循 foo/bar:1.0.0 这样的格式。--require-dev: 开发版的依赖包，内容格式与 --require 相同。--stability (-s): minimum-stability 字段的值。 require增加require 命令增加新的依赖包到当前目录的 composer.json 文件中，并可以指定版本。 composer require vendor/package:2.* vendor/package2:dev-master install安装install 命令从当前目录读取 composer.json 文件，处理了依赖关系，并把其安装到 vendor 目录下。 如果当前目录下存在 composer.lock 文件，它会从此文件读取依赖版本，而不是根据 composer.json 文件去获取依赖。这确保了该库的每个使用者都能得到相同的依赖版本。 如果没有 composer.lock 文件，composer 将在处理完依赖关系后创建它。 你可以简单把composer.lock理解为扩展库的缓存。 update更新为了获取依赖的最新版本，并且更新 composer.lock 文件，你应该使用 update 命令。 composer update 这将解决项目的所有依赖，并将确切的版本号写入 composer.lock。 如果你只是想更新几个包，你可以像这样分别列出它们： composer update vendor/package vendor/package2 ==注意==：update命令会更新composer.json里限定版本的最新依赖。比如你写的是”monolog/monolog”: “1.*”,update命令可能会把1.0更新为1.2版本，但不会将1.0更新为2.0。所以使用时需要注意。 searchsearch 命令允许你为当前项目搜索依赖包，通常它只搜索 packagist.org 上的包，你可以简单的输入你的搜索条件。 show列出所有可用的软件包，你可以使用 show 命令。 也可以点击查看更多composer包 dump-autoload打印自动加载索引，某些情况下你需要更新 autoloader，例如在你的包中加入了一个新的类。你可以使用 dump-autoload 来完成，而不必执行 install 或 update 命令。 此外，它可以打印一个优化过的，符合 PSR-0/4 规范的类的索引，这也是出于对性能的可考虑。在大型的应用中会有许多类文件，而 autoloader 会占用每个请求的很大一部分时间，使用 classmaps 或许在开发时不太方便，但它在保证性能的前提下，仍然可以获得 PSR-0/4 规范带来的便利。 更composer多命令请点击查看 好了，这一节我们介绍了composer的安装和常用命令。我们后面可以将框架集成到一个composer包，分享给其他开发同学使用。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"系列文章---基础篇：1.PSR","slug":"系列文章-基础篇：1-PSR","date":"2020-02-01T02:54:13.000Z","updated":"2020-12-09T10:37:16.418Z","comments":true,"path":"2020/02/01/231/","link":"","permalink":"http://github.13sai.com/2020/02/01/231/","excerpt":"","text":"PHP DIY系列–一起手写一个api框架 PHP DIY系列–一起手写一个api框架 创作初衷 有没有用烦了CURD？ 各种框架是不是有点头大？ 有没有尝试自己设计一个框架？ 学了PHP语法，没有项目去实战，夯实基础 希望能帮助能让你快速地搭建一个自己的框架，能给你的工作或者学习中带来一定的帮助与启发。 你能学到什么 PSR规范 composer的使用 快速搭建一个API接口框架 Redis各种数据类型的应用 缓存应用分析 在开发框架之前，我来介绍框架开发遵循的规范。 大多数编程语言都有自己的一套编码规范，作为“世界上最好的语言”，PHP当然也有自己的编码规范。这个规范就是PHP Standard Recommendation（简称PSR）。 当然，从我自己的工作中，我发现很多PHP程序员尤其是初级程序员，是不知道PHP是有这么一个规范的，我认为这是不科学的。 什么是PSR？介绍PSR之前需要介绍一下制定此规范的组织—–PHP-FIG，全称是PHP Framework Interoperability。 组织成员制定规范，并且落实在自己的项目中，虽然不是官方组织，但也代表了大部分PHP社区项目，如CakePHP，Composer，Drupal，PEAR，Slim，Yii framework，Zend Framework等。并且有越来越多的项目加入并遵循此标准。 PSR项目的目的在于：通过框架作者或者框架的代表之间讨论，以最低程度的限制，制定一个协作标准，各个框架遵循统一的编码规范，让工程师一起更好协同工作。 截止目前，已经官网已有20条列出，除去起草中和舍弃的，有以下13条。 我们不妨来看看这些规范： PSR-1 基础编码规范 PHP 代码文件必须以 &lt;?php 或 &lt;?= 标签开始 PHP 代码文件必须以不带BOM的UTF-8编码 PHP 代码中 应该 只定义类、函数、常量等声明，或其他会产生 副作用 的操作（如：生成文件输出以及修改 .ini 配置文件等），二者只能选其一 命名空间以及类必须符合 PSR 的自动加载规范PSR-4 类的命名必须遵循 StudlyCaps 式大写开头的驼峰命名规范 类中的常量所有字母都必须 大写，单词间用下划线分隔 方法名称必须符合 camelCase 式的小写开头驼峰命名规范 PSR-12 代码风格规范PSR-12的规范很细致，包含了声明、命名空间、类及继承以及控制结构等说明。 我们先来看一个demo： 1234567891011121314151617181920212223242526272829303132&lt;?phpdeclare(strict_types=1);namespace Vendor\\Package;use Vendor\\Package\\&#123;ClassA as A, ClassB, ClassC as C&#125;;use Vendor\\Package\\SomeNamespace\\ClassD as D;use function Vendor\\Package\\&#123;functionA, functionB, functionC&#125;;use const Vendor\\Package\\&#123;ConstantA, ConstantB, ConstantC&#125;;class Foo extends Bar implements FooInterface&#123; public function sampleFunction(int $a, int $b = null): array &#123; if ($a === $b) &#123; bar(); &#125; elseif ($a &gt; $b) &#123; $foo-&gt;bar($arg1); &#125; else &#123; BazClass::bar($arg2, $arg3); &#125; &#125; final public static function bar() &#123; // method body &#125;&#125; 代码 必须 遵循 [PSR-1] 中的编码规范 所有PHP文件必须使用Unix LF (linefeed)作为行的结束符； 所有PHP文件必须以一个空白行作为结束； 纯PHP代码文件必须省略最后的 ?&gt; 结束标签 每行的字符数 应该软性保持在 80 个之内，理论上 一定不可 多于 120 个，但一定不可有硬性限制；非空行后一定不能有多余的空格符； 空行可以使得阅读代码更加方便以及有助于代码的分块。 每行一定不能存在多于一条语句 代码必须使用4个空格符的缩进，一定不能用 tab键 PHP所有关键字必须全部小写 控制结构的基本规范如下：123456控制结构关键词后必须有一个空格。左括号 ( 后一定不能有空格。右括号 ) 前也一定不能有空格。右括号 ) 与开始花括号 &#123; 间一定有一个空格。结构体主体一定要有一次缩进。结束花括号 &#125; 一定在结构体主体后单独成行。 代码风格规范内容很多，这里就不一一说明了，大家可自行阅读 PSR-4 自动加载关于由文件路径 自动载入 对应类的相关规范， 本规范是可互操作的，可以作为任一自动载入规范的补充，其中包括 PSR-0，此外， 本 PSR 还包括自动载入的类对应的文件存放路径规范。 此处的“类”泛指所有的class类、接口、traits可复用代码块以及其它类似结构。 一个完整的类名需具有以下结构: \\&lt;命名空间&gt;(\\&lt;子命名空间&gt;)*\\&lt;类名&gt; 完整的类名必须要有一个顶级命名空间，被称为 “vendor namespace”； 完整的类名可以有一个或多个子命名空间； 完整的类名必须有一个最终的类名； 完整的类名中任意一部分中的下划线都是没有特殊含义的； 完整的类名可以由任意大小写字母组成； 所有类名都必须是大小写敏感的。 当根据完整的类名载入相应的文件…… 完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为“命名空间前缀”，其必须与至少一个“文件基目录”相对应； 紧接命名空间前缀后的子命名空间必须与相应的”文件基目录“相匹配，其中的命名空间分隔符将作为目录分隔符。 末尾的类名必须与对应的以 .php 为后缀的文件同名。 自动加载器（autoloader）的实现一定不能抛出异常、一定不能触发任一级别的错误信息以及不应该有返回值。 例子下表展示了符合规范完整类名、命名空间前缀和文件基目录所对应的文件路径。 完整类名 命名空间前缀 文件基目录 文件路径 \\Acme\\Log\\Writer\\File_Writer Acme\\Log\\Writer ./acme-log-writer/lib/ ./acme-log-writer/lib/File_Writer.php \\Aura\\Web\\Response\\Status Aura\\Web /path/to/aura-web/src/ /path/to/aura-web/src/Response/Status.php \\Symfony\\Core\\Request Symfony\\Core ./vendor/Symfony/Core/ ./vendor/Symfony/Core/Request.php \\Zend\\Acl Zend /usr/includes/Zend/ /usr/includes/Zend/Acl.php 暂且只介绍这比较常用的三个规范。 更多最新规范建议点击查看 本节主要介绍了PHP的编码规范PSR，建议大家在开发中尽量遵循此规范，特别是团队开发的时候，我们不应该各自有着各自的编码风格，应该尽可能统一风格。正如PHP-FIG组织的初衷所说，他们建立的规范不是限制大家的编码自由，只是寻找共性，为了我们一起更好的协同工作。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"}]},{"title":"常见排序算法","slug":"常见排序算法","date":"2020-01-31T02:10:09.000Z","updated":"2021-04-13T07:20:16.159Z","comments":true,"path":"2020/01/31/226/","link":"","permalink":"http://github.13sai.com/2020/01/31/226/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318&lt;?php/** * 排序算法php实现 */run();function run() &#123; $array = [31, 54, 6, 15, 76, 8, 35, 3, 100, 31, 45]; //01 冒泡排序 $bubbleSortArray = bubbleSort($array); //02 插入排序 $insertSortArray = insertSort($array); //03 选择排序 $selectSortArray = selectSort($array); //04 希尔排序 $shellSortArray = shellSort($array); //05 堆排序 $heapSortArray = heapSort($array); //06 归并排序 $mergeSortArray = mergeSort($array); //07 快速排序 $quickSortArray = quickSort($array); echo PHP_EOL.&quot;冒泡排序：&quot;; var_export($bubbleSortArray); echo PHP_EOL.&quot;插入排序：&quot;; var_export($insertSortArray); echo PHP_EOL.&quot;选择排序：&quot;; var_export($selectSortArray); echo PHP_EOL.&quot;希尔排序：&quot;; var_export($shellSortArray); echo PHP_EOL.&quot;堆排序：&quot;; var_export($heapSortArray); echo PHP_EOL.&quot;归并排序：&quot;; var_export($mergeSortArray); echo PHP_EOL.&quot;快速排序：&quot;; var_export($quickSortArray); return;&#125;function bubbleSort($array) &#123; /** * 01 冒泡排序 * 说明：就是第一个位置上的数与他相邻第二个位置上的数比较， * 如果比他相邻的数小，则两者交换位置，否则不交换。 * 接着第一个位置上的数与第三个位置上的数比较大小，也是小则交换， * 一直到和最后一个位置的数比较交换完毕。 * 然后，是下一个循环，就是第二个位置上的数重复上面的比较交换操作， * 直到把整个数列变成是一个从小到大的有序序列。 */ $count = count($array); for ($i = 0; $i &lt; $count; $i++) &#123; for ($j=$i+1; $j&lt;$count; $j++) &#123; if ($array[$i] &gt; $array[$j]) &#123; list($array[$i], $array[$j]) = [$array[$j],$array[$i]]; &#125; &#125; &#125; return $array;&#125;function insertSort($array) &#123; /** * 02 插入排序 * 说明：从一堆待排序的数列中选出来一个最小值(可以认为第一个数就是已排序的数列)， * 然后从剩余的带排序的数列中选出来最小值有序放到已排序的数列中， * 依次操作，直到最后的数列都是一个从小到大的有序数列为止 */ $count = count($array); for ($i = 1; $i &lt; $count; $i++) &#123; $min = $i; //拿出待排序中的最小值 for ($j = $i + 1; $j &lt; $count; $j++) &#123; if ($array[$min] &gt; $array[$j]) &#123; $min = $j; &#125; &#125; //交换，而不是直接赋值，否则会有数据丢失 swap($array[$i], $array[$min]); //拿出的值插入到已排序的数列中 for ($k=$i-1; $k&gt;=0; $k--) &#123; if ($array[$i] &lt; $array[$k]) &#123; swap($array[$i], $array[$k]); &#125; break; &#125; &#125; return $array;&#125;function selectSort($array) &#123; /** * 03 选择排序 * 说明：从一堆待排序的数列中选出来一个最小值，放到新的数组的第一个位置， * 继续从剩余的数列中选取最小值放入到数组中，重复上面的步骤，将数字都取出来排成新的有序数列 */ $count = count($array); $newArr = array(); for ($i=0; $i&lt; $count; $i++) &#123; $min = selectSortChild($array); // var_dump($min); $newArr[$i] = $array[$min]; unset($array[$min]); //unset底层源码只是将min元素指针指向了null，所以需要下面的操作，否则排序结果后几项都是NULL $array = array_merge($array, []); &#125; return $newArr;&#125;//选择排序子函数function selectSortChild($array) &#123; $count = count($array); $min = 0; //拿出带排序中的最小值 for($j = 1; $j &lt; $count; $j++) &#123; if($array[$min] &gt; $array[$j]) &#123; $min = $j; &#125; &#125; return $min;&#125;//04 希尔排序function shellSort($array) &#123; /** * 04 希尔排序 * 说明：插入排序的一种改进， * 先比较一定距离的元素成为有序数列，再比较缩小增量距离的元素(可为元素的数量的一半)， * 一直到比较的是相邻元素的时候，就成为了插入排序。 */ //三层循 $count = count($array); for ($loop = floor($count); $loop &gt; 0; $loop = floor($loop/2)) &#123; for ($i=$loop; $i&lt;$count; $i++) &#123; for ($j=$i-$loop; $j&gt;=0 &amp;&amp; $array[$j] &gt; $array[$j+$loop]; $j = $j-$loop) &#123; swap($array[$j], $array[$j+$loop]); &#125; &#125; &#125; return $array;&#125;//05 堆排序function heapSort($array)&#123; /** * 05 堆排序 说明： * 1) 构造大顶堆 * 2）交换堆顶和堆底 * 3)重复前面的步骤升序排列完成 */ $count = count($array); //1. 构造大顶堆 for ($i=floor($count/2) - 1; $i&gt;=0; $i--) &#123; adjustHeap($array, $i, $count); &#125; //2. 排序 for ($j=$count-1; $j&gt;=0; $j--) &#123; swap($array[0], $array[$j]); adjustHeap($array, 0, $j); &#125; return $array;&#125;//堆排序子函数function adjustHeap(&amp;$array, $i, $length)&#123; if($i&lt;0) return false; $tmp = $array[$i]; for ($j=$i*2+1; $j&lt;$length; $j=$j*2+1) &#123; if ($j+1&lt; $length &amp;&amp; $array[$j] &lt; $array[$j+1])//右子节点比左子节点大，则j指向右子节点 $j++; if ($array[$j] &gt; $tmp) &#123; //子节点比父节点大，则将子节点的值赋给父节点(不用交换) $array[$i] = $array[$j]; $i = $j; &#125; else &#123; break; &#125; &#125; $array[$i] = $tmp;//实现交换(i有变化时)&#125;//06 归并排序function mergeSort($array) &#123; /** * 06 归并排序 * 说明：将待排序的数列看成是单个的有序的数列， * 然后进行合并，直到合并成最后的完整有序的数列 */ //1.进行归并 $length = count($array); for ($gap = 1; $gap&lt;$length; $gap = $gap*2) &#123; mergePass($array, $gap, $length); &#125; return $array;&#125;//归并排序子函数1--合并function mergePass (&amp;$array, $gap, $length) &#123; //1. 归并长度是gap的相邻两个子表 for ($i=0; $i+2*$gap-1&lt;$length; $i=$i+2*$gap) &#123; merge($array, $i, $i+$gap-1, $i+2*$gap-1); &#125; //2. 余下的两个字表合并，后者的长度小于gap if ($i+$gap-1 &lt; $length) &#123; merge($array, $i, $i+$gap-1, $length-1); &#125;&#125;//归并排序子函数2--合并两个有序序列function merge(&amp;$array, $low, $mid, $high) &#123; $i = $low;//第一段序列的下标 $j = $mid + 1;//第二段序列的下标 $k = 0; $arrayNew = array();//新的临时合并数组 //扫描第一段序列和第二段序列，直到有一个序列扫描完毕 while ($i&lt;=$mid &amp;&amp; $j&lt;=$high) &#123; //比较两个合并的数组，小的放到新的临时合并数组中 if ($array[$i] &gt; $array[$j]) &#123; $arrayNew[$k] = $array[$j]; $k++; $j++; &#125; else &#123; $arrayNew[$k] = $array[$i]; $k++; $i++; &#125; &#125; //数组1中有没扫描的元素，直接复制到新数组中 while ($i &lt;= $mid) &#123; $arrayNew[$k] = $array[$i]; $k++; $i++; &#125; //数组2中有没扫描的元素，直接复制到新数组中 while ($j &lt;= $high) &#123; $arrayNew[$k] = $array[$j]; $k++; $j++; &#125; //将合并新数组复制到原数组中 for ($i=$low,$k=0; $i&lt;=$high; $i++,$k++) &#123; $array[$i] = $arrayNew[$k]; &#125;&#125;//交换数据function swap (&amp;$a, &amp;$b) &#123; $res = $a; $a = $b; $b = $res;&#125;function quickSort($array) &#123; // 判断是否需要运行，因下面已拿出一个中间值，这里&lt;=1 if (count($array) &lt;= 1) &#123; return $array; &#125; $middle = $array[0]; // 中间值 $left = []; // 接收小于中间值 $right = [];// 接收大于中间值 $equal = []; $equal[] = $middle; // 循环比较 for ($i=1; $i &lt; count($array); $i++) &#123; if ($middle == $array[$i]) &#123; $equal[] = $array[$i]; &#125; elseif ($middle &lt; $array[$i]) &#123; $right[] = $array[$i]; &#125; else &#123; $left[] = $array[$i]; &#125; &#125; // 递归排序划分好的2边 $left = quickSort($left); $right = quickSort($right); // 合并排序后的数据，别忘了合并中间值 return array_merge($left, $equal, $right);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://github.13sai.com/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://github.13sai.com/tags/algorithm/"}]},{"title":"Redis使用scan替换keys","slug":"Redis使用scan替换keys","date":"2020-01-26T06:49:45.000Z","updated":"2020-01-26T06:51:51.371Z","comments":true,"path":"2020/01/26/225/","link":"","permalink":"http://github.13sai.com/2020/01/26/225/","excerpt":"","text":"我们都知道查找Redis的键时，可以使用keys pattern，但当key太多时，keys命令的效率就很低，如果在线上直接使用，甚至可能发生生产事故，这时候，我们不妨使用scan命令。 SCAN 命令是一个基于游标的迭代器（cursor based iterator）： SCAN 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。当 SCAN 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。 生成key12345678910111213141516171819&lt;?php// 生成1000个$redis = new \\Redis();$redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379, 10);$redis-&gt;select(2);$arr = [ &#x27;rwer&#x27;, &#x27;24erw&#x27;, &#x27;rterq4&#x27;, &#x27;sdgfd5&#x27;, &#x27;dgsdg&#x27;, &#x27;sfst&#x27;,];for ($i=0; $i&lt;1000; $i++) &#123; $redis-&gt;set(md5($i.$arr[$i%6]), md5($arr[$i%6].&#x27;sdfsd&#x27;));&#125;echo &quot;OK&quot;.PHP_EOL; keys查看个数keys c* scan遍历1234567891011121314151617181920212223242526&lt;?php$redis = new \\Redis();$redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379, 10);$redis-&gt;select(2);$iterator = null;// 遍历前缀$pattern = &#x27;c*&#x27;;$count = 100;// 务必设置，如果没扫描到，继续扫描，而不是返回空，否则while直接退出，遍历就会不准确$redis-&gt;setOption(\\Redis::OPT_SCAN, \\Redis::SCAN_RETRY);$total = [];$i = 0;// $count可以不设置，非必需参数while($arr = $redis-&gt;scan($iterator, $pattern, $count)) &#123; $arrVal = $redis-&gt;mget($arr); $ret = array_combine($arr, $arrVal); $total = array_merge($total, $ret); $i++;&#125;// var_dump($total);var_dump($i);echo count($total).PHP_EOL; 当然你也可以不使用\\Redis::OPT_SCAN, \\Redis::SCAN_RETRY这两个参数，自行循环，判断返回值是不是false，也能遍历成功。","categories":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"}]},{"title":"Laravel配合JWT","slug":"Laravel配合JWT","date":"2020-01-20T10:07:42.000Z","updated":"2021-04-13T07:32:57.607Z","comments":true,"path":"2020/01/20/224/","link":"","permalink":"http://github.13sai.com/2020/01/20/224/","excerpt":"","text":"测试使用的是Laravel5.5版本。 安装1composer require tymon/jwt-auth=1.0.0-rc.5 配置生成配置123php artisan vendor:publish --provider=&quot;Tymon\\JWTAuth\\Providers\\LaravelServiceProvider&quot;php artisan jwt:secret auth配置123456789101112131415161718192021222324252627282930313233&lt;?phpreturn [ ... &#x27;defaults&#x27; =&gt; [ &#x27;guard&#x27; =&gt; &#x27;web&#x27;, &#x27;passwords&#x27; =&gt; &#x27;users&#x27;, ], &#x27;guards&#x27; =&gt; [ &#x27;web&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;session&#x27;, &#x27;provider&#x27; =&gt; &#x27;users&#x27;, ], // 使用jwt &#x27;api&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;jwt&#x27;, &#x27;provider&#x27; =&gt; &#x27;apiUser&#x27;, ], ], &#x27;providers&#x27; =&gt; [ ... // 指定model &#x27;apiUser&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;eloquent&#x27;, &#x27;model&#x27; =&gt; App\\ApiUser::class, ], ],]; 编码控制器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?phpnamespace App\\Http\\Controllers\\Api;use App\\ApiUser;use App\\Http\\Controllers\\Controller;use Illuminate\\Http\\Request;use Tymon\\JWTAuth\\Facades\\JWTAuth;class AuthController extends Controller&#123; /** * 中间件去除login和refresh * * @return void */ public function __construct() &#123; $this-&gt;middleware(&#x27;auth:api&#x27;, [&#x27;except&#x27; =&gt; [&#x27;login&#x27;,&#x27;refresh&#x27;]]); &#125; /** * Get a JWT via given credentials. * * @return \\Illuminate\\Http\\JsonResponse */ public function login(Request $request) &#123; $credentials = $request-&gt;only(&#x27;phone&#x27;, &#x27;password&#x27;); if (count($credentials) &lt; 2) &#123; return response()-&gt;json([&#x27;error&#x27; =&gt; &#x27;Unauthorized&#x27;], 401); &#125; $user = ApiUser::where(&#x27;phone&#x27;, $credentials[&#x27;phone&#x27;]) -&gt;where(&#x27;password&#x27;, md5($credentials[&#x27;password&#x27;])) -&gt;first(); if (empty($user) || !$token = JWTAuth::fromUser($user)) &#123; return response()-&gt;json([&#x27;error&#x27; =&gt; &#x27;Unauthorized&#x27;], 401); &#125; // dd($token); return $this-&gt;respondWithToken($token); &#125; /** * Get the authenticated User. * * @return \\Illuminate\\Http\\JsonResponse */ public function me() &#123; return response()-&gt;json(auth(&#x27;api&#x27;)-&gt;user()); &#125; /** * Log the user out (Invalidate the token). * * @return \\Illuminate\\Http\\JsonResponse */ public function logout() &#123; auth()-&gt;logout(); return response()-&gt;json([&#x27;message&#x27; =&gt; &#x27;Successfully logged out&#x27;]); &#125; /** * Refresh a token. * * @return \\Illuminate\\Http\\JsonResponse */ public function refresh() &#123; return $this-&gt;respondWithToken(auth(&#x27;api&#x27;)-&gt;refresh()); &#125; /** * Get the token array structure. * * @param string $token * * @return \\Illuminate\\Http\\JsonResponse */ protected function respondWithToken($token) &#123; return response()-&gt;json([ &#x27;access_token&#x27; =&gt; $token, &#x27;token_type&#x27; =&gt; &#x27;bearer&#x27;, &#x27;expires_in&#x27; =&gt; auth(&#x27;api&#x27;)-&gt;factory()-&gt;getTTL() * 60 ]); &#125;&#125; 路由： 此处注意，我为了方便测试，使用了get方法，生产环境不建议使用get。 12345678// routes/api.phpRoute::middleware(&#x27;api&#x27;)-&gt;prefix(&#x27;auth&#x27;)-&gt;namespace(&#x27;Api&#x27;)-&gt;group(function () &#123; Route::get(&#x27;login&#x27;, &#x27;AuthController@login&#x27;); Route::post(&#x27;logout&#x27;, &#x27;AuthController@logout&#x27;); Route::get(&#x27;refresh&#x27;, &#x27;AuthController@refresh&#x27;); Route::get(&#x27;me&#x27;, &#x27;AuthController@me&#x27;);&#125;); 测试一下: unauthenticated处理这里需要注意下，unauthenticated处理一下比较好，否则会默认跳转login登录页面。 12345678910111213141516171819202122&lt;?phpnamespace App\\Exceptions;use Exception;use Illuminate\\Foundation\\Exceptions\\Handler as ExceptionHandler;use Illuminate\\Auth\\AuthenticationException;class Handler extends ExceptionHandler&#123; ... protected function unauthenticated($request, AuthenticationException $exception) &#123; return response()-&gt;json([&#x27;message&#x27; =&gt; &#x27;Unauthenticated.&#x27;], 401); /*非api可以这么处理 return $request-&gt;expectsJson() ? response()-&gt;json([&#x27;message&#x27; =&gt; &#x27;Unauthenticated.&#x27;], 401) : redirect()-&gt;guest(route(&#x27;login&#x27;)); */ &#125;&#125; 加入token refresh加入中间件代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace App\\Http\\Middleware; use Closure;use Tymon\\JWTAuth\\Facades\\JWTAuth;use Tymon\\JWTAuth\\Exceptions\\JWTException;use Illuminate\\Auth\\AuthenticationException;use Tymon\\JWTAuth\\Exceptions\\TokenExpiredException;use Illuminate\\Http\\Exceptions\\HttpResponseException;use Tymon\\JWTAuth\\Http\\Middleware\\BaseMiddleware;class RefreshToken extends BaseMiddleware&#123; /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; try&#123; //检查请求中是否带有token 如果没有token值则抛出异常 $this-&gt;checkForToken($request); if ($request-&gt;user = JWTAuth::parseToken()-&gt;authenticate()) &#123; return $next($request); &#125; throw new AuthenticationException(&#x27;Unauthorized&#x27;, []); &#125;catch (TokenExpiredException $exception)&#123; //返回特殊的code throw new HttpResponseException(response()-&gt;json([ &#x27;message&#x27; =&gt; &#x27;token expired&#x27; ])); &#125; catch (\\Exception $exception) &#123; throw new AuthenticationException(&#x27;Unauthorized&#x27;, []); &#125; &#125;&#125; 注册： 123456789101112131415161718&lt;?phpnamespace App\\Http;use Illuminate\\Foundation\\Http\\Kernel as HttpKernel;class Kernel extends HttpKernel&#123; ... protected $routeMiddleware = [ &#x27;token.refresh&#x27; =&gt; \\App\\Http\\Middleware\\RefreshToken::class, &#x27;auth.basic&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, &#x27;bindings&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, &#x27;can&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class, &#x27;guest&#x27; =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, &#x27;throttle&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, ];&#125; 相应的控制器构造函数修改： 1234public function __construct()&#123; $this-&gt;middleware(&#x27;token.refresh&#x27;, [&#x27;except&#x27; =&gt; [&#x27;login&#x27;,&#x27;refresh&#x27;]]);&#125; 把token时间设置成1分钟，测试一下。 可以根据api返回，去调用刷新接口。 简单使用就是这样啦。更多使用可以看下站内其他文章：JWT 完整使用详解jwt-auth文档","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"},{"name":"Laravel","slug":"Laravel","permalink":"http://github.13sai.com/tags/Laravel/"},{"name":"jwt","slug":"jwt","permalink":"http://github.13sai.com/tags/jwt/"}]},{"title":"Laravel统一错误处理","slug":"Laravel统一错误处理","date":"2020-01-20T05:54:24.000Z","updated":"2021-04-13T07:33:02.242Z","comments":true,"path":"2020/01/20/223/","link":"","permalink":"http://github.13sai.com/2020/01/20/223/","excerpt":"","text":"Laravel中的App\\Exceptions\\Handler 类负责记录应用程序触发的所有异常，这在我们开发过程中十分方便，总是try…catch使代码太过繁琐且可读性大大降低，那么怎么使用它处理异常为json呢？ 我们可以新建一个class，用来处理异常返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php/** * Author: sai * Date: 2020/1/15 * Time: 14:31 */namespace App\\Exceptions;class ApiException extends \\Exception&#123; const ERROR_CODE = 1001; const ERROR_MSG = &#x27;ApiException&#x27;; private $data = []; /** * BusinessException constructor. * * @param string $message * @param string $code * @param array $data */ public function __construct(string $message, string $code, $data = []) &#123; $this-&gt;code = $code ? : self::ERROR_CODE; $this-&gt;message = $message ? : self::ERROR_MSG; $this-&gt;data = $data; &#125; /** * @return array */ public function getData() &#123; return $this-&gt;data; &#125; /** * 异常输出 */ public function render($request) &#123; return response()-&gt;json([ &#x27;data&#x27; =&gt; $this-&gt;getData(), &#x27;code&#x27; =&gt; $this-&gt;getCode(), &#x27;messgae&#x27; =&gt; $this-&gt;getMessage(), ], 200); &#125;&#125; 然后我们在Handler加入，加入$dontReport，便不会使用自带的错误处理，而使用自定义的处理。 123456789101112131415161718&lt;?phpnamespace App\\Exceptions;use Exception;use Illuminate\\Foundation\\Exceptions\\Handler as ExceptionHandler;class Handler extends ExceptionHandler&#123; /** * 一些不需管或不需要抛出的异常 */ protected $dontReport = [ ApiException::class, ]; ...&#125; 我们测试一下： 12345678910111213141516&lt;?phpnamespace App\\Http\\Controllers;use App\\Exceptions\\ApiException;use Illuminate\\Http\\Request;class HomeController extends Controller&#123; public function index(Request $request) &#123; throw new ApiException(&#x27;error&#x27;, 10001, [&#x27;oh&#x27; =&gt; &#x27;no&#x27;]); return 1; &#125;&#125; 查看输出： 测试ok，我们可以愉快的使用啦。当然，其他形式的错误输出可以自行扩展。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://github.13sai.com/tags/Laravel/"}]},{"title":"ElementUI整合编辑器vue-quill-editor","slug":"ElementUI整合编辑器vue-quill-editor","date":"2020-01-08T10:13:38.000Z","updated":"2021-04-13T07:30:22.924Z","comments":true,"path":"2020/01/08/222/","link":"","permalink":"http://github.13sai.com/2020/01/08/222/","excerpt":"","text":"直接上代码： main.js 1234567import VueQuillEditor from &#x27;vue-quill-editor&#x27;import &#x27;quill/dist/quill.core.css&#x27;import &#x27;quill/dist/quill.snow.css&#x27;import &#x27;quill/dist/quill.bubble.css&#x27;Vue.use(VueQuillEditor) template: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106...&lt;el-form-item label=&quot;详情&quot; prop=&quot;content&quot;&gt; &lt;quill-editor v-model=&quot;form.remark&quot; ref=&quot;myQuillEditor&quot; :options=&quot;editorOption&quot; @blur=&quot;onEditorBlur($event)&quot; @focus=&quot;onEditorFocus($event)&quot; @change=&quot;onEditorChange($event)&quot;&gt; &lt;/quill-editor&gt;&lt;/el-form-item&gt;&lt;div style=&quot;display:none;&quot;&gt; &lt;el-upload class=&quot;edit-uploader&quot; :action=&quot;uploadPicUrl&quot; :show-file-list=&quot;false&quot; :headers=&quot;header&quot; :on-success=&quot;editorUploadSuccess&quot; :on-error=&quot;editorUploadError&quot; :before-upload=&quot;beforeEditorUpload&quot; &gt; &lt;i class=&quot;el-icon-plus avatar-uploader-icon&quot; ref=&quot;aUpload&quot;&gt;&lt;/i&gt; &lt;/el-upload&gt;&lt;/div&gt;... &lt;script&gt;export default &#123; data() &#123; return &#123; editorOption: &#123; modules: &#123; toolbar: &#123;container:[ [&#x27;bold&#x27;, &#x27;italic&#x27;, &#x27;underline&#x27;, &#x27;strike&#x27;], [&#x27;blockquote&#x27;, &#x27;code-block&#x27;], [&#123; &#x27;header&#x27;: 1 &#125;, &#123; &#x27;header&#x27;: 2 &#125;], [&#123; &#x27;list&#x27;: &#x27;ordered&#x27; &#125;, &#123; &#x27;list&#x27;: &#x27;bullet&#x27; &#125;], [&#123; &#x27;script&#x27;: &#x27;sub&#x27; &#125;, &#123; &#x27;script&#x27;: &#x27;super&#x27; &#125;], [&#123; &#x27;indent&#x27;: &#x27;-1&#x27; &#125;, &#123; &#x27;indent&#x27;: &#x27;+1&#x27; &#125;], [&#123; &#x27;direction&#x27;: &#x27;rtl&#x27; &#125;], [&#123; &#x27;size&#x27;: [&#x27;small&#x27;, false, &#x27;large&#x27;, &#x27;huge&#x27;] &#125;], [&#123; &#x27;header&#x27;: [1, 2, 3, 4, 5, 6, false] &#125;], [&#123; &#x27;font&#x27;: [] &#125;], [&#123; &#x27;color&#x27;: [] &#125;, &#123; &#x27;background&#x27;: [] &#125;], [&#123; &#x27;align&#x27;: [] &#125;], [&#x27;clean&#x27;], [&#x27;link&#x27;, &#x27;image&#x27;] ], handlers: &#123; &#x27;image&#x27;: function(value) &#123; if (value) &#123; document.querySelector(&#x27;.edit-uploader input&#x27;).click() &#125; else &#123; this.quill.format(&#x27;image&#x27;, false); &#125; // this.$refs.aUpload.click() //自定义图片上传回调 &#125; &#125; &#125;, syntax: &#123; highlight: text =&gt; hljs.highlightAuto(text).value &#125; &#125;, &#125; &#125; &#125;, methods: &#123; onEditorReady(editor) &#123; // 准备编辑器 &#125;, onEditorBlur()&#123;&#125;, // 失去焦点事件 onEditorFocus()&#123;&#125;, // 获得焦点事件 onEditorChange()&#123;&#125;, // 内容改变事件 beforeEditorUpload() &#123; // 显示loading动画 this.quillUpdateImg = true &#125;, editorUploadSuccess(res, file) &#123; // 获取富文本组件实例 let quill = this.$refs.myQuillEditor.quill // 如果上传成功 if (res.code === 0) &#123; // 获取光标所在位置 let length = quill.getSelection().index; // 插入图片 res.info为服务器返回的图片地址 quill.insertEmbed(length, &#x27;image&#x27;, res.data.filepath) // 调整光标到最后 quill.setSelection(length + 1) &#125; else &#123; this.$message.error(&#x27;图片插入失败&#x27;) &#125; // loading动画消失 this.quillUpdateImg = false &#125;, // 富文本图片上传失败 editorUploadError() &#123; // loading动画消失 this.quillUpdateImg = false this.$message.error(&#x27;图片插入失败&#x27;) &#125; &#125;&#125;&lt;/script&gt; 这里需要注意的是，编辑器默认使用base64上传，我们使用elementui的上传组件替换掉原来的图片上传。","categories":[{"name":"vue","slug":"vue","permalink":"http://github.13sai.com/categories/vue/"}],"tags":[{"name":"ElementUI","slug":"ElementUI","permalink":"http://github.13sai.com/tags/ElementUI/"}]},{"title":"javascript签名直传OSS","slug":"javascript签名直传OSS","date":"2020-01-08T10:13:07.000Z","updated":"2020-12-09T10:42:59.327Z","comments":true,"path":"2020/01/08/221/","link":"","permalink":"http://github.13sai.com/2020/01/08/221/","excerpt":"","text":"最近在写后台代码，使用的是VUE+ElementUI，踩了一些坑分享一下。 原理：从服务端获取签名，js直接上传阿里云OSS服务器。 elementui主要代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657template:&lt;el-form-item label=&quot;上传图片&quot; prop=&quot;video&quot;&gt; &lt;el-upload id=&quot;video&quot; action :data=&quot;aliyunOssToken&quot; :http-request=&quot;uploadVideo&quot; :headers=&quot;header&quot;&gt; &lt;img v-if=&quot;form.cover&quot; :src=&quot;form.cover&quot;&gt; &lt;el-button class=&quot;avatar-uploader-icon&quot; type=&quot;primary&quot;&gt;上传&lt;/el-button&gt; &lt;/el-upload&gt;&lt;/el-form-item&gt;script：upload(file)&#123; var _self = this; let imgType = file.file.type.split(&quot;/&quot;)[1].toLowerCase(); if (imgType != &#x27;jpg&#x27; &amp;&amp; imgType != &#x27;png&#x27;) &#123; this.$message.error(&#x27;请上传图片类型&#x27;); return; &#125; getOSSToken().then(function(res)&#123; _self.aliyunOssToken = res.data; var ossData = &#123;&#125;; //key就代表文件层级和阿里云上的文件名 let imgType = file.file.type.split(&quot;/&quot;)[1]; let filename = file.file.name + file.file.size; //md5对图片名称进行加密 let keyValue = &quot;images/&quot; + md5(new Date() + filename) + &quot;.&quot; + imgType; // 组装formdata let formdata = new FormData(); formdata.append(&#x27;name&#x27;, file.file.name) formdata.append(&#x27;key&#x27;, keyValue) formdata.append(&#x27;policy&#x27;, _self.aliyunOssToken.policy) formdata.append(&#x27;OSSAccessKeyId&#x27;, _self.aliyunOssToken.accessid) formdata.append(&#x27;success_action_status&#x27;, 200) formdata.append(&#x27;signature&#x27;, _self.aliyunOssToken.signature) formdata.append(&#x27;file&#x27;, file.file) _self.uploadOSS(formdata, _self.aliyunOssToken.host).then(function(res)&#123; _self.form.cover = _self.aliyunOssToken.host + &#x27;/&#x27; + keyValue; _self.$message.success(&#x27;上传成功&#x27;); &#125;).catch(function(error)&#123; _self.$message.error(&#x27;上传失败&#x27;); console.log(error); &#125;) &#125;).catch(function(error)&#123; console.log(error); &#125;)&#125;,uploadOSS(formData, url) &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;multipart/form-data;boundary=&quot;+new Date().getTime() &#125; &#125;; return axios.post(url,formData,config);&#125; 其中：务必使用表单提交方式，aliyunOssToken格式如下 12345678&#123; &quot;accessid&quot;: &quot;LToofXWKudxfoAlI&quot;, &quot;host&quot;: &quot;https:\\/\\/xxx.oss-cn-hangzhou.aliyuncs.com&quot;, &quot;policy&quot;: &quot;eyJleHBpcmF0eretaW9uIjoiQxODowNzowMFoiLCJjb25kaXRpb25zIjpbWyJjb250ZW50LWxlbmd0aC17ewreMDQ4NTc2MDAwXSxbInN0YXJ0cy13aXRoIiwiJGtleSIsInZpZGVvXC8iXV19&quot;, &quot;signature&quot;: &quot;HRFJ4345VIvRhrsMa44546=&quot;, &quot;expire&quot;: 1578478020, &quot;dir&quot;: &quot;images\\/&quot;&#125; 记得设置阿里云OSS跨域规则： 文档： javascript签名直传","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"wrk压测使用","slug":"wrk压测使用","date":"2019-12-30T10:12:46.000Z","updated":"2019-12-30T10:13:51.968Z","comments":true,"path":"2019/12/30/220/","link":"","permalink":"http://github.13sai.com/2019/12/30/220/","excerpt":"","text":"最近有需要做一些压力测试，之前一直用ab，用起来不是很舒服，最近有使用wrk，轻量好用。 安装12345git clone https://github.com/wg/wrk.git wrkcd wrkmake# move the executable to somewhere in your PATHsudo cp wrk /somewhere/in/your/PATH 默认情况下wrk会使用自带的LuaJIT和OpenSSL，如果你想使用系统已安装的版本，可以使用WITH_LUAJIT和WITH_OPENSSL这两个选项来指定它们的路径。比如： 1make WITH_LUAJIT=/usr WITH_OPENSSL=/usr 使用说明1234567891011121314wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt; Options: -c, --connections &lt;N&gt; 跟服务器建立并保持的TCP连接数量 -d, --duration &lt;T&gt; 压测时间 -t, --threads &lt;N&gt; 使用多少个线程进行压测 -s, --script &lt;S&gt; 指定Lua脚本路径 -H, --header &lt;H&gt; 为每一个HTTP请求添加HTTP头 --latency 在压测结束后，打印延迟统计信息 --timeout &lt;T&gt; 超时时间 -v, --version 打印正在使用的wrk的详细版本信息 &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G) &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h) 测试123456789101112131415161718192021222324252627282930313233wrk -t8 -c200 -d30s --latency &quot;http://www.bing.com&quot;输出：Running 30s test @ http://www.bing.com 8 threads and 200 connections Thread Stats Avg Stdev Max +/- Stdev Latency 46.67ms 215.38ms 1.67s 95.59% Req/Sec 7.91k 1.15k 10.26k 70.77% Latency Distribution 50% 2.93ms 75% 3.78ms 90% 4.73ms 99% 1.35s 1790465 requests in 30.01s, 684.08MB readRequests/sec: 59658.29Running 30s test @ http://www.bing.com （压测时间30s） 8 threads and 200 connections （共8个测试线程，200个连接） Thread Stats Avg Stdev Max +/- Stdev （平均值） （标准差）（最大值）（正负一个标准差所占比例） Latency 46.67ms 215.38ms 1.67s 95.59% （延迟） Req/Sec 7.91k 1.15k 10.26k 70.77% （处理中的请求数） Latency Distribution （延迟分布） 50% 2.93ms 75% 3.78ms 90% 4.73ms 99% 1.35s （99分位的延迟） 1790465 requests in 30.01s, 684.08MB read （30.01秒内共处理完成了1790465个请求，读取了684.08MB数据）Requests/sec: 59658.29 （平均每秒处理完成59658.29个请求）Transfer/sec: 22.79MB （平均每秒读取数据22.79MB） lua脚本使用1234567--data.lualocal data= &quot;&#123;.count.:1&#125;&quot;wrk.headers[&quot;Content-Type&quot;] = &quot;application/jason&quot;wrk.method = &quot;POST&quot;function request() return wrk.format(&#x27;POST&#x27;, nil, nil, data)end 测试： 1wrk -t500 -c1000 -d1s --script=data.lua --latency https://github.13sai.com/ 个人用了几次，感觉比ab好用，推荐一下。 参考：Http压测工具wrk使用指南wrk","categories":[{"name":"test","slug":"test","permalink":"http://github.13sai.com/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"http://github.13sai.com/tags/test/"}]},{"title":"gomodules","slug":"gomodules","date":"2019-12-27T10:32:26.000Z","updated":"2019-12-27T10:34:10.415Z","comments":true,"path":"2019/12/27/219/","link":"","permalink":"http://github.13sai.com/2019/12/27/219/","excerpt":"","text":"modulesmodules在go的1.11版本中加入，并在最新的Go 1.13中对模块进行了重大改进和更改。 1.13版本前请务必开启模块 export GO111MODULE=auto 初始化在你的项目目录中执行： go mod init 13sai/game 会生成go.mod 1234module 13sai/gamego 1.12 然后你可以尽情编写你的项目代码，在你每次go get的时候，modules也会将你的安装的package加入go.mod 123456module 13sai/gamego 1.12require github.com/gin-gonic/gin v1.5.0 // indirect 当然，你也可以像我一样，先去写代码，不去初始化modules，写完代码之后，初始化，然后执行： go run main.go 当然，如果你没有翻墙，也没有使用国内镜像，很可能很多包都下载失败。 Goproxy 中国Go 1.13 及以上（推荐）打开你的终端并执行： 1$ go env -w GOPROXY=https://goproxy.cn,direct 完成。 macOS 或 Linux打开你的终端并执行： 1$ export GOPROXY=https://goproxy.cn 或者 1$ echo &quot;export GOPROXY=https://goproxy.cn&quot; &gt;&gt; ~/.profile &amp;&amp; source ~/.profile 完成。 Windows打开你的 PowerShell 并执行： 1C:\\&gt; $env:GOPROXY = &quot;https://goproxy.cn&quot; 或者 123456781. 打开“开始”并搜索“env”2. 选择“编辑系统环境变量”3. 点击“环境变量…”按钮4. 在“&lt;你的用户名&gt; 的用户变量”章节下（上半部分）5. 点击“新建…”按钮6. 选择“变量名”输入框并输入“GOPROXY”7. 选择“变量值”输入框并输入“https://goproxy.cn”8. 点击“确定”按钮 完成。 本地包处理本地宝使用这样的方式引入（local.com/13sai/game） 然后执行： 12$ go mod edit -require=local.com/13sai/game@v1.0.0$ go mod edit -replace=local.com/13sai/game@v1.0.0=$PWD vendor备份 go mod vendor 可以将modules下载到本地vendor目录，其中也包含上面的本地包。 其他12345go mod tidy //整理模块（拉取缺少的模块，移除不用的模块）go mod download//下载依赖包到本地缓存go mod graph //打印现有依赖结构go mod verify //校验依赖go mod why //解释为什么需要此模块 Modules的wiki","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"五大网络IO模型","slug":"五大网络IO模型","date":"2019-12-26T14:41:33.000Z","updated":"2021-04-13T07:28:13.154Z","comments":true,"path":"2019/12/26/218/","link":"","permalink":"http://github.13sai.com/2019/12/26/218/","excerpt":"","text":"Linux五大网络IO模型图解 阻塞io(同步io)：1发起请求就一直等待，直到数据返回。好比你去商场试衣间，里面有人，那你就一直在门外等着。(全程阻塞) 非阻塞io(同步io)：1不管有没有数据都返回，没有就隔一段时间再来请求，如此循环。好比你要喝水，水还没烧开，你就隔段时间去看一下饮水机，直到水烧开为止。(复制数据时阻塞) io复用(同步io)：12345I/O是指网络I/O,多路指多个TCP连接(即socket或者channel）,复用指复用一个或几个线程。意思说一个或一组线程处理多个连接。比如课堂上学生做完了作业就举手，老师就下去检查作业。(对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听，可以同时对多个读/写操作的IO函数进行轮询检测，直到有数据可读或可写时，才真正调用IO操作函数。) 信号驱动io(同步io)：12事先发出一个请求，当有数据后会返回一个标识回调，这时你可以去请求数据。好比银行排号，当叫到你的时候，你就可以去处理业务了(复制数据时阻塞)。 异步io：1发出请求就返回，剩下的事情会异步自动完成，不需要做任何处理。好比有事秘书干，自己啥也不用管。 总结：五种IO的模型：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO和异步IO；前四种都是同步IO，在内核数据copy到用户空间时都是阻塞的。 阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果会那就是传统的阻塞IO，如果不会那就是非阻塞IO。 同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO；如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"}]},{"title":"Nginx工作模式和进程模型","slug":"Nginx工作模式和进程模型","date":"2019-12-20T10:10:56.000Z","updated":"2021-04-13T07:33:44.664Z","comments":true,"path":"2019/12/20/216/","link":"","permalink":"http://github.13sai.com/2019/12/20/216/","excerpt":"","text":"工作模式 Nginx启动后，会产生一个master主进程，主进程执行一系列的工作后会产生一个或者多个工作进程worker 在客户端请求动态站点的过程中，Nginx服务器还涉及和后端服务器的通信。Nginx将接收到的Web请求通过代理转发到后端服务器，由后端服务器进行数据处理和组织; Nginx为了提高对请求的响应效率，降低网络压力，采用了缓存机制，将历史应答数据缓存到本地。保障对缓存文件的快速访问 进程模型nginx的进程模型，可以由下图来表示： master进程主要用来管理 worker 进程，master进程会接收来自外界发来的信号，再根据信号做不同的事情。所以我们要控制nginx，只需要通过kill向master进程发送信号就行了。 具体包括以下主要功能: 接收来自外界的信号 向各worker进程发送信号 监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程 重启说明（示例）比如kill -HUP pid，则是告诉nginx，重启nginx，早期版本可以用这个信号来重启nginx，因为是从容地重启，因此服务是不中断的。（现在一般使用nginx -s reload） master进程在接收到HUP信号后，会先重新加载配置文件，然后再启动新的worker进程，并向所有老的worker进程发送信号，告诉他们可以光荣退休了。新的worker在启动后，就开始接收新的请求，而老的worker在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。 （master不需要处理网络事件，不负责业务的执行） worker进程主要任务是完成具体的任务逻辑。其主要关注点是与客户端或后端真实服务器(此时 worker 作为中间代理)之间的数据可读/可写等I/O交互事件。具体包括以下主要功能: 接收客户端请求; 将请求一次送入各个功能模块进行过滤处理; 与后端服务器通信，接收后端服务器处理结果; 数据缓存proxy_cache模块 响应客户端请求 （一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。） worker进程是如何处理请求的？首先，worker进程之间是平等的，每个worker进程都是从master进程fork过来，在master进程里面，先建立好需要listen的socket（listenfd）之后，然后再fork出多个worker进程。每个worker进程，处理请求的机会也是一样的。当一个连接请求过来，每个进程都有可能处理这个连接，怎么做的呢？ 所有worker进程的listenfd会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有worker进程在注册listenfd读事件前抢accept_mutex，抢到互斥锁的那个worker进程注册listenfd读事件，在读事件里调用accept接受该连接。 当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后断开连接，这样就是一个完整的请求就是这样的了。 我们可以了解到一个请求，完全由worker进程来处理，且只在一个worker进程中处理。 Nginx采用的IO多路复用模型 IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程，目前支持I/O多路复用的系统调用有 select ， poll ， epoll ，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符(socket)，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读 写操作。 select基本原理select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。 优点 目前几乎在所有的平台上支持 缺点 select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是： select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。（一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max查看。32位机默认是1024个。64位机默认是2048） 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。（当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的） 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。 poll基本原理poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。 优点 它没有最大连接数的限制，原因是它是基于链表来存储的。 缺点 大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。 poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。 注意：从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。 epollepoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。 基本原理epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。 epoll对文件描述符的操作有两种模式LT（level trigger）和ET（edge trigger）。LT模式是默认模式，两者区别如下： LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。 ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。 优点 没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。 只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。 kqueuekqueue与epoll非常相似，最初是2000年Jonathan Lemon在FreeBSD系统上开发的一个高性能的事件通知接口。注册一批socket描述符到 kqueue 以后，当其中的描述符状态发生变化时，kqueue 将一次性通知应用程序哪些描述符可读、可写或出错了。只是适应平台不多。 参考： 网络通信 –&gt; IO多路复用之select、poll、epoll详解 nginx平台初探 这应该是Nginx系列最后一篇文章了，如果你有疑问，欢迎交流，水平有限，错误欢迎指正。 技术文章也发布在自己的公众号【爱好历史的程序员】，欢迎扫码关注，谢谢！","categories":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/tags/nginx/"}]},{"title":"gRPC初体验","slug":"gRPC初体验","date":"2019-12-20T03:12:47.000Z","updated":"2021-04-13T07:31:04.967Z","comments":true,"path":"2019/12/20/215/","link":"","permalink":"http://github.13sai.com/2019/12/20/215/","excerpt":"","text":"gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。 安装protocol buffer 编译器mac： 1brew install protobuf 其他系统可以尝试编译安装 protocolbuffers/protobuf 安装gprc1go get -u google.golang.org/grpc 安装protoc-gen-go插件1go get -u github.com/golang/protobuf/protoc-gen-go 使用新建hello目录，进入后执行： 1protoc --proto_path hello/ --go_out=plugins=grpc:hello hello.proto 会看到hello目录下生成了hello.pb.go文件。 当然，其中的 hello.proto 是预先自定义在hello文件夹下的，如： 123456789101112131415161718syntax = &quot;proto3&quot;; //语法声明package hello; //包名// 定义服务service Greeter &#123; rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;&#125;// 请求数据格式message HelloRequest &#123; string name = 1;&#125;// 响应数据格式message HelloReply &#123; string message = 1;&#125; server新建server目录，golang例子代码来自：https://github.com/grpc/grpc-go/tree/master/examples/helloworld 1234567891011121314151617181920212223242526272829303132333435363738// main.gopackage mainimport ( &quot;context&quot; &quot;log&quot; &quot;net&quot; &quot;google.golang.org/grpc&quot; pb &quot;local.com/sai/game/grpc/hello&quot;)const ( port = &quot;:50051&quot;)// server is used to implement helloworld.GreeterServer.type server struct &#123; pb.UnimplementedGreeterServer&#125;// SayHello implements helloworld.GreeterServerfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) &#123; log.Printf(&quot;Received: %v&quot;, in.GetName()) return &amp;pb.HelloReply&#123;Message: &quot;Hello &quot; + in.GetName()&#125;, nil&#125;func main() &#123; lis, err := net.Listen(&quot;tcp&quot;, port) if err != nil &#123; log.Fatalf(&quot;failed to listen: %v&quot;, err) &#125; s := grpc.NewServer() pb.RegisterGreeterServer(s, &amp;server&#123;&#125;) if err := s.Serve(lis); err != nil &#123; log.Fatalf(&quot;failed to serve: %v&quot;, err) &#125;&#125; clientgo client12345678910111213141516171819202122232425262728293031323334353637383940// client.gopackage mainimport ( &quot;context&quot; &quot;log&quot; &quot;os&quot; &quot;time&quot; &quot;google.golang.org/grpc&quot; pb &quot;local.com/sai/game/grpc/hello&quot;)const ( address = &quot;127.0.0.1:50051&quot; defaultName = &quot;13sai&quot;)func main() &#123; // Set up a connection to the server. conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock()) if err != nil &#123; log.Fatalf(&quot;did not connect: %v&quot;, err) &#125; defer conn.Close() c := pb.NewGreeterClient(conn) // Contact the server and print out its response. name := defaultName if len(os.Args) &gt; 1 &#123; name = os.Args[1] &#125; ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;) if err != nil &#123; log.Fatalf(&quot;could not greet: %v&quot;, err) &#125; log.Printf(&quot;Greeting: %s&quot;, r.GetMessage())&#125;` php client扩展安装 grpc扩展下载 profo 下载安装合适版本的扩展即可，记得别忘记在php.ini中加入： 12extension=grpc.soextension=protobuf.so 自动生成代码1protoc --php_out=client hello/hello.proto 会看到client目录下生成了GPBMetadata和Hello两个目录。 如果你对grpc相对较熟练，可以直接进行代码编写： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phprequire __DIR__ . &#x27;/vendor/autoload.php&#x27;;class Client extends \\Grpc\\BaseStub&#123; public function __construct($hostname, $opts, $channel = null) &#123; parent::__construct($hostname, $opts, $channel); &#125; /** * rpc SayHello(HelloRequest) returns (HelloReply) &#123;&#125; * 方法名尽量和 (gprc 定义 Greeter 服务)的方法一样 * 用于请求和响应该服务 */ public function SayHello(\\Hello\\HelloRequest $argument)&#123; // (/hello.Greeter/SayHello) 是请求服务端那个服务和方法，基本和 proto 文件定义一样 return $this-&gt;_simpleRequest(&#x27;/hello.Greeter/SayHello&#x27;, $argument, [&#x27;\\Hello\\HelloReply&#x27;, &#x27;decode&#x27;] ); &#125;&#125;//用于连接 服务端$client = new \\Client(&#x27;127.0.0.1:50051&#x27;, [ &#x27;credentials&#x27; =&gt; Grpc\\ChannelCredentials::createInsecure()]);//实例化 TestRequest 请求类$request = new \\Hello\\HelloRequest();$request-&gt;setName(&quot;fairy&quot;);//调用远程服务$get = $client-&gt;SayHello($request)-&gt;wait();//返回数组//$reply 是 TestReply 对象//$status 是数组list($reply, $status) = $get;echo $reply-&gt;getMessage().PHP_EOL;// print_r($client-&gt;SayHello($request)); 当然，也可以使用grpc_php_plugin插件生成。 grpc-php grpc_php_plugin插件clone太慢可以使用码云 12345git clone -b $(curl -L https://grpc.io/release) https://github.com/grpc/grpccd grpc#这一步很慢，暂未找到什么好方法git submodule update --initmake grpc_php_plugin 新建php-client，再来自动生成： 1protoc -I=./hello hello.proto --php_out=./php-client/ --grpc_out=php-client/ --plugin=protoc-gen-grpc=/Users/wangzetao/www/grpc1/bins/opt/grpc_php_plugin 会发现比上面自动生成多了一个GreeterClient.php 12345678910111213141516171819202122&lt;?php// client.phprequire __DIR__ . &#x27;/vendor/autoload.php&#x27;;//用于连接 服务端$client = new \\Hello\\GreeterClient(&#x27;127.0.0.1:50051&#x27;, [ &#x27;credentials&#x27; =&gt; Grpc\\ChannelCredentials::createInsecure()]);//实例化 TestRequest 请求类$request = new \\Hello\\HelloRequest();$request-&gt;setName(&quot;world&quot;);//调用远程服务$get = $client-&gt;SayHello($request)-&gt;wait();//返回数组//$status 是数组list($reply, $status) = $get;echo $reply-&gt;getMessage().PHP_EOL;// print_r($client-&gt;SayHello($request)); 运行测试 go run grpc/server/main.go go run grpc/client/main.go go run grpc/client/client.php go run grpc/client/php-client.php grpc初体验完成了，本次只是小小的使用了一下子，后续感兴趣的话可以深入学习一下。文中如有错误，欢迎指出交流。 技术文章也发布在自己的公众号【爱好历史的程序员】，欢迎扫码关注，谢谢！","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"http://github.13sai.com/tags/RPC/"}]},{"title":"docker安装gogs","slug":"docker安装gogs","date":"2019-12-08T13:19:39.000Z","updated":"2021-04-26T03:44:30.208Z","comments":true,"path":"2019/12/08/214/","link":"","permalink":"http://github.13sai.com/2019/12/08/214/","excerpt":"","text":"docker pull gogs/gogs docker run -itd –name=gogs1 -p 10022:22 -p 10023:3000 gogs/gogs 浏览器输入http://127.0.0.1:10023/ 主要修改的参数是 应用 URL 数据库用户密码 管理员信息 如果你有其他修改，自行修改即可。 点击立即安装按钮，按理说会跳到3000端口地址，你换成10023就好了。 然后你就可以自行创建，开始gogs之旅了。 另外，配置文件在容器的/data/gogs/conf/app.ini。 详细配置文件手册（来自github）概览 名称 描述 APP_NAME 应用名称，可以改成您的组织或公司名称 RUN_USER 运行应用的用户名称，我们建议您使用 git，但如果您在个人计算机上运行 Gogs，请修改为您的系统用户名称。如果没有正确设置这个值，很可能导致您的应用崩溃 RUN_MODE 鉴于性能和其它考虑，建议在部署环境下修改为 prod 模式。在您完成安装操作时，该值也会被设置为 prod 服务器 (server) 名称 描述 PROTOCOL http 或 https DOMAIN 服务器域名 ROOT_URL 公开的完整 URL 路径 HTTP_ADDR 应用 HTTP 监听地址 HTTP_PORT 应用 HTTP 监听端口号 UNIX_SOCKET_PERMISSION Unix 套接字文件的权限 LOCAL_ROOT_URL 用于 Gogs 工作进程（如：SSH）回访应用的本地（DMZ）URL，一般情况下请保持默认值，除非您的 SSH 服务器节点与 HTTP 并不是同一个节点入口 DISABLE_SSH 当 SSH 功能不可用时可以禁用 START_SSH_SERVER 启用该选项来启动内置 SSH 服务器 SSH_DOMAIN 允许公用网络访问 SSH 的域名 SSH_PORT SSH 端口号，如果不为 22 的话可以在此修改 SSH_LISTEN_HOST 内置 SSH 服务器监听的地址 SSH_LISTEN_PORT 内置 SSH 服务器监听的端口 SSH_ROOT_PATH SSH 根目录，一般为 ~/.ssh，但必须填写为 /home/git/.ssh REWRITE_AUTHORIZED_KEYS_AT_START 激活该选项以在应用启动时自动重写 authorized_keys 文件，该选项在使用内置 SSH 服务器时将会被自动禁用 SSH_KEY_TEST_PATH 用于测试 SSH 公钥的临时目录 SSH_KEYGEN_PATH ssh-keygen 程序的路径，默认为 ssh-keygen 即通过系统路径查找 MINIMUM_KEY_SIZE_CHECK 指定不同类型的公钥的最小密钥大小 OFFLINE_MODE 激活该选项来禁止从 CDN 获取静态资源，同时 Gravatar 服务也将被自动禁用 DISABLE_ROUTER_LOG 激活该选项来禁止打印路由日志 CERT_FILE HTTPS 授权文件路径 KEY_FILE HTTPS 的密钥文件路径 STATIC_ROOT_PATH 模板文件和静态文件的上级目录，默认为应用二进制所在的位置 APP_DATA_PATH 应用内部数据的存放目录 ENABLE_GZIP 激活该选项来启用应用级别 GZIP 支持 LANDING_PAGE 未登录用户的默认首页，可以是 home 或 explore（探索页） 仓库 (repository) 名称 描述 ROOT 用户仓库存储根目录，必须为绝对路径，默认为 ~/&lt;user name&gt;/gogs-repositories SCRIPT_TYPE 系统脚本类型，一般情况下均为 bash，但有些用户反应只能使用 sh ANSI_CHARSET 当遇到无法识别的字符集时使用的默认字符集 FORCE_PRIVATE 强制要求所有新建的仓库都是私有的 MAX_CREATION_LIMIT 全局默认的每个用户可创建创建仓库上限，-1 表示无限制 PREFERRED_LICENSES 建议用户首选的授权类型 DISABLE_HTTP_GIT 激活该选项来禁止用户通过 HTTP 对 Git 仓库进行交互操作，即用户只能通过 SSH 操作 ENABLE_LOCAL_PATH_MIGRATION 激活该选项来启用本地路径迁移仓库功能。启动后默认只有管理员可以使用，普通用户必须经由管理员授权 ENABLE_RAW_FILE_RENDER_MODE 激活该选项来启用在查看原始数据时对页面进行真实渲染，例如渲染实际的 HTML 页面，有潜在安全隐患 仓库 - 编辑器 (repository.editor) 名称 描述 LINE_WRAP_EXTENSIONS 需要显示为行包装的文件名后缀，通过逗号分隔。如果是无后缀名的文件，则单独放置一个逗号，例如：.txt, 仓库 - 文件上传 (repository.upload) 名称 描述 ENABLED 激活该选项来启用仓库文件上传功能 TEMP_PATH 文件上传的临时存放目录 ALLOWED_TYPES 允许上传的文件类型（例如：”image/jpeg|image/png”），留空表示允许上传任意类型的文件 FILE_MAX_SIZE 单个上传的文件的最大体积，以 MB 为单位 MAX_FILES 单次同时上传的最多文件个数 版本发布 - 附件 (release.attachment) 名称 描述 ENABLED 激活该选项来启用版本发布附件功能 PATH 存放附件的路径 ALLOWED_TYPES 允许上传的 MIME 类型，例如 “image/jpeg|image/png”，使用 */* 允许所有类型的文件 MAX_SIZE 最大允许上传的附件体积，单位为 MB，例如 32 MAX_FILES 最大允许一次性上传的附件个数，例如 10 Markdown (markdown) 名称 描述 ENABLE_HARD_LINE_BREAK 指示是否启用硬性换行扩展 CUSTOM_URL_SCHEMES 允许被解析为链接的自定义 URL 方案，例如 git（用于 git://）和magnet（用于 magnet://） FILE_EXTENSIONS 需要被渲染为 Markdown 格式的文件名后缀，通过逗号分隔。如果是无后缀名的文件，则单独放置一个逗号，例如：.markdown, Smartypants (smartypants) 名称 描述 ENABLED 指示是否启用 Smartypants 扩展 HTTP (http) 名称 描述 ACCESS_CONTROL_ALLOW_ORIGIN 头信息 Access-Control-Allow-Origin 的自定义值，默认为空，即不响应此头信息 数据库 (database) 名称 描述 DB_TYPE 数据库类型，可以是 mysql、postgres、mssql 或 sqlite3 HOST 数据库主机地址与端口 NAME 数据库名称 USER 数据库用户名 PASSWD 数据库用户密码 SSL_MODE 仅限 PostgreSQL 使用 PATH 仅限 SQLite3 使用，数据库文件路径 应用管理 (admin) 名称 描述 DISABLE_REGULAR_ORG_CREATION 激活该选项来禁止普通用户（非管理员）创建组织 安全 (security) 名称 描述 INSTALL_LOCK 用于指示是否允许访问安装页面（该页面可以设置管理员帐号，因此该选项非常重要） SECRET_KEY 全局的加密密钥，务必修改该值以确保您的服务器安全（会在每次安装时自动生成随机字符串） LOGIN_REMEMBER_DAYS 记住登录的天数 COOKIE_USERNAME 记录用户名的 Cookie 名称 COOKIE_REMEMBER_NAME 记录用户自动登录信息的 Cookie 名称 REVERSE_PROXY_AUTHENTICATION_USER 反向代理认证用户的 Header 字段名 服务 (service) 名称 描述 ACTIVE_CODE_LIVE_MINUTES 激活码的有效期，单位为分钟 RESET_PASSWD_CODE_LIVE_MINUTES 重置密码的有效期，单位为分钟 REGISTER_EMAIL_CONFIRM 激活该选项来要求注册用户必须验证邮箱，要求已启用 Mailer DISABLE_REGISTRATION 激活该选项来禁止用户注册功能，只能由管理员创建帐号 SHOW_REGISTRATION_BUTTON 用于指示是否显示注册按钮 REQUIRE_SIGNIN_VIEW 激活该选项来要求用户必须登录才能浏览任何页面 ENABLE_CACHE_AVATAR 激活该选项来缓存 Gravatar 的头像 ENABLE_NOTIFY_MAIL 激活该选项来发送通知邮件给关注者，例如创建 issue 时，要求已启用 Mailer ENABLE_REVERSE_PROXY_AUTHENTICATION 激活该选项来开启反向代理用户认证，请从 #165 了解更多信息 ENABLE_REVERSE_PROXY_AUTO_REGISTRATION 激活该选项来开启反向代理用户认证的自动注册功能 DISABLE_MINIMUM_KEY_SIZE_CHECK 激活该选项来禁止检查响应类型的密钥最小长度 ENABLE_CAPTCHA 激活该选项以在用户注册时要求输入验证码 Web 钩子 (webhook) 名称 描述 TYPES 启动的 Web 钩子类型，可以是 gogs、slack、discord或dingtalk QUEUE_LENGTH Web钩子队列长度，如果发现部分Webhook未能成功触发，可考虑增加该值 DELIVER_TIMEOUT 发送通知的超时时间，以秒为单位 SKIP_TLS_VERIFY 指示是否允许向具有非信任证书的地址发送通知 PAGING_NUM Web 钩子历史页面每页显示记录条数 邮件 (mailer) 名称 描述 ENABLED 启用该选项以激活邮件服务 SUBJECT_PREFIX 邮件标题的前缀 HOST SMTP 主机地址与端口 DISABLE_HELO 禁用 HELO 操作 HELO_HOSTNAME HELO 操作的自定义主机名 SKIP_VERIFY 不验证自签发证书的有效性 FROM 邮箱的来自地址，遵循 RFC 5322规范，可以是一个单纯的邮箱地址或者 &quot;名字&quot; &lt;email@example.com&gt; 的形式 USER 邮箱用户名 PASSWD 邮箱密码 USE_PLAIN_TEXT 使用 text/plain 作为邮件内容格式 备注：Gogs 仅支持使用 STARTTLS 的 SMTP 协议 缓存 (cache) 名称 描述 ADAPTER 缓存引擎适配器，可以为 memory、redis 或 memcache。如果您使用 redis 或 memcache，请确保使用 -tags 选项重新构建所有依赖，例如：go build -tags=&#39;redis&#39; INTERVAL 仅限内存缓存使用，GC 周期，单位为秒 HOST 仅限 redis 和 memcache 使用，主机地址和端口号 - Redis：network=tcp,addr=127.0.0.1:6379,password=macaron,db=0,pool_size=100,idle_timeout=180 - Memache：127.0.0.1:9090;127.0.0.1:9091 会话 (session) 名称 描述 PROVIDER Session 引擎提供者，可以是 memory、file、redis 或 mysql PROVIDER_CONFIG 如果提供者为 file，则为文件根目录；如果为其它提供者，则为主机地址和端口号 COOKIE_SECURE 激活该选项以要求所有 session 操作均通过 HTTPS GC_INTERVAL_TIME GC 周期，单位为秒 图片 (picture) 名称 描述 AVATAR_UPLOAD_PATH 存放用户上传头像的目录 GRAVATAR_SOURCE 可以是 gravatar、duoshuo 或任何 URL，例如：http://cn.gravatar.com/avatar/ DISABLE_GRAVATAR 激活该选项来仅使用本地头像 ENABLE_FEDERATED_AVATAR 激活该选项来启用 Federated 头像服务（http://www.libravatar.org），当 Gravatar 被禁用时此选项无法生效 附件 (attachment) 名称 描述 ENABLED 激活该选项以允许用户上传附件 PATH 存放附件的路径 ALLOWED_TYPES 允许上传的 MIME 类型，例如 “image/jpeg|image/png”，使用 */* 允许所有类型的文件 MAX_SIZE 最大允许上传的附件体积，单位为 MB，例如 4 MAX_FILES 最大允许一次性上传的附件个数，例如 5 时间 (time) 名称 描述 FORMAT 指定日期的输出格式，默认为 RFC1123，其它可选的格式为 ANSIC、UnixDate、RubyDate、RFC822、RFC822Z、RFC850、RFC1123、RFC1123Z、RFC3339、RFC3339Nano、Kitchen、Stamp、StampMilli、StampMicro 和 StampNano。访问 http://golang.org/pkg/time/#pkg-constants 查看详情 日志 (log) 名称 描述 ROOT_PATH 日志文件的根目录 MODE 日志记录模式，默认为 console。如果想要开启多模式，请使用逗号分割，例如：&quot;console, file&quot; LEVEL 基本日志级别，默认为 Trace 日志 - 控制台 (log.console) 名称 描述 LEVEL 控制台日志级别，留空则继承父值 日志 - 文件 (log.file) 名称 描述 LEVEL 文件日志级别，留空则继承父值 LOG_ROTATE 激活该选项以启用日志文件自转 DAILY_ROTATE 激活该选项以进行日常自转 MAX_SIZE_SHIFT 自转需要达到的最大文件体积，使用位左移，默认为 28 即 1 &lt;&lt; 28，表示 256MB MAX_LINES 自转需要达到的最大文件行数，默认为 1000000 MAX_DAYS 保留自转文件的最长期限，默认为 7 天后删除 日志 - Slack (log.slack) 名称 描述 LEVEL Slack 日志级别，留空则继承父值 URL Slack Web 钩子 URL 日志 - Discord (log.discord) 名称 描述 LEVEL Discord 日志级别，留空则继承父值 URL Discord Web 钩子 URL USERNAME 在 Web 钩子中显示的用户名 Cron (cron) 名称 描述 ENABLED 激活该选项以允许周期性运行 Cron 任务 RUN_AT_START 激活该选项以允许在启动时执行 Cron 任务 Cron - 更新镜像 (cron.update_mirrors) 名称 描述 SCHEDULE 定时更新仓库镜像的 Cron 语法，例如：@every 1h Cron - 仓库健康检查 (cron.repo_health_check) 名称 描述 SCHEDULE 定时进行仓库健康检查的 Cron 语法，例如：@every 24h TIMEOUT 仓库健康检查超时的定义语法，例如：60s ARGS git fsck 命令的参数，例如：--unreachable --tags Cron - 仓库统计检查 (cron.check_repo_stats) 名称 描述 RUN_AT_START 激活该选项以在启动时执行仓库统计检查 SCHEDULE 定时进行仓库统计检查的 Cron 语法，例如：@every 24h Cron - 仓库归档清理 (cron.repo_archive_cleanup) 名称 描述 RUN_AT_START 激活该选项以在启动时执行仓库归档清理 SCHEDULE 定时进行仓库归档清理的 Cron 语法，例如：@every 24h OLDER_THAN 仓库归档的文件有效期，过期的归档将被清理，例如：24h Git (git) 名称 描述 DISABLE_DIFF_HIGHLIGHT 激活该选项以禁用行内差异高亮 MAX_GIT_DIFF_LINES 差异对比页面单个文件显示的最大行数 MAX_GIT_DIFF_LINE_CHARACTERS 差异对比页面单行显示的最大字符数 MAX_GIT_DIFF_FILES 差异对比页面文件显示的最多个数 GC_ARGS git gc 命令的参数，例如：--aggressive --auto Git - 超时 (git.timeout) 名称 描述 MIGRATE 仓库迁移操作超时，默认为 600 秒 MIRROR 仓库镜像同步操作超时，默认为 300 秒 CLONE 仓库克隆操作超时，默认为 300 秒 PULL 仓库拉取操作超时，默认为 300 秒 GC 仓库垃圾回收操作超时，默认为 60 秒 UI (ui) 名称 描述 EXPLORE_PAGING_NUM 探索页面每页显示仓库的数量 ISSUE_PAGING_NUM 每页显示工单（Issue）的数量（应用到所有以列表形式显示工单的页面） FEED_MAX_COMMIT_NUM 一条最新活动中显示代码提交（Commit）的最大数量 THEME_COLOR_META_TAG 被用于 Android &gt;= 5.0 版本 “theme-color” 标记的值，无效的值将被忽略并使用默认值（查看详情） MAX_DISPLAY_FILE_SIZE 显示到页面的最大文件体积（Byte） UI - Admin (ui.admin) 名称 描述 USER_PAGING_NUM 用户管理页面每页显示记录条数 REPO_PAGING_NUM 仓库管理页面每页显示记录条数 NOTICE_PAGING_NUM 系统提示管理页面每页显示记录条数 ORG_PAGING_NUM 组织管理页面每页显示记录条数 Prometheus (prometheus) 名称 描述 ENABLED 激活该选项以启用 Prometheus 监控信息，默认为 true ENABLE_BASIC_AUTH 激活该选项以启用 HTTP 基本认证保护监控信息数据，默认为 false BASIC_AUTH_USERNAME HTTP 基本认证的用户名 BASIC_AUTH_PASSWORD HTTP 基本认证的密码 其他 (other) 名称 描述 SHOW_FOOTER_BRANDING 激活该选项以在页脚显示 Gogs 推广信息 SHOW_FOOTER_VERSION 激活该选项以在页脚显示 Gogs 版本信息 SHOW_FOOTER_TEMPLATE_LOAD_TIME 激活该选项以在页脚显示 Gogs 模板加载时间","categories":[{"name":"ci","slug":"ci","permalink":"http://github.13sai.com/categories/ci/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://github.13sai.com/tags/Docker/"},{"name":"CI","slug":"CI","permalink":"http://github.13sai.com/tags/CI/"}]},{"title":"利用consul+nginx-upsync实现动态负载","slug":"利用consul-nginx-upsync实现动态负载","date":"2019-12-01T01:53:29.000Z","updated":"2021-04-13T07:22:29.726Z","comments":true,"path":"2019/12/01/212/","link":"","permalink":"http://github.13sai.com/2019/12/01/212/","excerpt":"","text":"这是前一段时间学习的课程上面的，自己实际操作了一下，详细操作及说明如下。 如果Nginx遇到大流量和高负载，修改配置文件重启可能并不总是那么方便，因为恢复Nginx并重载配置会进一步增加系统负载，并很可能暂时降低性能。而一个个修改配置文件也是很容易出错和费时间的操作。 这时候不妨试试consul+nginx-upsync-module实现Nginx的动态负载。 nginx-upsync-modulenginx-upsync-module 提供了动态的负载均衡，它可以从consul或etcd同步upstreams，动态修改后端服务器属性（weight，max_fails，down…），而不需要重新加载nginx。这样我们通过它实现平滑伸缩，而不严重地影响性能。 利用docker安装我已经基于centos7构建了一个镜像 13sai/nginx-lua-upsync ，你可以使用下面的命令启动一个容器 docker run -itd –name=nginx-upsync -p 8008:80 -p 9501:9501 -p 9502:9502 -p 9503:9503 -p 8500:8500 13sai/nginx-lua-upsync 当然，你也可以不使用docker自行搭建，添加nginx-upsync-module模块可以参考nginx模块lua模块。 nginx-upsync-module的git地址 进入容器配置 docker exec -it nginx-upsync /bin/bash cd /usr/local/nginx/conf echo “server host.docker.internal:9501 weight=1 fail_timeout=10 max_fails=3;” &gt;&gt; servers.conf vi nginx.conf 123456789101112131415161718192021222324 #nginx.conf 主要配置 ... upstream 13sai&#123; upsync 192.168.65.2:8500/v1/kv/upstreams/test-server upsync_timeout=6m upsync_interval=500ms upsync_type=consul strong_dependency=off; upsync_dump_path /usr/local/nginx/conf/servers.conf; include /usr/local/nginx/conf/servers.conf;&#125;server &#123; listen 80; location / &#123; proxy_pass http://13sai; &#125; ... &#125;... upsync语法说明12345678910语法：syntax: upsync $consul/etcd.api.com:$port/v1/kv/upstreams/$upstream_name/ [upsync_type=consul/etcd] [upsync_interval=second/minutes] [upsync_timeout=second/minutes] [strong_dependency=off/on]默认值：无，如果省略参数，则默认参数为upsync_interval = 5s upsync_timeout = 6m strong_dependency = off描述：从 consul/etcd 中拉取upstreamsupsync 定义从consul/etcd拉取最新的upstream信息并存到本地的操作upsync_timeout 定义从consul/etcd拉取配置的超时时间upsync_interval 定义从consul/etc拉取配置的间隔时间upsync_type 定义使用配置服务类型strong_dependency 启动时是否强制依赖配置服务器，如果配置为on,则拉取失败，nginx同样会启用失败upsync_dump_path 定义从consul/etcd拉取配置后持久化到的本地的文件路径，这样即使 consul/etcd出问题了，本地同样会有备份文件 注意下面这个文件必须要有，文件路径和名称可以自定义，nginx-upsync-module会将负载信息缓存到此文件，否则Nginx启动会报错。 12#servers.conf，192.168.x.xxx是我的宿主机ipserver 192.168.x.xxx:9501 weight=20 max_fails=1 fail_timeout=5s; 重启nginx /usr/local/nginx/sbin/nginx -t /usr/local/nginx/sbin/nginx -s reload 这里虽然我们还未启动consul，但没有什么影响，upsync会去拉取，也必然会失败，servers.conf就不会更新，Nginx的error日志会有信息。 利用swoole启动3个http服务12345// 可启动3个server，端口分别为9501，9502，9503，输出也做对应修改$http = new Swoole\\Http\\Server(&quot;127.0.0.1&quot;, 9501);$http-&gt;on(&#x27;request&#x27;, function ($request, $response) &#123; $response-&gt;end(&quot;9501&quot;);&#125;); consul安装 这里consul只做一个kv存储，我自己也是第一次用，就不去做过多介绍了。 下载地址 解压到你需要的目录，主要也就是一个consul可执行文件。（这里我装在我的电脑，而不是刚才的docker容器） 命令可看文档：Consul 简介和快速入门 启动： nohup ./consul agent -dev &amp; 为了方便，我们也没有启动集群，生产环境建议使用consul集群。 UI查看 http://127.0.0.1:8500/ 查看节点 ./consul members curl 127.0.0.1:8500/v1/catalog/nodes 查看kv值 curl -v http://127.0.0.1:8500/v1/kv/\\?recurse 添加 curl -X PUT -d ‘{“weight”:20,”max_fails”:2,”fail_timeout”:5}’ http://127.0.0.1:8500/v1/kv/upstreams/test-server/192.168.x.xxx:9502 此处192.168.x.xxx是因为我创建的docker容器的宿主机ip。 删除 curl -X DELETE http://127.0.0.1:8500/v1/kv/upstreams/test-server/192.168.x.xxx:9502 我们可以通过添加和删除来测试，查看http://127.0.0.1:8008/来查看输出，也可以看看Nginx里的配置文件servers.conf，你会看到你操作consul，会动态改变Nginx的upstream，这样就实现了Nginx的动态扩容。 对consul和docker的学习还不够深入，文中如有错误，欢迎指正交流。","categories":[{"name":"microservice","slug":"microservice","permalink":"http://github.13sai.com/categories/microservice/"}],"tags":[{"name":"consul","slug":"consul","permalink":"http://github.13sai.com/tags/consul/"}]},{"title":"TCP三次握手和四次挥手","slug":"TCP三次握手和四次挥手","date":"2019-11-26T14:24:31.000Z","updated":"2019-11-27T10:27:49.237Z","comments":true,"path":"2019/11/26/210/","link":"","permalink":"http://github.13sai.com/2019/11/26/210/","excerpt":"","text":"三次握手 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方以建立起了链接。 为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以： 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。 因此，需要三次握手才能确认双方的接收与发送能力是否正常。 三次握手的作用三次握手的作用也是有好多的，多记住几个，保证不亏。例如： 确认双方的接受能力、发送能力是否正常。 指定自己的初始化序列号，为后面的可靠传送做准备。 如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。（HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。） 其他的问题例如： （ISN）是固定的吗? 三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。 什么是半连接队列 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 这里在补充一点关于SYN-ACK 重传次数的问题：服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, …. 三次握手过程中可以携带数据吗? 很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。 为什么这样呢？ 大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。 而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。 四次挥手 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 这里特别需要主要的就是TIME_WAIT这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。 至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。 这里我给出每个状态所包含的含义，有兴趣的可以看看。 LISTEN - 侦听来自远方TCP端口的连接请求； SYN-SENT -在发送连接请求后等待匹配的连接请求； SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认； FIN-WAIT-2 - 从远程TCP等待连接中断请求； CLOSE-WAIT - 等待从本地用户发来的连接中断请求； CLOSING -等待远程TCP对连接中断的确认； LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； CLOSED - 没有任何连接状态； 查看TCP状态命令12345678netstat -ant|awk &#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print (a,S[a])&#125;&#x27;LISTEN 9TIME_WAIT 189CLOSE_WAIT 2SYN_SENT 5FIN_WAIT2 7ESTABLISHED 453 参考：关于三次握手与四次挥手面试官想考我们什么？— 不看后悔系列","categories":[{"name":"网络","slug":"网络","permalink":"http://github.13sai.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"tcp","slug":"tcp","permalink":"http://github.13sai.com/tags/tcp/"}]},{"title":"Nginx配置常用参数，看这一篇就够了","slug":"Nginx配置常用参数，看这一篇就够了","date":"2019-11-22T02:25:01.000Z","updated":"2021-04-13T07:33:54.947Z","comments":true,"path":"2019/11/22/205/","link":"","permalink":"http://github.13sai.com/2019/11/22/205/","excerpt":"","text":"最近在全面学习Nginx，当作笔记了，如有错误，欢迎指出或深入交流。 主模块1234567891011121314# 配置用户或者组，默认为nobody nobody。#user www www; #Nginx开启的worker进程数，建议为CPU的核数#worker_processes 2; #指定nginx进程运行文件存放地址#pid /nginx/pid/nginx.pid;#指定日志路径，级别。这个设置可以放入全局块、http块、server块，级别以此为：debug|info|notice|warn|error|crit|alert|emergerror_log log/error.log debug; #可以在任意地方使用include指令实现配置文件的包含，类似于apache中的include方法，可减少主配置文件长度。include vhosts/*.conf; 事件模块12345678910111213141516events &#123; #设置网路连接序列化，防止惊群现象发生，默认为on accept_mutex on; #默认: 500ms 如果一个进程没有互斥锁，它将延迟至少多长时间。默认情况下，延迟是500ms 。 accept_mutex_delay 100ms; #设置一个进程是否同时接受多个网络连接，默认为off multi_accept on; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport，不建议设置，nginx会自行选择 #use epoll; #最大连接数，默认为512 worker_connections 1024;&#125; http部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293http &#123; #文件扩展名与文件类型映射表 include mime.types; # 默认文件类型，默认为text/plain default_type application/octet-stream; #取消服务日志 #access_log off; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。 sendfile on; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 sendfile_max_chunk 100k; #连接超时时间，默认为75s，可以在http，server，location块。 keepalive_timeout 65; #开启gzip资源压缩 gzip on; # 负载均衡，详细可看了一篇文章：https://learnku.com/articles/36737 upstream blog &#123; server 192.167.20.19:8081; server 192.168.10.121:8080 weight=5; &#125; #设定请求缓冲 client_header_buffer_size 128k; large_client_header_buffers 4 128k; #上传文件的大小限制 默认1m client_max_body_size 8m; server &#123; #单连接请求上限次数。 keepalive_requests 120; #监听端口 listen 80; #监听地址 server_name blog.13sai.com; #设定日志格式 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /data/logs/access.log main; # 根目录 root /www/web/public; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location /static/ &#123; #root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。 #root的处理结果是：root路径＋location路径 #alias的处理结果是：使用alias路径替换location路径 alias /www/static/; #过期30天，静态文件不怎么更新，过期可以设大一点,如果频繁更新，则可以设置得小一点。 expires 30d; &#125; # 处理php请求到fpm端口 location ~ \\.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_pass http://blog; #请求转向blog 定义的服务器列表 &#125; #禁止访问文件 location ~ /.git &#123; deny all; allow 127.0.0.1; #允许的ip &#125; &#125;&#125; 部分参数详细说明server_name123456781.首先选择所有字符串完全匹配的server_name，如 blog.13sai.com 。2.其次选择通配符在前面的server_name，如 *.13sai.com。3.再次选择通配符在后面的server_name，如www.13sai.* 。 4.最后选择使用正则表达式才匹配的server_name，如 ~^\\.sai\\.com$如果都不匹配1、优先选择listen配置项后有default或default_server的 2、找到匹配listen端口的第一个server块 location123location语法: location[=|~|~*|^~|@]/uri/&#123;...&#125;配置块: server location会尝试根据用户请求中的URI来匹配上面的/uri表达式，如果可以匹配，就选择 location&#123;&#125;块中的配置来处理用户请求。 location表达式类型 12345~ 表示执行一个正则匹配，区分大小写;~* 表示执行一个正则匹配，不区分大小写;^~ 表示普通字符匹配。使用前缀匹配。如果匹配成功，则不再匹配其他location; = 进行普通字符精确匹配。也就是完全匹配;@ 它定义一个命名的 location，使用在内部定向时，例如 error_page, try_files 优先级: 等号类型(=)的优先级最高。一旦匹配成功，则不再查找其他匹配项 前缀普通匹配(^~)优先级次之。不支持正则表达式。使用前缀匹配，如果有多个location匹配的话，则使用表达式最长的那个 正则表达式类型(~ ~*)的优先级次之。一旦匹配成功，则不再查找其他匹配项 常规字符串匹配，如果有多个location匹配的话，则使用表达式最长的那个 (location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ,* 正则顺序) &gt; (location 部分起始路径) return1234567891011121314151617181920212223242526语法:return code [text] return code URL;return URL;配置块:server，location，if该指令用于结束规则的执行并返回状态吗给客户端。状态码包括:204(No Content)、400(Bad Request)、402(Payment Required)、403(Forbidden) 404(Not Found)、405(Method Not Allowed)、406(Not Acceptable)、 408(Request Timeout)、410(Gone)、411(Length Required)、413(Request Entity Too Large)、416(Requested Range Not Satisfiable)、 500(Internal Server Error)、501(Not Implemented)、502(Bad Gateway)、 503(Service Unavailable)504(Gateway Timeout)。例如，示例，如果访问的URL以.sh .bash 结尾，返回状态码403 location ~ .*\\.(sh|bash)?$ &#123; return 403;&#125; rewrite12345678910111213141516执行顺序：1. 执行server块的rewrite指令(这里的块指的是server关键字后&#123;&#125;包围的区域，其它xx块类似)2. 执行location匹配3. 执行选定的location中的rewrite指令如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件如果循环超过10次，则返回500 Internal Server Error错误语法:rewrite regex replacement [flag]; 默认值:—配置块:server, location, ifrewrite是实现URL重写的关键指令，根据regex(正则表达式)部分内容，重定向到replacement，结尾是flag标记。 正则:perl兼容正则表达式语句进行规则匹配替代内容:将正则匹配的内容替换成replacementflag标记:rewrite支持的flag标记 if指令12345678910111213语法：if(condition)&#123;...&#125;默认值：无配置块：server,location对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行。if条件(conditon)可以是如下任何内容:一个变量名；false如果这个变量是空字符串或者以0开始的字符串；使用= ,!= 比较的一个变量和字符串是用~， ~*与正则表达式匹配的变量，如果这个正则表达式中包含&#125;，;则整个表达式需要用&quot; 或&#x27; 包围使用-f ，!-f 检查一个文件是否存在使用-d, !-d 检查一个目录是否存在使用-e ，!-e 检查一个文件、目录、符号链接是否存在使用-x ， !-x 检查一个文件是否可执行 if实例12345678910111213141516if ($http_user_agent~*(mobile|nokia|iphone|ipad|android|samsung|htc|blackberry)) &#123; rewrite ^.+ /mobile last; ＃跳转到手机站&#125;if ($request_method = POST) &#123; return 405;&#125;if ($slow) &#123; limit_rate 10k;&#125;if ($invalid_referer) &#123; return 403;&#125; last &amp; break123456789101112（1）last 和 break 当出现在location 之外时，两者的作用是一致的没有任何差异。注意一点就是，他们会跳过所有的在他们之后的rewrite 模块中的指令，去选择自己匹配的location（2）last 和 break 当出现在location 内部时，两者就存在了差异-- last: 使用了last 指令，rewrite 后会跳出location 作用域，重新开始再走一次刚刚的行为-- break: 使用了break 指令，rewrite后不会跳出location 作用域。它的生命也在这个location中终结。解释通俗易懂：last： 重新将rewrite后的地址在server标签中执行break： 将rewrite后的地址在当前location标签中执行 permanent &amp; redirect:12permanent: 永久性重定向。请求日志中的状态码为301redirect:临时重定向。请求日志中的状态码为302 从实现功能的角度上去看，permanent 和 redirect 是一样的。不存在好坏。也不存在什么性能上的问题。但是对seo会有影响，这里要根据需要做出选择在 permanent 和 redirect 中提到了 状态码 301 和 302。 记住：last 和 break 想对于的访问日志的请求状态码为200 当你打开一个网页，同时打开debug 模式时，会发现301 和 302 时的行为是这样的。 第一个请求301 或者 302 后，浏览器重新获取了一个新的URL ，然后会对这个新的URL 重新进行访问。所以当你配置的是permanent 和 redirect ,你对一个URL 的访问请求，落到服务器上至少为2次；而当你配置了last 或者是break 时，你最终的URL 确定下来后，不会将这个URL返回给浏览器，而是将其扔给了fastcgi_pass或者是proxy_pass指令去处理。请求一个URL ，落到服务器上的次数就为1次。 注意：配置last 在跨域的时候效果和redirect一致，都是返回302状态码，请求地址也发生改变 应用估算并发nginx作为http服务器的时候： max_clients = worker_processes * worker_connections/2 nginx作为反向代理服务器的时候： max_clients = worker_processes * worker_connections/4 限制每个IP的并发连接数demo:定义一个叫“two”的记录区，总容量为 10M（超过大小将请求失败，以变量 $binary_remote_addr 作为会话的判断基准（即一个地址一个会话）。 限制 /download/ 目录下，一个会话只能进行一个连接。 简单点，就是限制 /download/ 目录下，一个IP只能发起一个连接，多过一个，一律503。 123456789101112http &#123; ... limit_conn_zone $binary_remote_addr zone=two:10m; server &#123; ... location /download &#123; limit_conn two 1; &#125; &#125;&#125; 限流demo:定义一个叫“one”的记录区，占用空间大小为10m（超过大小将请求失败），平均处理的请求频率不能超过每秒一次，也可以设置分钟速率 12345678910111213141516http &#123; ... limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; server &#123; ... location / &#123; #缓存区队列burst=5个,nodelay表示不延期(超过的请求失败)，即每秒最多可处理rate+burst个,同时处理rate个。 limit_req zone=one burst=5 nodelay; &#125; &#125;&#125; 白名单123456789101112131415161718192021222324http&#123; ... #判断客户端的ip地址是否在白名单列表当中,如果返回为0,则在白名单列表当中,否则返回为1 geo $whiteIpList &#123; default 1; 118.24.109.254 0; 47.98.147.0/24 1; #可以引入一些白名单配置 include &#x27;whiteIP.conf&#x27; &#125; #如果不在白名单之内,返回客户端的二进制的ip地址 map $whiteIpList $limit &#123; default &quot;&quot;; 1 $binary_remote_addr; 0 &quot;&quot;; &#125; #如果返回的是空字符串那么速率限制会失效 limit_req_zone $limit zone=test:2m rate=1r/m; ...&#125; 防盗链1234567891011121314http &#123; ... server &#123; ... location ~* \\.(gif|jpg|png|swf|flv)$ &#123; valid_referers none blocked *.13sai.com; if ($invalid_referer) &#123; rewrite ^/ blog.13sai.com &#125; &#125; &#125;&#125;","categories":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/tags/nginx/"}]},{"title":"Nginx代理缓存","slug":"Nginx代理缓存","date":"2019-11-22T02:24:50.000Z","updated":"2021-04-13T07:33:35.792Z","comments":true,"path":"2019/11/22/208/","link":"","permalink":"http://github.13sai.com/2019/11/22/208/","excerpt":"","text":"Nginx的缓存可以简单分成web缓存和代理缓存，本篇文章主要介绍代理缓存。 web缓存Nginx提供了expires、etag、if-modified-since指令来实现浏览器缓存控制。 这个配置比较简单，一般可以缓存一些js、css等静态文件。 对于这几个不想做过多说明，大家可以看两张图，简单理解下。 代理缓存代理缓存主要用到proxy模块中的proxy_cache。我们来看一个demo。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950upstream 13sai&#123; server 127.0.0.1:9501 weight=10;&#125;#自定义缓存目录,缓存文件大小proxy_cache_path /usr/local/etc/nginx/cache levels=1:2 keys_zone=sai_cache:10m max_size=200m inactive=10m use_temp_path=off;server &#123; listen 80; server_name nginx-t.com; location / &#123; proxy_next_upstream error http_503; proxy_pass http://13sai; #启用缓存sai_cache proxy_cache sai_cache; #定义如何生成缓存的键 proxy_cache_key $scheme$proxy_host$uri$is_args$args; #针对多种请求方法缓存，默认GET HEAD proxy_cache_methods GET HEAD POST; #为不同的响应状态码设置不同的缓存时间。 proxy_cache_valid 200 302 10m; proxy_cache_valid 404 1m; #设置响应被缓存的最小请求次数,最少2次才会缓存 proxy_cache_min_uses 1; #开启此功能时，对于相同的请求，同时只允许一个请求发往后端 proxy_cache_lock on; #为proxy_cache_lock指令设置锁的超时5s proxy_cache_lock_timeout 5s; #忽略服务器不缓存的要求 proxy_ignore_headers Cache-Control; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; 测试效果12345678// server1.php&lt;?php$http = new Swoole\\Http\\Server(&quot;127.0.0.1&quot;, 9501);$http-&gt;on(&#x27;request&#x27;, function ($request, $response) &#123; echo &quot;no cache&quot;.PHP_EOL; $response-&gt;end(&quot;&lt;h1&gt;9501&lt;/h1&gt;&quot;);&#125;);$http-&gt;start(); php server1.php #查看控制台输出 发送get和post请求 ab -n10 -c10 http://nginx-t.com/v\\=get ab -p ‘data.json’ -n10 -c10 http://nginx-t.com/v\\=post 重复提交几次put请求 curl -X PUT http://nginx-t.com/v\\=put 下面是我的测试结果截图（为了方便查看，我在get和post请求之前敲了几个空行） 下面说明几个参数： proxy_cache_path123语法: proxy_cache_path path [levels=levels] keys_zone=name:size [inactive=time] [max_size=size] [loader_files=number] [loader_sleep=time] [loader_threshold=time];默认值: —上下文: http path：缓存数据是保存在文件中的，缓存的键和文件名都是在代理URL上执行MD5的结果。 levels：定义了缓存的层次结构 12#当levels=1:2时，表示是两级目录，1和2表示用1位和2位16进制来命名目录名称。在此例中，第一级目录用1位16进制命名，如b；第二级目录用2位16进制命名，如2c。所以此例中一级目录有16个，二级目录有16*16=256个：cache/b/2c/c75ad5e343f042f52e875343425e51b key_zone:在共享内存中设置一块存储区域来存放缓存的key和metadata(类似使用次数)，这样nginx可以快速判断一个request是否命中或者未命中缓 存，1m可以存储8000个key，10m可以存储80000个key。 max_size:最大cache空间，如果不指定，会使用掉所有disk space，如果超过max_size参数设置的最大值，使用LRU算法移除缓存数据 inactive:未被访问文件在缓存中保留时间，默认是10分钟。指定时间内未被访问的缓存文件将被删除。 loader_files:每次最多加载的数量 loader_sleeps:每次加载的延时 loader_threshold:指定每次加载执行的时间 proxy_cache_lock开启此功能时，对于相同的请求，同时只允许一个请求发往后端，并根据proxy_cache_key指令的设置在缓存中植入一个新条目。其他请求相同条目的请求将一直等待，直到缓存中出现相应的内容，或者锁在proxy_cache_lock_timeout指令设置的超时后被释放。 proxy_cache_valid如果仅仅指定了time， proxy_cache_valid 5m; 那么只有状态码为200、300和302的响应会被缓存。 如果使用了any参数，那么就可以缓存任何响应： proxy_cache_valid any 1m; proxy_ignore_headers123语法: proxy_ignore_headers field ...;默认值: —上下文: http, server, location 不处理后端服务器返回的指定响应头。下面的响应头可以被设置： “X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate” ，“X-Accel-Buffering” ， “X-Accel-Charset”，“Expires”，“Cache-Control”，和“Set-Cookie” 。 此参数不建议设置，原则上这些缓存应当后端代码处理。 proxy_cache_use_stale1234语法: proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_404 | off ...;默认值: proxy_cache_use_stale off;上下文: http, server, location 如果后端服务器出现状况，nginx是可以使用过期的响应缓存的。这条指令就是定义何种条件下允许开启此机制。这条指令的参数与proxy_next_upstream指令的参数相同。 proxy_cache_bypass与proxy_no_cache123语法: proxy_cache_bypass string ...;默认值: —上下文: http, server, location 定义nginx不从缓存取响应的条件。如果至少一个字符串条件非空而且非“0”，nginx就不会从缓存中去取响应： 12proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;proxy_cache_bypass $http_pragma $http_authorization; 本指令可和与proxy_no_cache一起使用。 123语法: proxy_no_cache string ...;默认值: —上下文: http, server, location 定义nginx不将响应写入缓存的条件。如果至少一个字符串条件非空而且非“0”，nginx就不将响应存入缓存： 12proxy_no_cache $cookie_nocache $arg_nocache$arg_comment;proxy_no_cache $http_pragma $http_authorization; proxy_cache_methods该指令用于设置缓存哪些HTTP方法,默认缓存HTTP GET/HEAD方法,不缓存HTTP POST 方法。 有了代理缓存，那么清除缓存如何操作呢？ 清除缓存 删除缓存目录的文件 使用ngx_cache_purge模块，可查看这篇文章Nginx缓存配置及nginx ngx_cache_purge模块的使用 推荐第二种方法。","categories":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/tags/nginx/"}]},{"title":"Nginx内嵌变量","slug":"Nginx内嵌变量","date":"2019-11-22T02:22:02.000Z","updated":"2021-04-13T07:33:51.976Z","comments":true,"path":"2019/11/22/210/","link":"","permalink":"http://github.13sai.com/2019/11/22/210/","excerpt":"","text":"Nginx内嵌变量是非常常用的，记录下备查。 Nginx内嵌变量由 ngx_http_core_module 模块支持，变量名与Apache服务器对应，这些变量可以表示客户端的请求头字段，诸如$http_user_agent、$http_cookie等等。 nginx也支持其他变量： 参数名称 说明 $arg_name 请求中的的参数名，即“?”后面的arg_name=arg_value形式的arg_name，如/index.php?www=www.13sai.com，可以用$arg_www就是www.13sai.com $args 请求中的参数值 $binary_remote_addr 客户端地址的二进制形式, 固定长度为4个字节 $body_bytes_sent 传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的“%B”参数保持兼容 $bytes_sent 传输给客户端的字节数 $connection TCP连接的序列号 $connection_requests TCP连接当前的请求数量 $content_length “Content-Length” 请求头字段 $content_type “Content-Type” 请求头字段 $cookie_name cookie名称 $document_root 当前请求的文档根目录或别名 $document_uri 同 $uri $host 优先级如下：HTTP请求行的主机名&gt;”HOST”请求头字段&gt;符合请求的服务器名 $hostname 主机名 $http_name 匹配任意请求头字段； 变量名中的后半部分“name”可以替换成任意请求头字段，如在配置文件中需要获取http请求头：“Accept-Language”，那么将“－”替换为下划线，大写字母替换为小写，形如：$http_accept_language即可。 $https 如果开启了SSL安全模式，值为“on”，否则为空字符串。 $is_args 如果请求中有参数，值为“?”，否则为空字符串。 $limit_rate 用于设置响应的速度限制，详见 limit_rate。 $msec 当前的Unix时间戳 (1.3.9, 1.2.6) $nginx_version nginx版本 $pid 工作进程的PID $pipe 如果请求来自管道通信，值为“p”，否则为“.” (1.3.12, 1.2.7) $proxy_protocol_addr 获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串。(1.5.12) $query_string 同 $args，然而 $query_string是只读的不会改变 $realpath_root 当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径。 $remote_addr 客户端地址 $remote_port 客户端端口 $remote_user 用于HTTP基础认证服务的用户名 $request 代表客户端的请求地址 $request_body 客户端的请求主体,此变量可在location中使用，将请求主体通过proxy_pass, fastcgi_pass, uwsgi_pass, 和 scgi_pass传递给下一级的代理服务器。 $request_body_file 请求正文的临时文件名。处理完成时，临时文件将被删除。 如果希望总是将请求正文写入文件，需要开启client_body_in_file_only。 如果在被代理的请求或FastCGI请求中传递临时文件名，就应该禁止传递请求正文本身。 使用proxy_pass_request_body off指令 和fastcgi_pass_request_body off指令 分别禁止在代理和FastCGI中传递请求正文。 $request_completion 如果请求成功，值为”OK”，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空。 $request_filename 当前连接请求的文件路径，由root或alias指令与URI请求生成。 $request_length 请求的长度 (包括请求的地址, http请求头和请求主体) $request_method HTTP请求方法，通常为“GET”或“POST” $request_time 处理客户端请求使用的时间; 从读取客户端的第一个字节开始计时。 $request_uri 这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：”/sai/test.php?arg=www”。 $scheme 请求使用的Web协议, “http” 或 “https” $sent_http_name 可以设置任意http响应头字段； 变量名中的后半部分“name”可以替换成任意响应头字段，如需要设置响应头Content-length，那么将“－”替换为下划线，大写字母替换为小写，形如：$sent_http_content_length 4096即可。 $server_addr 服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中。 $server_name 服务器名 $server_port 服务器端口 $server_protocol 服务器的HTTP版本, 通常为 “HTTP/1.0” 或 “HTTP/1.1” $status HTTP响应代码 $time_iso8601 服务器时间的ISO 8610格式 $time_local 服务器时间（LOG Format 格式） ，nginx处理完成打印日志的时间，不是请求发出的时间 $uri 请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如”/foo/bar.html”。 apache服务器变量可看[备忘] apache服务端变量 参考： 中文文档 Nginx 相关文章： Nginx 负载均衡 Nginx 添加 lua 模块 Nginx 配置常用参数，看这一篇就够了 Nginx 代理缓存","categories":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/tags/nginx/"}]},{"title":"Nginx添加lua-nginx模块","slug":"Nginx添加lua-nginx模块","date":"2019-11-20T05:52:59.000Z","updated":"2019-11-28T05:55:08.478Z","comments":true,"path":"2019/11/20/202/","link":"","permalink":"http://github.13sai.com/2019/11/20/202/","excerpt":"","text":"ngx_lua是Nginx的一个模块，将Lua嵌入到Nginx中，从而可以使用Lua来编写脚本，这样就可以使用Lua编写应用脚本，部署到Nginx中运行，即Nginx变成了一个Web容器；这样开发人员就可以使用Lua语言开发高性能Web应用了。 安装lua1234wget http://luajit.org/download/LuaJIT-2.0.5.tar.gz tar -zxvf LuaJIT-2.0.5.tar.gzcd LuaJIT-2.0.5make &amp;&amp; make install PREFIX=/usr/local/LuaJIT etc/profile加入123# luaexport LUAJIT_LIB=/usr/local/LuaJIT/lib export LUAJIT_INC=/usr/local/LuaJIT/include/luajit-2.0 source etc/profile 下载ngx_devel_kit模块1wget https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz NDK(nginx development kit)模块是一个拓展nginx服务器核心功能的模块，第三方模块开发可以基于它来快速实现。 NDK提供函数和宏处理一些基本任务， 减轻第三方模块开发的代码量 下载lua-nginx-module模块1wget https://github.com/openresty/lua-nginx-module/archive/v0.10.9rc7.tar.gz lua-nginx-module 模块使nginx中能直接运行lua 查看原始编译 nginx -V 12如：configure arguments: --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-http_sub_module --with-http_v2_module 进入nginx原始目录： 1./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-http_sub_module --with-http_v2_module --add-module=/root/lua-nginx-module-0.10.9rc7/ --add-module=/root/ngx_devel_kit-0.3.0 只make，不执行make install。 编译报错应该就是lua环境变量不对。 12345678nginx -V 命令报错./nginx: error while loading shared libraries: libluajit-5.1.so.2: cannot open shared object file: No such file or directory解决：echo &quot;/usr/local/LuaJIT/lib&quot; &gt;&gt; /etc/ld.so.confldconfig 成功之后可以nginx -V查看，无报错即可。 把原来的nginx备份为nginx_old cp objs/nginx到原来的nginx并覆盖。 在编译目录执行 make upgrade 测试： 12345678910server&#123; ... location /lua &#123; default_type &#x27;text/html&#x27;; content_by_lua &#x27; ngx.say(&quot;hello, lua!&quot;) &#x27;; &#125; ...&#125; 浏览器打开： http://blog.13sai.com/lua 可以看到hello, lua! 此安装方法也适用于Nginx其他module安装。","categories":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/tags/nginx/"}]},{"title":"Nginx负载均衡","slug":"Nginx负载均衡","date":"2019-11-17T22:01:55.000Z","updated":"2021-04-13T07:33:39.360Z","comments":true,"path":"2019/11/18/203/","link":"","permalink":"http://github.13sai.com/2019/11/18/203/","excerpt":"","text":"nginx负载均衡是我们经常用到的，那么有没有仔细看一下关于负载均衡的配置参数呢？ 负载均衡策略 1.轮询(默认)：每一个来自网络中的请求，轮流分配给内部的服务器，从1到N然后重新开始。此种负载均衡算法适合服务器组内部的服务器都具有相同的配置并且平均服务请求 相对均衡的情况。 2.加权轮询（weight）：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。例如:服务器A的权值被设计成1，B的权值是3，C的权值是6，则服务器A、B、C将分别接受到10%、30%、60%的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。 3.ip-hash（ip_hash）：我们都知道，每个请求的客户端都有相应的ip地址，该均衡策略中，nginx将会根据相应的hash函数，对每个请求的ip作为关键字，得到的hash值将会决定将请求分发给相应Server进行处理。 4.最少连接数（least_conn）：最少连接，也就是说nginx会判断后端集群服务器中哪个Server当前的 Active Connection 数是最少的，那么对于每个新进来的请求，nginx将该其分发给对应的Server。 语法1234567891011121314151617181920212223242526272829303132333435语法: upstream name &#123; ... &#125; 默认值: —上下文: httpupstream 指令当中包含server指令语法: server address [parameters]; 上下文: upstream例子:upstream backend &#123; server backend1.example.com:8081 weight=4 max_fails=2 fail_timeout=30s; server backend2.example.com:8080 weight=1;&#125;server &#123; location / &#123; proxy_pass http://backend; &#125;&#125;参数说明:weight=number 设定服务器的权重，默认是1，权重越大被访问机会越大，可以根据机器的配置情况来配置。max_fails=number 设定Nginx与服务器通信的尝试失败的次数。在fail_timeout参数定义的时间段内，如果失败的次数达到此值，Nginx就认为服务器不 可用。在下一个fail_timeout时间段，服务器不会再被尝试。 失败的尝试次数默认是1。默认配置时，http_404状态不被认为是失败的尝试。 可以通过指令proxy_next_upstream 和memcached_next_upstream来配置什么是失败的尝试。fail_timeout=time统计失败尝试次数的时间段。在这段时间中，服务器失败次数达到指定的尝试次数，服务器就被认为不可用。默认情况下，该超时时间是10秒。 backup标记为备用服务器。当主服务器不可用以后，请求会被传给这些服务器，配置这个指令可以实现故障转移。down 标记服务器永久不可用，可以跟ip_hash指令一起使用。 即便未设置诸多参数，默认情况下，当其中某个server挂掉之后，nginx还是会把请求分发到正常的server中去。但一般建议我们手动去设置。 proxy_next_upstream 指令在nginx的配置文件中， proxy_next_upstream 项定义了什么情况下进行重试 1234567891011121314151617语法: proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...; 默认值: proxy_next_upstream error timeout;上下文: http, server, location其中:error 表示和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现错误。 timeout 表示和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现超时。 invalid_header 表示后端服务器返回空响应或者非法响应头http_500 表示后端服务器返回的响应状态码为500non_idempotent 通常，如果请求已发送到上游服务器，则具有非等幂方法（POST、LOCK、PATCH）的请求不会传递到下一个服务器；启用此选项可显式允许重试此类请求；off 表示停止将请求发送给下一台后端服务器 注意下non_idempotent参数，proxy_next_upstream配置默认转发get请求，但对于post等请求并无效果，建议配置这一项。 相关12345678910proxy_next_upstream_tries number:设置重试次数，默认0表示不限制，注意此重试次数指的是所有请求次数(包括第一次和之后的重试次数之和)。 proxy_next_upstream_timeout time: 设置重试最大超时时间，默认0表示不限制。即在 proxy_next_upstream_timeout 时间内允许 proxy_next_upstream_tries 次重试。如果超过了其中一个设置，则 Nginx 也会结束重试并返回客户 端响应(可能是错误码)。proxy_send_timeout 后端服务器数据回传时间(代理发送超时时间)proxy_read_timeout 连接成功后，后端服务器响应时间(代理接收超时时间) proxy_connect_timeout nginx连接后端的超时时间，一般不超过75s 建议自己动手使用这些参数，试验一下，加深印象和理解。","categories":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/tags/nginx/"}]},{"title":"git回退远程分支版本","slug":"git回退远程分支版本","date":"2019-10-28T18:12:11.000Z","updated":"2021-04-26T03:36:09.598Z","comments":true,"path":"2019/10/29/201/","link":"","permalink":"http://github.13sai.com/2019/10/29/201/","excerpt":"","text":"偶尔会有代码提交错误，又提交到远程分支了，怎么回退呢？ 强制回退1234# 查看日志，找到对应的commit idgit loggit reset --hard 回退的版本idgit push -f origin 分支名 这样回退是清除了回退的版本id之后的提交，连日志都没有了。 回退版本1234# 查看日志，找到对应的commit idgit loggit reset --soft 回退的版本idgit commit 这样回退是改回回退的版本id之后的提交，日志仍然存在。","categories":[{"name":"ci","slug":"ci","permalink":"http://github.13sai.com/categories/ci/"}],"tags":[{"name":"git","slug":"git","permalink":"http://github.13sai.com/tags/git/"}]},{"title":"php+nginx上传文件413","slug":"php+nginx上传文件413","date":"2019-10-08T17:07:50.000Z","updated":"2021-04-13T07:37:44.406Z","comments":true,"path":"2019/10/09/200/","link":"","permalink":"http://github.13sai.com/2019/10/09/200/","excerpt":"","text":"最近在项目中上传文件的时候，上传出错，返回413 Request Entity Too Large 解决方法：（具体大小视业务而定） 以下代码加入 nginx.conf 文件中的 http{ … } 块中 client_max_body_size 32M; PHP 设置上传大小 打开php.ini 文件中 修改以下几个参数 123memory_limit = 32Mupload_max_filesize = 8Mpost_max_size = 16M 重启nginx，fpm即可。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://github.13sai.com/tags/Nginx/"}]},{"title":"php生成器yield","slug":"php生成器yield","date":"2019-09-19T17:28:31.000Z","updated":"2021-04-13T07:37:10.620Z","comments":true,"path":"2019/09/20/199/","link":"","permalink":"http://github.13sai.com/2019/09/20/199/","excerpt":"","text":"一个生成器函数看起来像一个普通的函数，不同的是普通函数返回一个值，而一个生成器可以yield生成许多它所需要的值。 生成器提供了一种更容易的方法来实现简单的对象迭代，相比较定义类实现 Iterator 接口的方式，性能开销和复杂性大大降低。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpfunction xrange($start, $limit, $step = 1) &#123; if ($start &lt; $limit) &#123; if ($step &lt;= 0) &#123; throw new LogicException(&#x27;Step must be +ve&#x27;); &#125; for ($i = $start; $i &lt;= $limit; $i += $step) &#123; yield $i; &#125; &#125; else &#123; if ($step &gt;= 0) &#123; throw new LogicException(&#x27;Step must be -ve&#x27;); &#125; for ($i = $start; $i &gt;= $limit; $i += $step) &#123; yield $i; &#125; &#125;&#125;/* * 注意下面range()和xrange()输出的结果是一样的。 */echo &#x27;Single digit odd numbers from range(): &#x27;;foreach (range(1, 9, 2) as $number) &#123; echo &quot;$number &quot;;&#125;echo &quot;\\n&quot;;echo &#x27;Single digit odd numbers from xrange(): &#x27;;foreach (xrange(1, 9, 2) as $number) &#123; echo &quot;$number &quot;;&#125;// 输出内容Single digit odd numbers from range(): 1 3 5 7 9Single digit odd numbers from xrange(): 1 3 5 7 9 集合laravel与业务（更新uv）的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?php/** * 数据修复 * Author: sai * Date: 2019/9/19 */namespace App\\Console\\Commands;use App\\Models\\StatisticModel;use Illuminate\\Console\\Command;use Illuminate\\Support\\Facades\\DB;use Illuminate\\Support\\Facades\\Redis;class DataStatistic extends Command&#123; /** * The name and signature of the console command. * * @var string */ protected $signature = &#x27;DataStatistic&#x27;; /** * The console command description. * * @var string */ protected $description = &#x27;DataStatistic&#x27;; /** * Create a new command instance. * * @return void */ public function __construct() &#123; parent::__construct(); &#125; public function parseStr(...$param)&#123; $str = &#x27;&#x27;; foreach ($param as $key =&gt; $value) &#123; //处理数组 if (is_array($value)) &#123; $value = md5(json_encode($value)); &#125; $str .= $value; &#125; return $str; &#125; public function handle() &#123; // 单独输出到updateChapter.log文件 \\Log::useFiles(storage_path().&#x27;/logs/data.log&#x27;); $iTime = time(); \\Log::info(&#x27;start&#x27;, [&#x27;timestamp&#x27; =&gt; $iTime]); $i = 0; $ret = $this-&gt;traverse(); foreach ($ret as $v) &#123; foreach ($v as $value) &#123; $key = $this-&gt;parseStr(&#x27;wx:&#x27;, $value-&gt;wx_id); $count = (int) Redis::pfcount($key); // redis里的uv更大时更新，并记录更新前后数据 if ($count &gt; $value-&gt;uv) &#123; \\Log::info(&#x27;update id:&#x27;.$value-&gt;id, [$value-&gt;uv =&gt; $count]); $i++; (new StatisticModel([&#x27;hash_id&#x27; =&gt; $value-&gt;wx_id]))-&gt;where(&#x27;id&#x27;, $value-&gt;id)-&gt;update([&#x27;uv&#x27; =&gt; $count, &#x27;update_time&#x27; =&gt; $iTime]); &#125; &#125; &#125; // 记录更新时间与数量 \\Log::info(&#x27;end&#x27;, [&#x27;timestamp&#x27;=&gt;time(), &#x27;count&#x27; =&gt; $i,&#x27;interval&#x27; =&gt; time() - $iTime]); return true; &#125; private function traverse() &#123; $page = 3000; for ($i = 1; $i &lt; 6; $i++) &#123; $count = DB::table(&#x27;wx_statistics_&#x27;.$i)-&gt;count(); if ($count &lt; 1) &#123; // 记录进度 \\Log::info(&#x27;update schedule&#x27;, [&#x27;table success&#x27; =&gt; $i]); continue; &#125; $num = ceil($count/$page); for ($j = 0; $j &lt; $num; $j++) &#123; $ret = DB::table(&#x27;wx_statistics_&#x27;.$i) -&gt;select([&#x27;id&#x27;, &#x27;wx_id&#x27;, &#x27;uv&#x27;]) -&gt;orderBy(&#x27;id&#x27;, &#x27;asc&#x27;) -&gt;skip($j*$page) -&gt;take($page) -&gt;get() -&gt;toArray(); if (empty($ret)) &#123; continue; &#125; yield $ret; &#125; \\Log::info(&#x27;update schedule&#x27;, [&#x27;table success&#x27; =&gt; $i]); &#125; return true; &#125;&#125;","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"通过mysqlbinlog恢复误操作清空的表","slug":"通过mysqlbinlog恢复误操作清空的表","date":"2019-09-08T13:17:28.000Z","updated":"2021-04-13T07:27:41.579Z","comments":true,"path":"2019/09/08/198/","link":"","permalink":"http://github.13sai.com/2019/09/08/198/","excerpt":"","text":"昨天晚上朋友说数据库误删了，没有备份能不能恢复，我一愣，突然想到之前我们遇到过的问题，便问他是否开启了binlog。 show variables like log_bin; 如果现实log_bin是ON，就说明打开了。 值得庆幸，他们的生产数据库开了binlog。然后跟他说了下这个可以恢复，让他们去操作一下。结果那边问我能不能操作，我说可以。 操作： 找到存放binlog的目录 mysqlbinlog mysql-bin.000011 &gt; bak.log 找到删除的语句时间 导出sql mysqlbinlog –stop-datetime=”2019-09-07 17:30:31” mysql-bin.000011 &gt;all.sql stop-datetime应该是误删操作前一刻时间。 下载all.sql倒入本地数据库，导出误删表，倒入生产数据库。 检测生产数据库，无异常即可 反思： 导出sql时应该指定数据库 mysqlbinlog –stop-datetime=”2019-09-07 17:30:31” –database=test mysql-bin.000893 &gt;all.sql 数据库重要数据尽量一天一备份，然后开启binlog，为了减少硬盘空间占用，设置expire_logs_days 生产数据库不使用root用户，新建用户，限制drop，truncate等危险操作权限 mysqlbin","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"mysql分页重复","slug":"mysql分页重复","date":"2019-09-04T15:10:16.000Z","updated":"2021-04-13T07:33:04.195Z","comments":true,"path":"2019/09/04/197/","link":"","permalink":"http://github.13sai.com/2019/09/04/197/","excerpt":"","text":"之前在项目中做分页时，发现第二页和第三页出现了系统的数据，查了下数据总数没变，发现是order相同导致的。 解决方案：在排序在最后加入主键排序","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"laravel默认分页带参","slug":"Laravel默认分页带参","date":"2019-09-02T11:07:26.000Z","updated":"2021-04-13T07:32:37.481Z","comments":true,"path":"2019/09/02/196/","link":"","permalink":"http://github.13sai.com/2019/09/02/196/","excerpt":"","text":"默认的laravel分页是只带分页参数的，那么如何加入其它参数呢？比如搜索项。 后端带参 123456789101112$list = $model::paginate(2);$list-&gt;appends([ name=&gt;$name, city=&gt;$city,])-&gt;render();return view(admin, [ list =&gt; $list]);// blade使用&#123;&#123; $list-&gt;links() &#125;&#125; 前端带参 123456789$list = $model::paginate(2);return view(admin.apply.apply, [ list =&gt; $list, name =&gt; $name, city =&gt; $city]);//前端&#123;&#123; $list-&gt;appends([name=&gt;$name, city =&gt; $city])-&gt;links() &#125;&#125; 两种方法均可！","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://github.13sai.com/tags/Laravel/"}]},{"title":"学习go遇到的一些问题和概念汇总","slug":"学习go遇到的一些问题和概念汇总","date":"2019-08-24T19:36:19.000Z","updated":"2021-04-13T07:28:47.069Z","comments":true,"path":"2019/08/25/195/","link":"","permalink":"http://github.13sai.com/2019/08/25/195/","excerpt":"","text":"go get安装x/sys失败的解决12345678// $GOPATH这段地址请自行修改，下载到goroot和gopath对应位置即可，不同系统略有不同git clone https://github.com/golang/net.git $GOPATH/src/github.com/golang/netgit clone https://github.com/golang/sys.git $GOPATH/src/github.com/golang/sysgit clone https://github.com/golang/tools.git $GOPATH/src/github.com/golang/toolsln -s $GOPATH/src/github.com/golang $GOPATH/src/golang.org/x go get命令安装golang.org比较慢的话，一般都可以在github.com找到对应的package，下载后放到对应的目录即可 go的环境变量设置在/etc/profile最下面加入以下代码： 12345# 可自行改成你的目录export GO_INSTALL_DIR=$HOMEexport GOROOT=$GO_INSTALL_DIR/goexport GOPATH=$HOME/mygoexport PATH=$GOPATH/bin:$PATH:$GO_INSTALL_DIR/go/bin import import _ 执行init函数，但不需要包所有函数 import . 解决循环依赖问题 &amp;和* &amp;符号的意思是对变量取地址，如：变量a的地址是&amp;a符号的意思是对指针取值，和聽&amp;聽可以互相抵消,同时注意，*&amp;可以抵消掉，但&amp;*是不可以抵消的 切片容量 容量当做成总长度减去左指针走过的元素值 1234一旦一个切片无法容纳更多的元素，Go语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的2倍。但是，当原切片的长度（以下简称原长度）大于或等于1024时，Go语言将会以原容量的1.25倍作为新容量的基准（以下新容量基准）。新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会比新长度大一些，当然，相等也是可能的。另外，如果我们一次追加的元素过多，以至于使新长度比原容量的2倍还要大，那么新容量就会以新长度为基准。 大小写 在Go语言中，没有特别的关键字来声明一个方法、函数或者类型是否为公开的，Go语言提供的是以大小写的方式进行区分的，如果一个类型的名字是以大写开头，那么其他包就可以访问；如果以小写开头，其他包就不能访问。 go的并发 概念 说明 进程 一个程序对应一个独立程序空间 线程 一个执行空间，一个进程可以有多个线程 逻辑处理器 执行创建的goroutine，绑定一个线程 调度器 Go运行时中的，分配goroutine给不同的逻辑处理器 全局运行队列 所有刚创建的goroutine都会放到这里 本地运行队列 逻辑处理器的goroutine队列 并发的概念和并行不一样，并行指的是在不同的物理处理器上同时执行不同的代码片段，并行可以同时做很多事情，而并发是同时管理很多事情，因为操作系统和硬件的总资源比较少，所以并发的效果要比并行好的多，使用较少的资源做更多的事情，也是Go语言提倡的。 通道12345678910111213h:=make(chan int)通道类型和Map这些类型一样，可以使用内置的make函数声明初始化，这里我们初始化了一个chan int类型的通道，所以我们只能往这个通道里发送int类型的数据，当然接收也只能是int类型的数据。我们知道，通道是用于在goroutine之间通信的，它具有发送和接收两个操作，而且这两个操作的运算符都是&lt;-。ch &lt;- 2 //发送数值2给这个通道x:=&lt;-ch //从通道里读取值，并把读取的值赋值给x变量&lt;-ch //从通道里读取值，然后忽略看例子，慢慢理解发送和接收的用法。发送操作&lt;-在通道的后面，看箭头方向，表示把数值2发送到通道ch里；接收操作&lt;-在通道的前面，而且是一个一元操作符，看箭头方向，表示从通道ch里读取数据。读取的数据可以赋值给一个变量，也可以忽略。通道我们还可以使用内置的close函数关闭。close(ch) 无缓冲的通道无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送goroutine和接收goroutine同时准备好，才可以完成发送和接收操作。 从上面无缓冲的通道定义来看，发送goroutine和接收gouroutine必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同步通道。 12345678910111213func main() &#123; ch := make(chan int) go func() &#123; var sum int = 0 for i := 0; i &lt; 10; i++ &#123; sum += i &#125; ch &lt;- sum &#125;() fmt.Println(&lt;-ch)&#125; 有缓冲的通道有缓冲通道，其实是一个队列，这个队列的最大容量就是我们使用make函数创建通道时，通过第二个参数指定的。 ch := make(chan int, 3)这里创建容量为3的，有缓冲的通道。对于有缓冲的通道，向其发送操作就是向队列的尾部插入元素，接收操作则是从队列的头部删除元素，并返回这个刚刚删除的元素。 当队列满的时候，发送操作会阻塞；当队列空的时候，接受操作会阻塞。有缓冲的通道，不要求发送和接收操作时同步的，相反可以解耦发送和接收操作。 想知道通道的容量以及里面有几个元素数据怎么办？其实和map一样，使用cap和len函数就可以了。 12cap(ch)len(ch) cap函数返回通道的最大容量，len函数返回现在通道里有几个元素。 12345678func mirroredQuery() string &#123; responses := make(chan string, 3) go func() &#123; responses &lt;- request(&quot;asia.gopl.io&quot;) &#125;() go func() &#123; responses &lt;- request(&quot;europe.gopl.io&quot;) &#125;() go func() &#123; responses &lt;- request(&quot;americas.gopl.io&quot;) &#125;() return &lt;-responses // return the quickest response&#125;func request(hostname string) (response string) &#123; /* ... */ &#125; 单向通道有时候，我们有一些特殊场景，比如限制一个通道只可以接收，但是不能发送；有时候限制一个通道只能发送，但是不能接收，这种通道我们称为单向通道。这个在生产者消费者很实用。 定义单向通道也很简单，只需要在定义的时候，带上&lt;-即可。 12var send chan&lt;- int //只能发送var receive &lt;-chan int //只能接收","categories":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"}]},{"title":"利用jenkins发布代码","slug":"利用jenkins发布代码","date":"2019-07-30T16:28:48.000Z","updated":"2021-04-13T07:19:42.888Z","comments":true,"path":"2019/07/31/194/","link":"","permalink":"http://github.13sai.com/2019/07/31/194/","excerpt":"","text":"安装jenkins123456789docker run \\ -u root \\ --rm \\ -d \\ -p 8090:8080 \\ -p 50000:50000 \\ -v jenkins-data:/var/jenkins_home \\ -v /var/run/docker.sock:/var/run/docker.sock \\ jenkinsci/blueocean 进入容器查看密码： docker exec -it 6d1a7f988069 /bin/bash 密码存储路径 /var/jenkins_home/secrets/initialAdminPassword jenkins关联git，拉取无需密码验证1234// 产生公钥与私钥对.ssh-keygen// 用ssh-copy-id将公钥复制到远程机器中(gitlab等)ssh-copy-id -i .ssh/id_rsa.pub git@xxx.com jenkins关联代码服务器，同步无需密码验证12// 尽量使用内网ipscp -p .ssh/id_rsa.pub www@172.17.158.15:/home/www/.ssh/authorized_keys 新建项目 选择自由风格项目 Source Code Management填写git地址 Build执行shell脚本 shell demo 123456#!/bin/bashecho $&#123;BUILD_USER&#125;SOURCE_DIR=/var/jenkins_home/workspace/$&#123;JOB_NAME&#125;/DEST_DIR=/usr/local/nginx/html/jenkinsREMOTE_IP=172.17.158.15scp -r $SOURCE_DIR www@$REMOTE_IP:$DEST_DIR 保存后点击构建。原理：jenkins拉取git代码jenkins服务器，scp同步代码到代码服务器。 易出错点： 服务器目录权限问题 git拉取ssh验证 目录 构建时可查看Console Output信息，能看出哪一步错误，然后处理即可。","categories":[{"name":"ci","slug":"ci","permalink":"http://github.13sai.com/categories/ci/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://github.13sai.com/tags/jenkins/"}]},{"title":"nginx日志按日配置","slug":"Nginx日志按日配置","date":"2019-07-22T18:04:44.000Z","updated":"2021-04-13T07:34:01.667Z","comments":true,"path":"2019/07/23/193/","link":"","permalink":"http://github.13sai.com/2019/07/23/193/","excerpt":"","text":"老实说，我觉得nginx没有日志按日配置功能缺失有点费解，不过我们可以通过代码实现。配置如下： 12345if ($time_iso8601 ~ &quot;^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&quot;) &#123; set $day $1$2$3;&#125;access_log logs/access-$day.log main;","categories":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/tags/nginx/"}]},{"title":"lua+nginx实现黑名单禁止访问","slug":"lua-nginx实现黑名单禁止访问","date":"2019-07-15T17:35:49.000Z","updated":"2020-12-09T10:45:08.091Z","comments":true,"path":"2019/07/16/192/","link":"","permalink":"http://github.13sai.com/2019/07/16/192/","excerpt":"","text":"lua是可以很好地和Nginx配合使用的，去在代码之前做一些处理，这里我们力求简单，省去安装，使用OpenResty（基于 Nginx 与 Lua 的高性能 Web 平台） OpenResty地址 我是在windows7电脑上测试使用，主要配置代码如下： 12345678910111213141516171819202122232425262728293031323334# 分配内存，根据业务量lua_shared_dict ip_blacklist 1m;server &#123; listen 80; server_name localhost; root E:/www/web/test; access_log logs/host.access.log ; error_log logs/host.error.log; location / &#123; access_by_lua_file ../lua/black.lua; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; location ~ \\.php$ &#123; # 指定lua文件 access_by_lua_file &quot;D:\\openresty-1.15.8.1-win64/lua/black.lua&quot;; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; black.lua 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061local redis_host = &quot;127.0.0.1&quot; -- 这里一定是redis的IP地址local redis_port = &quot;6379&quot;-- 连接超时时间，单位ms，不建议设置太高local redis_connection_timeout = 1000local redis_key = &quot;ip_blacklist&quot;-- 缓存时间，单位slocal cache_ttl = 100-- 以上是配置local ip = ngx.var.remote_addrlocal ip_blacklist = ngx.shared.ip_blacklistlocal last_update_time = ip_blacklist:get(&quot;last_update_time&quot;);-- 当缓存时间到期更新blacklistif last_update_time == nil or last_update_time &lt; ( ngx.now() - cache_ttl ) then local redis = require &quot;resty.redis&quot;; local red = redis:new(); red:set_timeout(redis_connect_timeout); local ok, err = red:connect(redis_host, redis_port); if not ok then ngx.say(&quot;redis connect failed: &quot;, err) ngx.log(ngx.DEBUG, &quot;Redis connection error while retrieving ip_blacklist: &quot; .. err); return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) else -- local res, err = red:auth(&quot;foobared&quot;) -- 配置redis的密码，我测试未设置密码，代码注释 --if not res then --ngx.say(&quot;redis auth is error: &quot;, err) --return --end red:select(0) -- 设置redis的db local new_ip_blacklist, err = red:smembers(redis_key); if err then ngx.log(ngx.DEBUG, &quot;Redis read error while retrieving ip_blacklist: &quot; .. err); else -- 情况本地存储 ip_blacklist:flush_all(); for index, banned_ip in ipairs(new_ip_blacklist) do ip_blacklist:set(banned_ip, true); end -- 更新时间 ip_blacklist:set(&quot;last_update_time&quot;, ngx.now()); end endendif ip_blacklist:get(ip) then --ngx.say(ip) ngx.log(ngx.DEBUG, &quot;Banned IP detected and refused access: &quot; .. ip); return ngx.exit(ngx.HTTP_FORBIDDEN);end 完成。 当然了，这只是个基础版本，你可以让这个禁止访问功能更强大，比如增加可疑ip写入，比如增加ip限流等等。","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"}]},{"title":"Laravel管理日志","slug":"Laravel管理日志","date":"2019-07-04T15:50:25.000Z","updated":"2021-04-13T07:32:28.168Z","comments":true,"path":"2019/07/04/191/","link":"","permalink":"http://github.13sai.com/2019/07/04/191/","excerpt":"","text":"日志是很重要的东西，那么如何配置能让Laravel更好管理和查看呢？ 按日查看设置简单，在.env加入APP_LOG=daily，另外可定义最大日志保存天数在配置文件config/app.php中添加如下代码：1log_max_files=&gt;30 收集重要日志123Log::useFiles(storage_path(logs/important.log));// 按日，存储30天的Log::useDailyFiles(storage_path(logs/importantDaily.log, 30));","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://github.13sai.com/tags/Laravel/"}]},{"title":"快速找到php.ini文件位置","slug":"快速找到php.ini文件位置","date":"2019-06-26T16:02:04.000Z","updated":"2020-02-28T01:42:08.860Z","comments":true,"path":"2019/06/27/190/","link":"","permalink":"http://github.13sai.com/2019/06/27/190/","excerpt":"","text":"现在服务器装多个版本php很常见，那么如何快速找到php.ini文件位置呢？ phpinfo() php -i | grep php.ini find / -name php.ini php –ini","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"Laravel模板渲染的问题","slug":"Laravel模板渲染的问题","date":"2019-05-22T06:36:12.000Z","updated":"2021-04-13T07:32:32.489Z","comments":true,"path":"2019/05/22/189/","link":"","permalink":"http://github.13sai.com/2019/05/22/189/","excerpt":"","text":"1. laravel模板变量符更改前几天改版时，前后端分离，前端使用了art-template，刚好有和Laravel默认的变量符号，就发现了点问题。 解决方法： 前端修改art-template的符号，防止和Laravel冲突； 修改Laravel模板变量符-双大括号 可以在控制器调用view方法之前加入 12Blade::setContentTags([[, ]]);Blade::setEscapedContentTags(&#123;[@, @]&#125;); 便可以用{[@, @]}替代原来的双大括号。 2. 加载html不使用blade模板引擎除了这个还有一个问题，比如前后端分离的时候，我只想加载html，不需要渲染替换，这时候怎么办呢？ 1234Route::get(/, function () &#123; \\View::addExtension(html, php); return view()-&gt;file(index.html);//注意此处路径是public&#125;); 就这样加载就ok 了。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://github.13sai.com/tags/Laravel/"}]},{"title":"从缓存穿透聊到布隆过滤器","slug":"从缓存穿透聊到布隆过滤器","date":"2019-05-21T07:59:02.000Z","updated":"2021-04-26T03:41:06.274Z","comments":true,"path":"2019/05/21/188/","link":"","permalink":"http://github.13sai.com/2019/05/21/188/","excerpt":"","text":"缓存现在在web领域应用广泛，相信大部分开发人员都会用到，然而你遇见过缓存穿透吗？ 什么是缓存穿透？ 缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，但是出于容错的考虑，如果从存储层查不到数据则不写入缓存层。简单说，就查询一个不存在的key，因为没有缓存，就会去数据库查询，从而达到穿透缓存。增大数据库压力的险恶目的。 一般来说，不是恶意操作，正常来说，不会遇到这样的问题，然而，怕的就是一些险恶用心的攻击者。那么，我们如何有效处理这种问题呢？ 简单想一下，如果我们把有效的key集合起来，查询之前我们先判断一下查询的key是否在集合中，如果不在，直接打回去，让你调皮。这个问题不就解决了吗？ 但是，如果真的先把所有key组成集合，那这个存储占用的内存太大了，当有1亿个key，那存储空间也是相当可观的，有点太过浪费了。 为了不浪费，我跟你说，有一个小玩意叫“布隆过滤器”，它能帮你节省空间，节省钱。 布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。按上面的问题，我们可以把所有的key通过特定的算法，存储到这种二进制向量中，我们来看网上的一张图。 我们可以通过三个哈希算法将w存储到二进制向量，当查询w是否存在时，我们可以再通过这三个算法，如果算法算出来所在的位置均为1，则表示w可能存在（注意是可能存在），否则一定不存在。（这个很好理解，我就不做说明了） 说了这么多，我们来尝试下代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220&lt;?php/** * Author: sai * Date: 2019/5/17 * Time: 14:10 * 代码来自网络，有改动 */class BloomFilterHash&#123; /** * 由Justin Sobel编写的按位散列函数 */ public function JSHash($string, $len = null) &#123; $hash = 1315423911; $len || $len = strlen($string); for ($i=0; $i&lt;$len; $i++) &#123; $hash ^= (($hash &lt;&lt; 5) + ord($string[$i]) + ($hash &gt;&gt; 2)); &#125;// var_dump(($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF);die; return ($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF; &#125; /** * 该哈希算法基于AT＆T贝尔实验室的Peter J. Weinberger的工作。 * Aho Sethi和Ulman编写的“编译器（原理，技术和工具）”一书建议使用采用此特定算法中的散列方法的散列函数。 */ public function PJWHash($string, $len = null) &#123; $bitsInUnsignedInt = 4 * 8; //（unsigned int）（sizeof（unsigned int）* 8）; $threeQuarters = ($bitsInUnsignedInt * 3) / 4; $oneEighth = $bitsInUnsignedInt / 8; $highBits = 0xFFFFFFFF &lt;&lt; (int) ($bitsInUnsignedInt - $oneEighth); $hash = 0; $test = 0; $len || $len = strlen($string); for($i=0; $i&lt;$len; $i++) &#123; $hash = ($hash &lt;&lt; (int) ($oneEighth)) + ord($string[$i]); &#125; $test = $hash &amp; $highBits; if ($test != 0) &#123; $hash = (($hash ^ ($test &gt;&gt; (int)($threeQuarters))) &amp; (~$highBits)); &#125;// var_dump(($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF);die; return ($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF; &#125; /** * 类似于PJW Hash功能，但针对32位处理器进行了调整。它是基于UNIX的系统上的widley使用哈希函数。 */ public function ELFHash($string, $len = null) &#123; $hash = 0; $len || $len = strlen($string); for ($i=0; $i&lt;$len; $i++) &#123; $hash = ($hash &lt;&lt; 4) + ord($string[$i]); $x = $hash &amp; 0xF0000000; if ($x != 0) &#123; $hash ^= ($x &gt;&gt; 24); &#125; $hash &amp;= ~$x; &#125;// var_dump(($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF);die; return ($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF; &#125; /** * 这个哈希函数来自Brian Kernighan和Dennis Ritchie的书“The C Programming Language”。 * 它是一个简单的哈希函数，使用一组奇怪的可能种子，它们都构成了31 .... 31 ... 31等模式，它似乎与DJB哈希函数非常相似。 */ public function BKDRHash($string, $len = null) &#123; $seed = 131; # 31 131 1313 13131 131313 etc.. $hash = 0; $len || $len = strlen($string); for ($i=0; $i&lt;$len; $i++) &#123; $hash = (int) (($hash * $seed) + ord($string[$i])); &#125;// var_dump(($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF);die; return ($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF; &#125; /** * 这是在开源SDBM项目中使用的首选算法。 * 哈希函数似乎对许多不同的数据集具有良好的总体分布。它似乎适用于数据集中元素的MSB存在高差异的情况。 */ public function SDBMHash($string, $len = null) &#123; $hash = 0; $len || $len = strlen($string); for ($i=0; $i&lt;$len; $i++) &#123; $hash = (int) (ord($string[$i]) + ($hash &lt;&lt; 6) + ($hash &lt;&lt; 16) - $hash); &#125;// var_dump(($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF);die; return ($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF; &#125; /** * 由Daniel J. Bernstein教授制作的算法，首先在usenet新闻组comp.lang.c上向世界展示。 * 它是有史以来发布的最有效的哈希函数之一。 */ public function DJBHash($string, $len = null) &#123; $hash = 5381; $len || $len = strlen($string); for ($i=0; $i&lt;$len; $i++) &#123; $hash = (int) (($hash &lt;&lt; 5) + $hash) + ord($string[$i]); &#125; var_dump(($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF);die; return ($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF; &#125; /** * Donald E. Knuth在“计算机编程艺术第3卷”中提出的算法，主题是排序和搜索第6.4章。 */ public function DEKHash($string, $len = null) &#123; $len || $len = strlen($string); $hash = $len; for ($i=0; $i&lt;$len; $i++) &#123; $hash = (int) (($hash &lt;&lt; 5) ^ ($hash &gt;&gt; 27)) ^ ord($string[$i]); &#125;// var_dump((int)($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF);die; return ($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF; &#125; /** * 参考 http://www.isthe.com/chongo/tech/comp/fnv/ */ public function FNVHash($string, $len = null) &#123; $prime = 16777619; //32位的prime 2^24 + 2^8 + 0x93 = 16777619 $hash = 2166136261; //32位的offset $len || $len = strlen($string); for ($i=0; $i&lt;$len; $i++) &#123; $hash = (int) ($hash * $prime) % 0xFFFFFFFF; $hash ^= ord($string[$i]); &#125;// var_dump(($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF);die; return ($hash % 0xFFFFFFFF) &amp; 0xFFFFFFFF; &#125;&#125;/** * 使用redis实现的布隆过滤器 */abstract class BloomFilterRedis&#123; /** * 需要使用一个方法来定义bucket的名字 */ protected $bucket; protected $hashFunction; public function __construct() &#123; if (!$this-&gt;bucket || !$this-&gt;hashFunction) &#123; throw new Exception(&quot;需要定义bucket和hashFunction&quot;, 1); &#125; $this-&gt;Hash = new BloomFilterHash; $this-&gt;Redis = self::getRedis(); //假设这里你已经连接好了 &#125; public static function getRedis() &#123; $redis = new Redis(); $redis-&gt;connect(127.0.0.1, 6379);// $redis-&gt;auth(13sai666.);// var_dump($redis-&gt;info(SERVER));die; $redis-&gt;select(7); return $redis; &#125; /** * 添加到集合中 */ public function add($string) &#123; foreach ($this-&gt;hashFunction as $function) &#123; $hash = $this-&gt;Hash-&gt;$function($string); $this-&gt;Redis-&gt;setBit($this-&gt;bucket, $hash, 1); &#125; return true; &#125; /** * 查询是否存在, 存在的一定会存在, 不存在有一定几率会误判 */ public function exists($string) &#123; $pipe = $this-&gt;Redis-&gt;multi(); $len = strlen($string); foreach ($this-&gt;hashFunction as $function) &#123; $hash = $this-&gt;Hash-&gt;$function($string, $len); $pipe = $pipe-&gt;getBit($this-&gt;bucket, $hash); &#125; $res = $pipe-&gt;exec();// var_dump($res); foreach ($res as $bit) &#123; if ($bit == 0) &#123; return false; &#125; &#125; return true; &#125;&#125;/** * 重复内容过滤器 * 该布隆过滤器总位数为2^32位, 判断条数为2^30条. hash函数最优为3个.(能够容忍最多的hash函数个数) * * 注意, 在存储的数据量到2^30条时候, 误判率会急剧增加, 因此需要定时判断过滤器中的位为1的的数量是否超过50%, 超过则需要清空. */class FilteRepeatedComments extends BloomFilterRedis&#123; /** * 表示判断重复内容的过滤器 * @var string */ protected $bucket = bulong; protected $hashFunction = [FNVHash, JSHash, ELFHash];&#125; 可以调用测试下， 12345var_dump((new FilteRepeatedComments())-&gt;add(abc)); //truevar_dump((new FilteRepeatedComments())-&gt;add(bcd));//truevar_dump((new FilteRepeatedComments())-&gt;add(dfg));//truevar_dump((new FilteRepeatedComments())-&gt;exists(dfg));//truevar_dump((new FilteRepeatedComments())-&gt;exists(dgg));//false 简单的测试通过！ 当然，应用时需要进行更多的测试。 那么这个叫“布隆过滤器”的东东真有那么好用？ 我相信，你应该可以看出来，这是有误判率的，另外删除也是困难的。 具体误判推导过程，可以参考： 布隆过滤器(bloom filter)介绍以及php和redis实现布隆过滤器实现方法 布隆过滤器简介 应用场景： 垃圾邮件过滤 爬虫的url过滤 防止缓存击穿 好了，就介绍到这里啦！","categories":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"}]},{"title":"第一次输入验证码总是失败","slug":"第一次输入验证码总是失败","date":"2019-04-30T09:02:53.000Z","updated":"2021-04-26T03:41:09.653Z","comments":true,"path":"2019/04/30/187/","link":"","permalink":"http://github.13sai.com/2019/04/30/187/","excerpt":"","text":"上周网站改版时，表单提交遇到一个问题，就是输入图片验证码，第一次总是失败，即便输入无误，照样失败，第二次就能正常验证了。 分析原因： session不同步 模板渲染的问题 验证码图片生成问题 第一个，如果session不同步，按理说，点击刷新后应该也会失败。第二个，原来的未出现这个问题，按理说也不会是这个原因。第三个，修改下js代码，待页面渲染完成后再加载图片，试验无效。 打开调试器，发现有两张图片加载失败，是路径问题，修改后提交测试，发现验证码问题没了。 没了？？？what？？？why？？？","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/tags/web/"}]},{"title":"Linux的top命令详解","slug":"Linux的top命令详解","date":"2019-04-26T02:57:12.000Z","updated":"2021-04-13T07:32:35.131Z","comments":true,"path":"2019/04/26/186/","link":"","permalink":"http://github.13sai.com/2019/04/26/186/","excerpt":"","text":"top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，常用于服务端性能分析。 统计信息区前五行是系统整体的统计信息。具体如下： 123456789101112131415161718192021222324252627282930313233343536第一行服务器运行信息：09:46:41 当前时间up 71days，16:51 系统运行时间，格式为天，时:分2 users 当前登录用户数load average: 0.00, 0.00, 0.00 系统负载，即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 第二行为进程信息Tasks:total 进程总数running 正在运行的进程数sleeping 睡眠的进程数stopped 停止的进程数zombie 僵尸进程数第三行CPU信息Cpu(s): 0.5% us 用户空间占用CPU百分比0.3% sy 内核空间占用CPU百分比0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比99.0% id 空闲CPU百分比0.0% wa 等待输入输出的CPU时间百分比0.2%hi：硬件CPU中断占用百分比0.0%si：软中断占用百分比0.0%st：虚拟机占用百分比 第四行Mem内存信息:8189652k total 物理内存总量7885740k used 使用的物理内存总量303912k free 空闲内存总量566272k buffers 用作内核缓存的内存量第五行swap交换分区信息: 4194300k total 交换区总量15544k used 使用的交换区总量4178756k free 空闲交换区总量1318852k cached 缓存的交换区总量，即可用交换区内存 当然，也推荐使用其他运行分析可视化工具，如htop，功能相比top更为强大。","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"}]},{"title":"面试技术问题汇总","slug":"面试技术问题汇总","date":"2019-04-16T08:56:29.000Z","updated":"2020-12-09T10:35:30.599Z","comments":true,"path":"2019/04/16/185/","link":"","permalink":"http://github.13sai.com/2019/04/16/185/","excerpt":"","text":"Linux rpm和yum的区别 Linux命令大全 redis redis持久化 redis数据类型详解 mysql mysql执行过程 mysql存储引擎 nginx nginx健康监测 PHP 面向对象 this,self和parent more 如何设计一个框架？ 你用过的框架对比看看优缺点？ mysql连接池有了解吗？如何实现？ php-fpm配置pm为static和dynamic的区别？ 说说代码重构的思路？ 印象比较深刻的项目或者技术点？ 最近在看的技术书籍？ 暂时想到的就这些，后续会补充思路等。","categories":[{"name":"life","slug":"life","permalink":"http://github.13sai.com/categories/life/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://github.13sai.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"nginx配置根据url指向不同的目录","slug":"Nginx配置根据url指向不同的目录","date":"2019-04-16T02:07:51.000Z","updated":"2021-04-13T07:33:58.488Z","comments":true,"path":"2019/04/16/184/","link":"","permalink":"http://github.13sai.com/2019/04/16/184/","excerpt":"","text":"前几日，把老项目做前后端分离的时候，因为后台还是保留，前台做成前后端分离，遇到的一个需求。 老项目php版本5.6，新接口考虑使用php7.0，于是考虑根据url做nginx配置。 思路一：根据url区分php版本，再根据版本指向对应的root目录。主要配置如下： 12345678910111213141516171819202122232425262728293031server &#123; listen 80; server_name old.com; root /data/www/old; location / &#123; index index.html index.htm index.php; try_files $uri $uri/ /index.php?$query_string; &#125; location /api/ &#123; root /data/www/new; index index.html index.htm index.php; try_files $uri $uri/ /index.php?$query_string&amp;php=7; &#125; location ~ \\.php$ &#123; # 9000端口对应php-fpm5.6 , 9001端口对应php-fpm7.0 fastcgi_pass 127.0.0.1:9000; if ($args ~* &quot;php=7&quot;)&#123; root /data/www/new; fastcgi_pass 127.0.0.1:9001; &#125; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; ...&#125; 试验成功，只是总感觉别扭，因为在query_string后面加入php=7不那么优雅，对吧？而且如果有人习惯获取所有的query_string而不做处理，很容易引起问题。 思路二：根据url转发到另一个端口，另一个server监听此端口。主要配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647server &#123; listen 80; server_name old.com; root /data/www/old; location / &#123; index index.html index.htm index.php; try_files $uri $uri/ /index.php?$query_string; &#125; location /api/ &#123; proxy_pass http://127.0.0.1:8009; &#125; location ~ \\.php$ &#123; # 9000端口对应php-fpm5.6 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; ...&#125;server &#123; listen 8080; root /data/www/new; location / &#123; index index.html index.htm index.php; try_files $uri $uri/ /index.php?$query_string; &#125; location ~ \\.php$ &#123; # 9001端口对应php-fpm7.0 fastcgi_pass 127.0.0.1:9001; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; ...&#125; 相比第一个这个只会多占用个端口，但优雅多了！","categories":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/tags/nginx/"}]},{"title":"windows下的elasticsearch尝试","slug":"windows下的elasticsearch尝试","date":"2019-04-10T06:35:49.000Z","updated":"2021-04-26T03:39:06.944Z","comments":true,"path":"2019/04/10/183/","link":"","permalink":"http://github.13sai.com/2019/04/10/183/","excerpt":"","text":"环境：windows7 64位 ElasticSearch（后面简称es）基于java，所以务必先安装java，java安装省略，建议安装最新的稳定版。 安装eses下载 解压后进入目录，启动bin/elasticsearch.bat 访问： http://localhost:9200/ 可以看到一些信息，版本等，就表明已经安装病启动成功！ 安装HEAD插件 git clone git://github.com/mobz/elasticsearch-head.gitcd elasticsearch-headnpm installnpm run start 浏览器打开， http://localhost:9100/，可以看到刚开启动的ES实例。 伪集群打开config下得elasticsearch.yml 加入以下配置： 12345# 自定义配置cluster.name: sai_esnode.name: es0node.master: truehttp.port: 9200 复制es文件夹到es1,es2,修改配置: 123456789101112131415es1:# 自定义配置cluster.name: sai_esnode.name: es1node.master: falsehttp.port: 9201discovery.zen.ping.unicast.hosts: [&quot;127.0.0.1&quot;]es2:# 自定义配置cluster.name: sai_esnode.name: es2node.master: falsehttp.port: 9202discovery.zen.ping.unicast.hosts: [&quot;127.0.0.1&quot;] 注意，此时要保证es1，es2下面data目录为空，否则启动时会因为冲突id连接不上es0。 然后启动es1，es2，通过head插件，我们可以看到集群搭建完成！sai_es集群下有3个实例：es0，es1，es2。 集群搭建成功！","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://github.13sai.com/categories/ElasticSearch/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://github.13sai.com/tags/ElasticSearch/"}]},{"title":"redis集群配置","slug":"redis集群配置","date":"2019-03-29T01:44:15.000Z","updated":"2021-04-13T07:36:31.512Z","comments":true,"path":"2019/03/29/182/","link":"","permalink":"http://github.13sai.com/2019/03/29/182/","excerpt":"","text":"环境：centos7.5，redis5.0.0 下载安装在合适的目录，我是安装在/usr/local/redis-5.0.0下，过程比较简单，不赘述了。 同级下新建cluster，拷贝redis.conf文件进来，生成4个文件redis_2001.conf、redis_2002.conf、redis_2003.conf、redis_2004.conf，修改对应配置。 主要配置如下 123456789101112131415161718# 端口号port 2001# 后台启动daemonize yes# 开启集群cluster-enabled yes# 集群节点配置文件cluster-config-file nodes-2001.conf# 进程pid的文件位置pidfile /var/run/redis-2001.pid# 持久化配置# 开启aofappendonly yes# aof文件路径appendfilename &quot;appendonly-2001.aof&quot;# rdb文件路径dbfilename dump-2001.rdb 启动redis， 1234redis-server cluster/redis-2001.confredis-server cluster/redis-2002.confredis-server cluster/redis-2003.confredis-server cluster/redis-2004.conf 连接构建redis集群 ./redis-trib.rb create –replicas 1 127.0.0.1:2001 127.0.0.1:2002 127.0.0.1:2003 127.0.0.1:2004 抛出警告： WARNING: redis-trib.rb is not longer available! 5.0版本抛弃了redis-trib。 按照提示执行： redis-cli –cluster create 127.0.0.1:2001 127.0.0.1:2002 127.0.0.1:2003 127.0.0.1:2004 –cluster-replicas 1 错误输出如下： 1234*** ERROR: Invalid configuration for cluster creation.*** Redis Cluster requires at least 3 master nodes.*** This is not possible with 4 nodes and 1 replicas per node.*** At least 6 nodes are required. 因为是单机测试而已，去掉复制 redis-cli –cluster create 127.0.0.1:2001 127.0.0.1:2002 127.0.0.1:2003 127.0.0.1:2004 然后有个保存配置的确认，yes之后成功！ 1234[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 进入客户端 redis-cli -p 2001 查看节点 cluster nodes 123490a734c7716a00060584acb82cb3dd7e437a5459 127.0.0.1:2003@12003 master - 0 1541042930063 3 connected 8192-122877ac1fab72c275ba9549a9da71245fdd29a3920a6 127.0.0.1:2002@12002 master - 0 1541042930563 2 connected 4096-8191490035c372472798a224b6d00c249d8b41508b78 127.0.0.1:2001@12001 myself,master - 0 1541042928000 1 connected 0-40959101d285b991c6dcb086cf3da4cd0eae7777ece0 127.0.0.1:2004@12004 master - 0 1541042929563 4 connected 12288-16383 可以看出集群已搭建成功！ 对应的php可以使用predis操作redis，当然\\Redis也足够好用了,up to u。","categories":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"}]},{"title":"php小试rabbitmq","slug":"php小试rabbitmq","date":"2019-03-29T01:36:57.000Z","updated":"2021-04-13T07:36:58.130Z","comments":true,"path":"2019/03/29/181/","link":"","permalink":"http://github.13sai.com/2019/03/29/181/","excerpt":"","text":"RabbitMQ is lightweight and easy to deploy on premises and in the cloud. It supports multiple messaging protocols. RabbitMQ can be deployed in distributed and federated configurations to meet high-scale, high-availability requirements. 1. 安装：windows安装十分简单，印象中装的过程几乎无障碍，忽略。 centos7安装过程如下： 依赖安装 yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC-devel socat 安装erlang，务必在下面的地址下载，之前在官网下载，安装总是有问题，浪费了大把时间。 1https://dl.bintray.com/rabbitmq/rpm/erlang/20/el/7/ 官网下载rabiitmq，rpm安装 rpm -ivh (rpm包) 2. 配置启动rabbitmq /bin/systemctl start rabbitmq-server.service 片刻之后，可以查看状态是否active bin/systemctl status rabbitmq-server.service cp rabbitmq.config.example /etc/rabbitmq/cd /etc/rabbitmq/mv rabbitmq.config.example rabbitmq.config 修改成你想要的配置，然后重启。 3. UI启动 rabbitmq-plugins enable rabbitmq_management 然后根据配置打开界面 安全性问题，可以禁止外部guest访问，新建账户 rabbitmqctl add_user 13sai 12345678rabbitmqctl set_user_tags 13sai administrator 并修改配置： {loopback_users, [&lt;&lt;”guest”&gt;&gt;]} 重启rabbitmq服务。 4. 简单实例生产者： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php/** * Created by PhpStorm. * User: 13sai * Date: 2018/11/5 * Time: 10:39 */// 配置信息$config = [ host =&gt; localhost, port =&gt; 5672, login =&gt; sai, password =&gt; 123456, vhost=&gt;/];$exName = changes; //交换机名$route = key; //路由key// 创建连接和channel$conn = new AMQPConnection($config);if (!$conn-&gt;connect()) &#123; die(&quot;连接失败&quot;);&#125;$channel = new AMQPChannel($conn);//消息内容$message = &quot;消息测试&quot;;//创建交换机$ex = new AMQPExchange($channel);$ex-&gt;setName($exName);//发送消息，注意持久化也要设置[delivery_mode =&gt; AMQP_DURABLE]for($i=0; $i&lt;5; $i++)&#123; echo &quot;Send Message:&quot;.$ex-&gt;publish($i.:.$message, $route, AMQP_DURABLE, [delivery_mode =&gt; AMQP_DURABLE]).&quot;&quot;;&#125;$conn-&gt;disconnect(); 消费者： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** * Created by PhpStorm. * User: 13sai * Date: 2018/11/5 * Time: 10:39 */$config = [ host =&gt; localhost, port =&gt; 5672, login =&gt; sai, password =&gt; 123456, vhost=&gt;/];$exName = changes; //交换机名$queueMame = queue1; //队列名$route = key; //路由key// 创建连接和channel$conn = new AMQPConnection($config);if (!$conn-&gt;connect()) &#123; die(&quot;连接失败&quot;);&#125;$channel = new AMQPChannel($conn);// 创建交换机$ex = new AMQPExchange($channel);$ex-&gt;setName($exName);$ex-&gt;setType(AMQP_EX_TYPE_DIRECT); //direct类型$ex-&gt;setFlags(AMQP_DURABLE); //持久化，很重要echo &quot;Exchange Status:&quot;.$ex-&gt;declare().&quot;&quot;;// 创建队列$queue = new AMQPQueue($channel);$queue-&gt;setName($queueMame);$queue-&gt;setFlags(AMQP_DURABLE); //持久化echo &quot;Message Total:&quot;.$queue-&gt;declare().&quot;&quot;;//绑定交换机与队列，并指定路由键echo Queue Bind: .$queue-&gt;bind($exName, $route).&quot;&quot;;//阻塞模式接收消息echo &quot;Message:&quot;;while(True)&#123; $queue-&gt;consume(processMessage);&#125;$conn-&gt;disconnect();/** * 消费回调函数 * 处理消息 */function processMessage($envelope, $queue) &#123; $msg = $envelope-&gt;getBody(); echo $msg.&quot;&quot;; //处理消息 $queue-&gt;ack($envelope-&gt;getDeliveryTag()); //手动发送ACK应答&#125; 花了些时间，不过弄出来还是感觉不错的。","categories":[{"name":"MQ","slug":"MQ","permalink":"http://github.13sai.com/categories/MQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://github.13sai.com/tags/RabbitMQ/"}]},{"title":"LNMP设置开机自启动","slug":"LNMP设置开机自启动","date":"2019-03-29T01:33:25.000Z","updated":"2021-04-13T07:32:44.500Z","comments":true,"path":"2019/03/29/180/","link":"","permalink":"http://github.13sai.com/2019/03/29/180/","excerpt":"","text":"有时候服务器需要重启，但重启各种程序需要启动是个麻烦的事情，我们尝试配置开机自启动。 环境：centos 7.5 我的版本跟低版本有多不同，不能通过chkconfig add命令加入，我们可以进入目录 /lib/systemd/system 依次新建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// mysqld.service[Unit]Description=mysqlAfter=network.target[Service]Type=forkingExecStart=/usr/bin/mysql.serverExecReload=/bin/systemctl restart mysqld.serviceExecStop=/bin/systemctl stop mysqld.servicePrivateTmp=true[Install]WantedBy=multi-user.target----------//nginx.service[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/bin/nginxExecReload=/usr/bin/nginx -s reloadExecStop=/usr/bin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target----------// php-fpm.service[Unit]Description=php-fpmAfter=network.target[Service]Type=forkingExecStart=/usr/bin/php-fpmExecReload=ps -ef|grep php-fpm|awk -F &#123;print &#125;|xargs kill -USR2ExecStop=ps -ef|grep php-fpm|awk -F &#123;print &#125;|xargs kill -INTPrivateTmp=true[Install]WantedBy=multi-user.target----------// redis.service[Unit]Description=redisAfter=network.target[Service]Type=forkingExecStart=/usr/bin/redis-server /usr/local/redis-5.0.0/redis.confExecStop=/usr/local/redis-5.0.0/redis-cli shutdownPrivateTmp=true[Install]WantedBy=multi-user.target ExecStart,ExecStop,ExecReload各有不同，自行修改 并且systemctl enable启动。 reboot 测试一下。 脚本说明 12345678910111213141516171819202122232425262728293031323334主要有以下三部分[unit] :定义与Unit类型无关的通用选项；用于提供unit的描述信息、 unit行为及依赖关系等[Service]：与特定类型相关的专用选项；此处为Service类型[Install]：定义由“ systemctl enable”以及&quot;systemctl disable“命令在实现服务启用或禁用时用到的一些选项----------Service参数EnvironmentFile：环境配置文件ExecStart：指明启动unit要运行命令或脚本的绝对路径ExecStartPre： ExecStart前运行ExecStartPost： ExecStart后运行ExecRsload: 重启当前服务时执行的命令ExecStopPost：停止当前服务之后执行的命令ExecStartSec：自动重启当前服务间隔的秒数ExecStop：指明停止unit要运行的命令或脚本Restart：当设定Restart=1时，则当次daemon服务意外终止后，会再次自动启动此服务。TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数。Environment：指定环境变量。----------Install参数：Alias：别名，可使用systemctl command Alias.serviceRequiredBy：被哪些units所依赖，强依赖WantedBy：被哪些units所依赖，弱依赖Also：安装本服务的时候还要安装别的相关服务 更多请看：在linux下创建自定义服务linux中的unit的配置文件","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"}]},{"title":"redis数据类型，持久化以及应用场景","slug":"redis数据类型，持久化以及应用场景","date":"2019-02-15T09:21:34.000Z","updated":"2021-04-13T07:36:11.074Z","comments":true,"path":"2019/02/15/179/","link":"","permalink":"http://github.13sai.com/2019/02/15/179/","excerpt":"","text":"先推荐个redis命令网站，感觉比官网简介，平时用得比较多，友情链接一下。 Redis命令参考 数据类型 string hash set sorted set list 主要有以上五大数据类型。另外还有 pub/sub 发布订阅 geo O2O应用 transactions 事务（不应该是数据类型，应该算特性） 持久化 AOF：（可理解为增量备份）记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾 RDB：（可理解为全备份）在指定的时间间隔能对你的数据进行快照存储 RDB 的优点 RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。 RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，易于迁移。 RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。 RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 RDB 的缺点 如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。 每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。 AOF 的优点 使用 AOF 持久化会让 Redis 变得非常耐久，你可以设置不同的 fsync 策略，默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。 AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。 Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。 AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。AOF 的缺点 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB（这里指的应该指的是相同数据集更慢） 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。 AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。 优缺点一说明，你就知道应该选用那种持久化机制了，但依旧建议，如果条件允许同时启用AOF和RDB，可能性能会稍有影响，但后期恢复会方便很多。 应用场景 缓存（最常用） 队列 发布订阅 LBS 计数器，pv，uv等统计 分布式锁 好了，redis的一些知识介绍到这里。","categories":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"}]},{"title":"Redis为什么使用单进程单线程方式也这么快","slug":"Redis为什么使用单进程单线程方式也这么快","date":"2019-02-12T09:53:01.000Z","updated":"2021-04-13T07:36:14.926Z","comments":true,"path":"2019/02/12/178/","link":"","permalink":"http://github.13sai.com/2019/02/12/178/","excerpt":"","text":"Redis 采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由 C 语言编写。官方提供的数据是可以达到100k+的qps。这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差。 Redis 快的主要原因有： 完全基于内存 数据结构简单，对数据操作也简单 使用多路 I/O 复用模型,非阻塞IO 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求 多路 I/O 复用模型多路 I/O 复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了 Redis 具有很高的吞吐量。 和 Memcached 不同，Redis 并没有直接使用 Libevent，而是自己完成了一个非常轻量级的对 select、epoll、evport、kqueue 这些通用的接口的实现。在不同的系统调用选用适合的接口，linux 下默认是 epoll。因为 Libevent 比较重，更通用，代码量也就很庞大，拥有很多 Redis 用不上的功能，Redis 为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。 单进程单线程好处 代码更清晰，处理逻辑更简单 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗 不存在多进程或者多线程导致的切换而消耗 CPU 单进程单线程弊端无法发挥多核 CPU 性能，不过可以通过在单机开多个 Redis 实例来完善 其他一些优秀的开源软件采用的模型1.单进程多线程模型：MySQL、Memcached、Oracle(Windows版本）2.多进程模型：Oracle（Linux版本）3.Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。 Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。 参考：为什么说Redis是单线程的以及Redis为什么这么快！Redis单线程原理","categories":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"}]},{"title":"基于mycat实现读写分离","slug":"基于mycat实现读写分离","date":"2019-01-11T17:29:53.000Z","updated":"2019-11-27T10:13:31.695Z","comments":true,"path":"2019/01/12/177/","link":"","permalink":"http://github.13sai.com/2019/01/12/177/","excerpt":"","text":"mysql中间件，分库分表，读写分离。 环境： centos7.4 mysql5.7 下载安装下载地址 解压到你喜欢的目录。 启动 ./bin/mycat start tips:建议修改配置文件时bak下原配置文件。 秒启动，尝试修改配置(conf/wrapper.conf)，保存后发现mycat进程没有了。 猜测是OOM kill了，查看系统日志，貌似无mycat异常。 dmesg | tail -20 查看logs目录下日志，应该是内存不足。（心疼ecs1cpu1g的配置） 修改conf/wrapper.conf 12345678910111213# Java Additional Parameters#wrapper.java.additional.1=wrapper.java.additional.1=-DMYCAT_HOME=.wrapper.java.additional.2=-serverwrapper.java.additional.3=-XX:MaxPermSize=64Mwrapper.java.additional.4=-XX:+AggressiveOptswrapper.java.additional.5=-XX:MaxDirectMemorySize=256Mwrapper.java.additional.6=-Dcom.sun.management.jmxremotewrapper.java.additional.7=-Dcom.sun.management.jmxremote.port=1984wrapper.java.additional.8=-Dcom.sun.management.jmxremote.authenticate=falsewrapper.java.additional.9=-Dcom.sun.management.jmxremote.ssl=falsewrapper.java.additional.10=-Xmx512Mwrapper.java.additional.11=-Xms512M 重新启动，成功，进程也没有被kill，但内存已经80%左右了。 关闭ecs云监控缩减内存占用，调低mysql占用内存缓冲区。 开启3306,3307端口的mysql实例，增加mycat数据库，并配置master-slave，设置好所需账号密码权限。 关注下内存占用，约85%，还能撑住。 关闭mycat。 server.xml主要修改，数据库，账号密码。 1234&lt;user name=&quot;root&quot;&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;schemas&quot;&gt;sai&lt;/property&gt;&lt;/user&gt; sai为逻辑库，可自行配置。 schema.xml主要修改 1234567891011121314151617// sai对应server.xml配置&lt;schema name=&quot;sai&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt; &lt;table name=&quot;company&quot; primaryKey=&quot;ID&quot; type=&quot;global&quot; dataNode=&quot;dn1&quot; /&gt;&lt;/schema&gt;// localhost3306对应dataHost的name，database是真实的数据库&lt;dataNode name=&quot;dn1&quot; dataHost=&quot;localhost3306&quot; database=&quot;mycat&quot; /&gt;&lt;dataHost name=&quot;localhost3306&quot; maxCon=&quot;100&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;2&quot; slaveThreshold=&quot;30&quot;&gt; &lt;heartbeat&gt;show slave status&lt;/heartbeat&gt; // 读（3307）写（3306）实例 &lt;writeHost host=&quot;hostM1&quot; url=&quot;127.0.1:3306&quot; user=&quot;mycat&quot; password=&quot;111111&quot;&gt; &lt;!-- can have multi read hosts --&gt; &lt;readHost host=&quot;hostS2&quot; url=&quot;127.0.1:3307&quot; user=&quot;mycat&quot; password=&quot;111111&quot; /&gt; &lt;/writeHost&gt;&lt;/dataHost&gt; 123456789101112balance指的负载均衡类型，目前的取值有4种：0, 不开启读写分离机制，所有读操作都发送到当前可用的writeHost上。1，全部的readHost与stand by writeHost参与select语句的负载均衡，简单的说，当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且M1与 M2互为主备)，正常情况下，M2,S1,S2都参与select语句的负载均衡。2，所有读操作都随机的在writeHost、readhost上分发。3，所有读请求随机的分发到wiriterHost对应的readhost执行，writerHost不负担读压力switchType指的是切换的模式，目前的取值也有4种：-1， 表示不自动切换1， 默认值，表示自动切换，1.5版本后丢弃2 ，基于MySQL主从同步的状态决定是否切换,心跳语句为 show slave status 启动。 mysql -h127.0.0.1 -uroot -P8066 -p 输入密码进入，切换sai 默认端口8066，mysql执行下语句， INSERT INTO company VALUES (1, 13sai); select * from company; mysql实例已经开启了查询日志，查看日志，读写分离了。 吐槽 假如表很多，配置不是得晕死 最近发现很多好用的中间件底层都是java，考虑要不要入坑。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"如何恢复误删的数据库","slug":"如何恢复误删的数据库","date":"2019-01-10T17:43:38.000Z","updated":"2021-04-13T07:23:20.480Z","comments":true,"path":"2019/01/11/176/","link":"","permalink":"http://github.13sai.com/2019/01/11/176/","excerpt":"","text":"前段时间，某开发人员误删了一个数据库，导致我们的服务，最后是恢复了，过程我并不清楚，但引起了我的兴趣。因为误操作真的是很难避免的，开发人员那么多，一个不小心，就可能影响了其他人的使用，所以慎重操作，最好能禁用一些操作，比如drop！ 那么如何来恢复呢？ 如果有备份的话，当然去寻找最新的，然后恢复，如果不在意新增的数据，那么这样就足够了。 来看一下备份， 123456// 备份某个数据库某些表mysqldump [options] db_name [tbl_name ...] &gt; bak.sql// 备份多个数据库mysqldump [options] --databases db_name ...&gt; bak.sql// 备份所有数据库mysqldump [options] --all-databases&gt; bak.sql 个人建议单个备份，好独立操作。 了解更多请看：mysqldump 恢复操作（以单个数据库为例） mysql -h127.0.0.1 -uroot -p del &lt; bak.sql 操作是不是很简单？ 那么如果没有备份怎么办呢？ 第二种操作前提是开启了binlog，通过log恢复。 误删后可以保存下binlog mysqlbinlog mysql-bin.000011 &gt; del.log 打开文件，去掉drop操作并保存。 mysql -h127.0.0.1 -uroot -p &lt;del.log 当然，比较建议通过dump全备份操作，然后找出备份到drop的pos。 通过mysqlbinlog 的start-position和stop-position生成sql后恢复。这里就不赘述了。 有兴趣可以看看mysqlbinlog 好了，就说到这里，希望对你有所帮助。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"mysql高可用探讨（读写分离）","slug":"mysql高可用探讨（读写分离）","date":"2018-12-30T15:21:36.000Z","updated":"2021-04-13T07:33:07.683Z","comments":true,"path":"2018/12/30/175/","link":"","permalink":"http://github.13sai.com/2018/12/30/175/","excerpt":"","text":"上一篇我们聊到TP做读写分离的底层实现，相对来说，其实思路是清晰简单的，但这些其实都是基于数据库已经做到了主从配置。 如果你不知道，可以mysql主从实战 建议给从库单独开个账号只授权读的权限，而不是设置slave为read_only（我配置了，but没啥用） 但我们稍微深入思考一下，PHP框架里有做到高可用吗？加入从库其中一个挂了，照着TP的思路，依旧有可能去这个从库读取数据，这是我们不能接受的。 一主一从甚至一主多从的架构显然只能满足读写性能，而不能保证服务的高可用。我们知道任何一个服务挂掉的可能性都是存在的，我们说的高可用只能是尽可能小的避免整个服务挂掉的可能。由此你应该能想到多主多从，这个仅仅文章里的配置是完成不了的，PHP框架也是检测不了的。 我觉得PHP框架来做读写分离是不科学的，因为增加了代码的复杂度，我认为这些应该交给数据库来做，或者数据库中间件来做，各司其职吗。 我不知道是不是很多人会想到mysql_proxy，然而官方已经不推荐使用了，推荐使用mysql_router，有在自己的ECS上尝试了一下，配置相对还是简单的，没测试性能，但确实实现了一定程度的高可用。 当然你也可以去使用变形虫等中间件，他们的功能相比mysql_router更为强大。 此篇没有干货，只是纯技术探讨，我不过是在南京南站，没事码码字罢了！","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/tags/sql/"}]},{"title":"ThinkPHP读写分离的内部实现","slug":"ThinkPHP读写分离的内部实现","date":"2018-12-17T07:56:21.000Z","updated":"2021-04-13T07:35:28.381Z","comments":true,"path":"2018/12/17/174/","link":"","permalink":"http://github.13sai.com/2018/12/17/174/","excerpt":"","text":"分析的版本是TP3.2.3 此版本已经支持mysql数据库读写分离，配置比较简单，具体可看分布式数据库支持 我们尝试分析下源码实现： 不妨先yy一下，在写操作和读操作时区分开数据库连接分别连接master和slave。 我们可以看见Model.class.php的db初始化 12345678910111213141516171819202122232425public function db($linkNum = , $config = , $force = false) &#123; if ( === $linkNum &amp;&amp; $this-&gt;db) &#123; return $this-&gt;db; &#125; if (! isset ( $this-&gt;_db [$linkNum] ) || $force) &#123; // 创建一个新的实例 if (! empty ( $config ) &amp;&amp; is_string ( $config ) &amp;&amp; false === strpos ( $config, / )) &#123; // 支持读取配置参数 $config = C ( $config ); &#125; $this-&gt;_db [$linkNum] = Db::getInstance ( $config ); &#125; elseif (NULL === $config) &#123; $this-&gt;_db [$linkNum]-&gt;close (); // 关闭数据库连接 unset ( $this-&gt;_db [$linkNum] ); return; &#125; // 切换数据库连接 $this-&gt;db = $this-&gt;_db [$linkNum]; $this-&gt;_after_db (); // 字段检测 if (! empty ( $this-&gt;name ) &amp;&amp; $this-&gt;autoCheckFields) $this-&gt;_checkTableInfo (); return $this;&#125; 接着看DB单例， 1234567891011121314151617181920static public function getInstance($config = array()) &#123; $md5 = md5 ( serialize ( $config ) ); if (! isset ( self::$instance [$md5] )) &#123; // 解析连接参数 支持数组和字符串 $options = self::parseConfig ( $config ); // 兼容mysqli if (mysqli == $options [type]) $options [type] = mysql; // 如果采用lite方式 仅支持原生SQL 包括query和execute方法 $class = $options [lite] ? ThinkDbLite : Think\\Db\\Driver\\ . ucwords ( strtolower ( $options [type] ) ); if (class_exists ( $class )) &#123; self::$instance [$md5] = new $class ( $options ); &#125; else &#123; // 类没有定义 E ( L ( _NO_DB_DRIVER_ ) . : . $class ); &#125; &#125; self::$_instance = self::$instance [$md5]; return self::$_instance;&#125; 接着看见mysql驱动继承了抽象类Driver。 不妨找两个Model操作读（find）和写(add): 123456789101112public function find($options = array()) &#123; ... $resultSet = $this-&gt;db-&gt;select ( $options ); ...&#125;public function add($data = , $options = array(), $replace = false) &#123; ... $result = $this-&gt;db-&gt;insert ( $data, $options, $replace ); ...&#125; 我们只聚焦关键代码select 和insert 。然后去查看数据库驱动类代码： 12345678910public function select($options = array()) &#123; ... $result = $this-&gt;query ( $sql, ! empty ( $options [fetch_sql] ) ? true : false ); ...&#125;public function insert($data, $options = array(), $replace = false) &#123; ... return $this-&gt;execute ( $sql, ! empty ( $options [fetch_sql] ) ? true : false );&#125; 继续寻根，我们看见 123456789101112131415/** * 执行查询 返回数据集 */public function query($str, $fetchSql = false) &#123; $this-&gt;initConnect ( false ); ...&#125;/** * 执行语句 */public function execute($str, $fetchSql = false) &#123; $this-&gt;initConnect ( true ); ...&#125; 我们终于找到了根本， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 初始化数据库连接 * * @access protected * @param boolean $master * 主服务器 * @return void */ protected function initConnect($master = true) &#123; if (! empty ( $this-&gt;config [deploy] )) // 采用分布式数据库 $this-&gt;_linkID = $this-&gt;multiConnect ( $master ); else // 默认单数据库 if (! $this-&gt;_linkID) $this-&gt;_linkID = $this-&gt;connect (); &#125; /** * 连接分布式服务器 * * @access protected * @param boolean $master * 主服务器 * @return void */ protected function multiConnect($master = false) &#123; // 分布式数据库配置解析 $_config [username] = explode ( ,, $this-&gt;config [username] ); $_config [password] = explode ( ,, $this-&gt;config [password] ); $_config [hostname] = explode ( ,, $this-&gt;config [hostname] ); $_config [hostport] = explode ( ,, $this-&gt;config [hostport] ); $_config [database] = explode ( ,, $this-&gt;config [database] ); $_config [dsn] = explode ( ,, $this-&gt;config [dsn] ); $_config [charset] = explode ( ,, $this-&gt;config [charset] ); $m = floor ( mt_rand ( 0, $this-&gt;config [master_num] - 1 ) ); // 数据库读写是否分离 if ($this-&gt;config [rw_separate]) &#123; // 主从式采用读写分离 if ($master) // 主服务器写入 $r = $m; else &#123; if (is_numeric ( $this-&gt;config [slave_no] )) &#123; // 指定服务器读 $r = $this-&gt;config [slave_no]; &#125; else &#123; // 读操作连接从服务器 $r = floor ( mt_rand ( $this-&gt;config [master_num], count ( $_config [hostname] ) - 1 ) ); // 每次随机连接的数据库 &#125; &#125; &#125; else &#123; // 读写操作不区分服务器 $r = floor ( mt_rand ( 0, count ( $_config [hostname] ) - 1 ) ); // 每次随机连接的数据库 &#125; if ($m != $r) &#123; $db_master = array ( username =&gt; isset ( $_config [username] [$m] ) ? $_config [username] [$m] : $_config [username] [0], password =&gt; isset ( $_config [password] [$m] ) ? $_config [password] [$m] : $_config [password] [0], hostname =&gt; isset ( $_config [hostname] [$m] ) ? $_config [hostname] [$m] : $_config [hostname] [0], hostport =&gt; isset ( $_config [hostport] [$m] ) ? $_config [hostport] [$m] : $_config [hostport] [0], database =&gt; isset ( $_config [database] [$m] ) ? $_config [database] [$m] : $_config [database] [0], dsn =&gt; isset ( $_config [dsn] [$m] ) ? $_config [dsn] [$m] : $_config [dsn] [0], charset =&gt; isset ( $_config [charset] [$m] ) ? $_config [charset] [$m] : $_config [charset] [0] ); &#125; $db_config = array ( username =&gt; isset ( $_config [username] [$r] ) ? $_config [username] [$r] : $_config [username] [0], password =&gt; isset ( $_config [password] [$r] ) ? $_config [password] [$r] : $_config [password] [0], hostname =&gt; isset ( $_config [hostname] [$r] ) ? $_config [hostname] [$r] : $_config [hostname] [0], hostport =&gt; isset ( $_config [hostport] [$r] ) ? $_config [hostport] [$r] : $_config [hostport] [0], database =&gt; isset ( $_config [database] [$r] ) ? $_config [database] [$r] : $_config [database] [0], dsn =&gt; isset ( $_config [dsn] [$r] ) ? $_config [dsn] [$r] : $_config [dsn] [0], charset =&gt; isset ( $_config [charset] [$r] ) ? $_config [charset] [$r] : $_config [charset] [0] ); return $this-&gt;connect ( $db_config, $r, $r == $m ? false : $db_master ); &#125; 其实就是通过传入initConnect来区分读写操作，并根据配置去连接操作。 今天分析就到这里了，其实与我们yy的基本一致。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://github.13sai.com/tags/ThinkPHP/"}]},{"title":"php合成图片","slug":"php合成图片","date":"2018-12-13T14:16:39.000Z","updated":"2021-04-13T07:37:19.073Z","comments":true,"path":"2018/12/13/172/","link":"","permalink":"http://github.13sai.com/2018/12/13/172/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php/** * Created by PhpStorm. * User: 13sai * Date: 2018/12/7 */header(&quot;Content-type: image/png&quot;);//ob_clean();//$path_2 = D:workdata/2.png;$path_1 = D:workdata/1.png;$info2 = getimagesize($path_2);$info1 = getimagesize($path_1);function getImage($ext, $img)&#123; switch ($ext) &#123; case png : $ret = imagecreatefrompng($img); break; case jpeg: $ret = imagecreatefromjpeg($img); break; case gif: $ret = imagecreatefromgif($img); break; default: throw new \\Exception(不能识别的图片格式); break; &#125; return $ret??;&#125;//获取图片扩展名$type1 = image_type_to_extension($info1[2],false);$type2 = image_type_to_extension($info2[2],false);$image_1 = getImage($type1, $path_1);$image_2 = getImage($type2, $path_2);imagecopy( $image_1, $image_2, 50, 70, 0, 0, $info2[0], $info2[1] );// 输出imagepng($image_1, D:picscompose.png);imagedestroy($image_1);imagedestroy($image_2);","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"swoole发邮件","slug":"swoole发邮件","date":"2018-11-29T14:46:31.000Z","updated":"2021-04-13T07:36:23.227Z","comments":true,"path":"2018/11/29/171/","link":"","permalink":"http://github.13sai.com/2018/11/29/171/","excerpt":"","text":"Swoole：面向生产环境的 PHP 异步网络通信引擎 很早就知道了swoole，但一直没有实际用到生产中，最近在重构博客，就想着做点东西，先swoole发邮件练练手。 回顾下发邮件，我们使用PHPMailer来发送。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php/** * Created by PhpStorm. * User: 13sai * Date: 2018/11/29 * Time: 11:16 */require &#x27;../vendor/autoload.php&#x27;;use PHPMailer\\PHPMailer\\PHPMailer;use PHPMailer\\PHPMailer\\Exception;$mail = new PHPMailer(true);try &#123; //Server settings // $mail-&gt;SMTPDebug = 2; // Enable verbose debug output $mail-&gt;isSMTP(); // Set mailer to use SMTP $mail-&gt;Host = &#x27;smtp.163.com&#x27;; // Specify main and backup SMTP servers $mail-&gt;SMTPAuth = true; // Enable SMTP authentication $mail-&gt;Username = &#x27;sai@163.com&#x27;; // SMTP username $mail-&gt;Password = &#x27;*&#x27;; // SMTP password $mail-&gt;SMTPSecure = &#x27;tls&#x27;; // Enable TLS encryption, ssl also accepted $mail-&gt;Port = 25; // TCP port to connect to //收件人 $mail-&gt;setFrom(&#x27;sai@163.com&#x27;, &#x27;13sai&#x27;); $mail-&gt;addAddress(&#x27;957042781@qq.com&#x27;); // Name is optional $mail-&gt;addReplyTo(&#x27;957042781@qq.com&#x27;, &#x27;Information&#x27;);// $mail-&gt;addCC(&#x27;cc@example.com&#x27;);// $mail-&gt;addBCC(&#x27;bcc@example.com&#x27;); //附件 $mail-&gt;addAttachment(&#x27;/var/file.tar.gz&#x27;); // Add attachments $mail-&gt;addAttachment(&#x27;/tmp/image.jpg&#x27;, &#x27;new.jpg&#x27;); // Optional name //html $mail-&gt;isHTML(true); $mail-&gt;Subject = &#x27;Here is the subject&#x27;; $mail-&gt;Body = &#x27;This is the HTML message body &lt;b&gt;in bold!&lt;/b&gt;&#x27;; $mail-&gt;AltBody = &#x27;This is the body in plain text for non-HTML mail clients&#x27;; $mail-&gt;send(); echo &#x27;Message has been sent&#x27;;&#125; catch (Exception $e) &#123; echo &#x27;Message could not be sent.&#x27;; echo &#x27;Mailer Error: &#x27; . $mail-&gt;ErrorInfo;&#125; 运行发送，收到邮件。 主程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246&lt;?php/** Created by PhpStorm. User: 13sai Date: 2018/11/29 Time: 14:06/require dirname(DIR).&#x27;/vendor/autoload.php&#x27;;use PHPMailer\\PHPMailer\\PHPMailer;use PHPMailer\\PHPMailer\\Exception;class Mailer&#123; protected $server; protected $host = &#x27;127.0.0.1&#x27;; protected $port = 9502; // 进程名称 protected $taskName = &#x27;swooleMailer&#x27;; // PID路径 protected $pidPath = &#x27;/run/swooleMail.pid&#x27;; // 设置运行时参数 protected $options = [ &#x27;worker_num&#x27; =&gt; 4, //worker进程数,一般设置为CPU数的1-4倍 &#x27;daemonize&#x27; =&gt; true, //启用守护进程 &#x27;log_file&#x27; =&gt; &#x27;/data/logs/swoole.log&#x27;, //指定swoole错误日志文件 &#x27;log_level&#x27; =&gt; 0, //日志级别 范围是0-5，0-DEBUG，1-TRACE，2-INFO，3-NOTICE，4-WARNING，5-ERROR &#x27;dispatch_mode&#x27; =&gt; 1, //数据包分发策略,1-轮询模式 &#x27;task_worker_num&#x27; =&gt; 4, //task进程的数量 &#x27;task_ipc_mode&#x27; =&gt; 3, //使用消息队列通信，并设置为争抢模式 //&#x27;heartbeat_idle_time&#x27; =&gt; 600, //一个连接如果600秒内未向服务器发送任何数据，此连接将被强制关闭 //&#x27;heartbeat_check_interval&#x27; =&gt; 60, //启用心跳检测，每隔60s轮循一次 ]; // 邮件服务器配置 protected $mailConfig = [ &#x27;smtp_host&#x27; =&gt; &#x27;smtp.163.com&#x27;, &#x27;username&#x27; =&gt; &#x27;sai0556@163.com&#x27;, &#x27;password&#x27; =&gt; &#x27;xmw1015&#x27;,// SMTP 密码/口令 &#x27;secure&#x27; =&gt; &#x27;ssl&#x27;, //Enable TLS encryption, ssl also accepted &#x27;port&#x27; =&gt; 465, // tcp邮件服务器端口 ]; public function __construct($mailConfig, $options = []) &#123; // 构建Server对象，监听端口 $this-&gt;server = new swoole_server($this-&gt;host, $this-&gt;port); if (!empty($options)) &#123; $this-&gt;options = array_merge($this-&gt;options, $options); &#125; $this-&gt;server-&gt;set($this-&gt;options); $this-&gt;mailConfig = $mailConfig; // 注册事件 $this-&gt;server-&gt;on(&#x27;Start&#x27;, [$this, &#x27;onStart&#x27;]); $this-&gt;server-&gt;on(&#x27;Connect&#x27;, [$this, &#x27;onConnect&#x27;]); $this-&gt;server-&gt;on(&#x27;Receive&#x27;, [$this, &#x27;onReceive&#x27;]); $this-&gt;server-&gt;on(&#x27;Task&#x27;, [$this, &#x27;onTask&#x27;]); $this-&gt;server-&gt;on(&#x27;Finish&#x27;, [$this, &#x27;onFinish&#x27;]); $this-&gt;server-&gt;on(&#x27;Close&#x27;, [$this, &#x27;onClose&#x27;]); // 启动服务 //$this-&gt;server-&gt;start(); &#125; protected function init() &#123; // &#125; public function start() &#123; // Run worker $this-&gt;server-&gt;start(); &#125; public function onStart($server) &#123; // 设置进程名 cli_set_process_title($this-&gt;taskName); //记录进程id,脚本实现自动重启 $pid = &quot;&#123;$server-&gt;master_pid&#125;&#123;$server-&gt;manager_pid&#125;&quot;; file_put_contents($this-&gt;pidPath, $pid); &#125; //监听连接进入事件 public function onConnect($server, $fd, $from_id) &#123; $server-&gt;send($fd, &quot;Hello &#123;$fd&#125;!&quot; ); &#125; // 监听数据接收事件 public function onReceive(swoole_server $server, $fd, $from_id, $data) &#123; $res[&#x27;result&#x27;] = &#x27;success&#x27;; $server-&gt;send($fd, json_encode($res)); // 同步返回消息给客户端 $server-&gt;task($data); // 执行异步任务 &#125; /* @param $server swoole_server swoole_server对象 @param $task_id int 任务id @param $from_id int 投递任务的worker_id @param $data string 投递的数据 / public function onTask(swoole_server $server, $task_id, $from_id, $data) &#123; $res[&#x27;result&#x27;] = &#x27;failed&#x27;; $req = json_decode($data, true); $action = $req[&#x27;action&#x27;]; echo date(&#x27;Y-m-d H:i:s&#x27;).&quot; onTask: [&quot;.$action.&quot;].&quot;; switch ($action) &#123; case &#x27;sendMail&#x27;: //发送单个邮件 $mailData = [ &#x27;emailAddress&#x27; =&gt; $req[&#x27;to&#x27;], //接收方，改成自己的邮箱可以测试接收邮件 &#x27;subject&#x27; =&gt; $req[&#x27;subject&#x27;], &#x27;body&#x27; =&gt; $req[&#x27;body&#x27;], ]; $this-&gt;sendMail($mailData); break; default: break; &#125; &#125; /* @param $server swoole_server swoole_server对象 @param $task_id int 任务id @param $data string 任务返回的数据 */ public function onFinish(swoole_server $server, $task_id, $data) &#123; // &#125; // 监听连接关闭事件 public function onClose($server, $fd, $from_id) &#123; echo &quot;Client &#123;$fd&#125; close connection&quot;; &#125; public function stop() &#123; $this-&gt;server-&gt;stop(); &#125; private function sendMail($mailData = []) &#123; $mail = new PHPMailer(true); try &#123; $mailConfig = $this-&gt;mailConfig; $mail-&gt;isSMTP(); // TCP port to connect to $mail-&gt;Host = $mailConfig[&#x27;smtp_host&#x27;]; // SMTP服务 $mail-&gt;SMTPAuth = true; // Enable SMTP authentication $mail-&gt;Username = $mailConfig[&#x27;username&#x27;]; // SMTP 用户名 $mail-&gt;Password = $mailConfig[&#x27;password&#x27;]; // SMTP 密码/口令 $mail-&gt;SMTPSecure = $mailConfig[&#x27;secure&#x27;]; // Enable TLS encryption, ssl also accepted $mail-&gt;Port = $mailConfig[&#x27;port&#x27;]; // TCP 端口 //Recipients $mail-&gt;setFrom(&#x27;sai0556@163.com&#x27;, &#x27;13sai&#x27;); $mail-&gt;addAddress(&#x27;957042781@qq.com&#x27;); // Name is optional $mail-&gt;addReplyTo(&#x27;957042781@qq.com&#x27;, &#x27;Information&#x27;); //Content $mail-&gt;isHTML(true); // Set email format to HTML $mail-&gt;Subject = &#x27;Here is the subject&#x27;; $mail-&gt;Body = &#x27;This is the HTML message body &lt;b&gt;in bold!&lt;/b&gt;&#x27;; $mail-&gt;AltBody = &#x27;This is the body in plain text for non-HTML mail clients&#x27;; $mail-&gt;send(); echo &#x27;Message has been sent&#x27;; &#125; catch (Exception $e) &#123; echo &#x27;Message could not be sent.&#x27;; echo &#x27;Mailer Error: &#x27; . $mail-&gt;ErrorInfo; &#125; try &#123; $mailConfig = $this-&gt;mailConfig; $mail-&gt;isSMTP(); // Set mailer to use SMTP $mail-&gt;Host = $mailConfig[&#x27;smtp_host&#x27;]; // SMTP服务 $mail-&gt;SMTPAuth = true; // Enable SMTP authentication $mail-&gt;Username = $mailConfig[&#x27;username&#x27;]; // SMTP 用户名 $mail-&gt;Password = $mailConfig[&#x27;password&#x27;]; // SMTP 密码/口令 $mail-&gt;SMTPSecure = $mailConfig[&#x27;secure&#x27;]; // Enable TLS encryption, ssl also accepted $mail-&gt;Port = $mailConfig[&#x27;port&#x27;]; // TCP 端口 $mail-&gt;CharSet = &quot;UTF-8&quot;; //字符集 $mail-&gt;setFrom($mailConfig[&#x27;username&#x27;], &#x27;13sai&#x27;); //发件人地址，名称 $mail-&gt;addAddress($mailData[&#x27;emailAddress&#x27;], &#x27;亲&#x27;); // 收件人地址和名称 //$mail-&gt;addCC(&#x27;hellowebanet@163.com&#x27;); // 抄送 if (isset($mailData[&#x27;attach&#x27;])) &#123; $mail-&gt;addAttachment($mailData[&#x27;attach&#x27;]); // 添加附件 &#125; //$mail-&gt;addAttachment(&#x27;/tmp/image.jpg&#x27;, &#x27;new.jpg&#x27;); // Optional name //Content $mail-&gt;isHTML(true); // Set email format to HTML $mail-&gt;Subject = $mailData[&#x27;subject&#x27;]; $mail-&gt;Body = $mailData[&#x27;body&#x27;]; $mail-&gt;send(); return true; &#125; catch (\\Exception $e) &#123; echo &#x27;Message could not be sent. Mailer Error: &#x27;. $mail-&gt;ErrorInfo; return false; &#125; &#125;&#125; 服务：1234567891011121314151617181920&lt;?php/* Created by PhpStorm. User: 13sai Date: 2018/11/29 Time: 14:09 /require DIR . &#x27;/Mailer.php&#x27;;$config = [ &#x27;smtp_host&#x27; =&gt; &#x27;smtp.163.com&#x27;, &#x27;username&#x27; =&gt; &#x27;sai@163.com&#x27;, &#x27;password&#x27; =&gt; &#x27;&#x27;, &#x27;secure&#x27; =&gt; &#x27;ssl&#x27;, &#x27;port&#x27; =&gt; 465];$server = new Mailer($config);$server-&gt;start(); 发送12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** Created by PhpStorm. User: 13sai Date: 2018/11/29 Time: 14:14 /class Client&#123; private $client; public function __construct() &#123; $this-&gt;client = new swoole_client(SWOOLE_SOCK_TCP); &#125; public function send() &#123; if( !$this-&gt;client-&gt;connect(&quot;127.0.0.1&quot;, 9502 , 1) ) &#123; echo &quot;Error: &#123;$this-&gt;client-&gt;errMsg&#125;[&#123;$this-&gt;client-&gt;errCode&#125;]&quot;; &#125; $action = &#x27;sendMail&#x27;; $time = time(); $data = [ &#x27;action&#x27; =&gt; $action, &#x27;to&#x27; =&gt; &#x27;957042781@qq.com&#x27;, &#x27;subject&#x27; =&gt; &#x27;wow&#x27;, &#x27;body&#x27; =&gt; &#x27;hello, 13sai!&#x27; ]; $msg = json_encode($data); $this-&gt;client-&gt;send( $msg ); $message = $this-&gt;client-&gt;recv(); echo &quot;Get Message From Server:&#123;$message&#125;&quot;; &#125;&#125;$client = new Client();$client-&gt;send(); 测试通过！ 注意： 此处我用了25端口，部署到Linux时上发送邮件发不出去，把PHPMailer的错误说明查了个遍，wrong，端口改为465，使用ssl发送，ok！ 心累。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"swoole","slug":"swoole","permalink":"http://github.13sai.com/tags/swoole/"}]},{"title":"nginx健康检查","slug":"nginx健康检查","date":"2018-10-19T14:21:15.000Z","updated":"2021-04-13T07:33:47.647Z","comments":true,"path":"2018/10/19/170/","link":"","permalink":"http://github.13sai.com/2018/10/19/170/","excerpt":"","text":"面试被问到健康检测，自己不了解，便有了下文。当项目访问量比较大时，我们经常使用nginx做负载均衡。如下：#设定http服务器，利用它的反向代理功能提供负载均衡支持 http&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;#设定mime类型,类型由mime.type文件定义&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/etc/nginx/mime.types;&nbsp;&nbsp;&nbsp;&nbsp;default_type&nbsp;&nbsp;&nbsp;&nbsp;application/octet-stream; &nbsp;&nbsp;&nbsp;&nbsp;#设定日志格式&nbsp;&nbsp;&nbsp;&nbsp;access_log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/var/log/nginx/access.log; &nbsp;&nbsp;&nbsp;&nbsp;#省略上文有的一些配置节点&nbsp;&nbsp;&nbsp;&nbsp;#。。。。。。。。。。 &nbsp;&nbsp;&nbsp;&nbsp;#设定负载均衡的服务器列表&nbsp;&nbsp;&nbsp;&nbsp;upstream&nbsp;sai{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#weigth参数表示权值，权值越高被分配到的几率越大&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;192.168.8.1:3128&nbsp;weight=5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#本机上的Squid开启3128端口,不是必须要squid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;192.168.8.2:80&nbsp;&nbsp;&nbsp;&nbsp;weight=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;192.168.8.3:80&nbsp;&nbsp;&nbsp;&nbsp;weight=6;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#第一个虚拟服务器&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#侦听192.168.8.x的80端口&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;80;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;&nbsp;&nbsp;&nbsp;www.13sai.com; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#对aspx后缀的进行负载均衡请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;~&nbsp;.*.php$&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#定义服务器的默认网站根目录位置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/root;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#定义首页索引文件的名称&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;index.php&nbsp;index.html&nbsp;index.htm;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#请求转向mysvr&nbsp;定义的服务器列表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;&nbsp;&nbsp;&nbsp;http://sai; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#以下是一些反向代理的配置可删除. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_redirect&nbsp;off; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;Host&nbsp;$host;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;X-Real-IP&nbsp;$remote_addr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;X-Forwarded-For&nbsp;$proxy_add_x_forwarded_for; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#允许客户端请求的最大单文件字节数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client_max_body_size&nbsp;10m;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#缓冲区代理缓冲用户端请求的最大字节数，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client_body_buffer_size&nbsp;128k; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#nginx跟后端服务器连接超时时间(代理连接超时)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_connect_timeout&nbsp;90; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#连接成功后，后端服务器响应时间(代理接收超时)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_read_timeout&nbsp;90; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#设置代理服务器（nginx）保存用户头信息的缓冲区大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_buffer_size&nbsp;4k; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_buffers&nbsp;4&nbsp;32k; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#高负荷下缓冲大小（proxy_buffers*2）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_busy_buffers_size&nbsp;64k;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#设定缓存文件夹大小，大于这个值，将从upstream服务器传&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_temp_file_write_size&nbsp;64k;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}}这是nginx中文网上的一个实例（有删改），这样处理分发服务器，我们加入了三台机器，保证了项目的负载量。然而，我们常常忽略另一件事，就是健康检查。（好吧，其实我也忽略了这个问题，面试被问到，一脸懵！！！）何为健康监测？假如我们加入的3台机器中有一台因为其他原因挂掉了，但分发的服务器是不知道的，依旧正常分发请求，必然就导致部分用户访问失败，这是很严重的问题，那么这个时候就需要用到健康检查了。下面我们介绍两种健康检查：被动检查：如果 Nginx 在 10 秒内有 2 个请求发送失败或没有接收到响应，则标记服务器为不可用&nbsp;&nbsp;&nbsp;&nbsp;upstream&nbsp;sai{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;192.168.8.1:3128&nbsp;&nbsp;max_fails=2&nbsp;fail_timeout=10s&nbsp;weight=5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;192.168.8.2:80&nbsp;&nbsp;&nbsp;&nbsp;max_fails=2&nbsp;fail_timeout=10s&nbsp;weight=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;192.168.8.3:80&nbsp;&nbsp;&nbsp;&nbsp;max_fails=2&nbsp;fail_timeout=10s&nbsp;weight=6;&nbsp;&nbsp;&nbsp;&nbsp;}主动检查：需要先开启health_check&nbsp;&nbsp;&nbsp;&nbsp;upstream&nbsp;sai{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zone&nbsp;sai&nbsp;64k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;192.168.8.1:3128&nbsp;&nbsp;max_fails=2&nbsp;fail_timeout=10s&nbsp;weight=5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;192.168.8.2:80&nbsp;&nbsp;&nbsp;&nbsp;max_fails=2&nbsp;fail_timeout=10s&nbsp;weight=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;192.168.8.3:80&nbsp;&nbsp;&nbsp;&nbsp;max_fails=2&nbsp;fail_timeout=10s&nbsp;weight=6;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;~&nbsp;.*.php$&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#其他省略&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;…&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;http://sai;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;health_check&nbsp;interval=10&nbsp;fails=3&nbsp;passes=2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;也可以使用此种，指定特定接口&nbsp;health_check&nbsp;uri=/some/path;&nbsp;&nbsp;&nbsp;&nbsp;}配置起来还是比较简单的。 proxy_next_upstream123456789101112131415161718192021222324# 开启proxy_next_upstream proxy_next_upstream onupstream proxy_web&#123; server 192.168.1.120:7851 weight=2 max_fails=3 fail_timeout=100s; server 192.168.1.121:7851 weight=2 max_fails=3 fail_timeout=100s;&#125;server &#123; listen 80; server_name blog.13sai.com; root /www; index index.html; location /sys &#123; proxy_pass http://proxy_web; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; // 502,404,error自动代理到下一个server proxy_next_upstream http_502 http_504 error timeout invalid_header; &#125;&#125; 如要了解更多可以查看nginx手册：nginx健康监测","categories":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/tags/nginx/"}]},{"title":"小型商城商品模块设计","slug":"小型商城商品模块设计","date":"2018-08-31T10:07:06.000Z","updated":"2021-04-26T03:44:08.662Z","comments":true,"path":"2018/08/31/168/","link":"","permalink":"http://github.13sai.com/2018/08/31/168/","excerpt":"","text":"最近有做到类商城小型项目，主要负责商品模块，便分享下商品模块设计思路。主要分为5个表：商品作为主表，与规格表、属性表、sku表直接关联。ER关系图如下：SQL语句如下：--&nbsp;---------------------------- --&nbsp;Table&nbsp;structure&nbsp;for&nbsp;goods --&nbsp;---------------------------- DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;`goods`; CREATE&nbsp;TABLE&nbsp;`goods`&nbsp;&nbsp;( &nbsp;&nbsp;`id`&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;AUTO_INCREMENT, &nbsp;&nbsp;`mid`&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;店铺id&#39;, &nbsp;&nbsp;`goods_sn`&nbsp;varchar(128)&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NULL&nbsp;DEFAULT&nbsp;NULL&nbsp;COMMENT&nbsp;&#39;商品编码&#39;, &nbsp;&nbsp;`title`&nbsp;varchar(128)&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NOT&nbsp;NULL, &nbsp;&nbsp;`main_pic`&nbsp;varchar(255)&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;&#39;商品主图&#39;, &nbsp;&nbsp;`pics`&nbsp;varchar(1024)&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;&#39;图集&#39;, &nbsp;&nbsp;`cate_id`&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;分类id&#39;, &nbsp;&nbsp;`outer_price`&nbsp;decimal(10,&nbsp;2)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0.00&nbsp;COMMENT&nbsp;&#39;外部价格&nbsp;单位：元&#39;, &nbsp;&nbsp;`inner_price`&nbsp;decimal(10,&nbsp;2)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0.00&nbsp;COMMENT&nbsp;&#39;价格&nbsp;单位：元&#39;, &nbsp;&nbsp;`description`&nbsp;text&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NULL, &nbsp;&nbsp;`is_delete`&nbsp;tinyint(1)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;0&nbsp;正常&nbsp;1&nbsp;删除&#39;, &nbsp;&nbsp;`status`&nbsp;tinyint(2)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;4&nbsp;COMMENT&nbsp;&#39;2审核，3上架，4店铺下架，5平台下架，6拒绝上架&#39;, &nbsp;&nbsp;`create_at`&nbsp;timestamp(0)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;CURRENT_TIMESTAMP&nbsp;COMMENT&nbsp;&#39;添加时间&#39;, &nbsp;&nbsp;`update_at`&nbsp;timestamp(0)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;CURRENT_TIMESTAMP&nbsp;ON&nbsp;UPDATE&nbsp;CURRENT_TIMESTAMP(0)&nbsp;COMMENT&nbsp;&#39;更新时间&#39;, &nbsp;&nbsp;`stock_num`&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;库存&#39;, &nbsp;&nbsp;`sale_num`&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;销量&#39;, &nbsp;&nbsp;`sku_type`&nbsp;tinyint(1)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;2&nbsp;COMMENT&nbsp;&#39;1:&nbsp;单规格&nbsp;2：多规格&#39;, &nbsp;&nbsp;`item_url`&nbsp;varchar(512)&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;&#39;&#39;&nbsp;COMMENT&nbsp;&#39;商品链接&#39;, &nbsp;&nbsp;`sell_out`&nbsp;tinyint(1)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;已卖光&#39;, &nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(`id`)&nbsp;USING&nbsp;BTREE, &nbsp;&nbsp;INDEX&nbsp;`shop_id`(`mid`)&nbsp;USING&nbsp;BTREE, &nbsp;&nbsp;INDEX&nbsp;`cate_id`(`cate_id`)&nbsp;USING&nbsp;BTREE, &nbsp;&nbsp;CONSTRAINT&nbsp;`cate_id`&nbsp;FOREIGN&nbsp;KEY&nbsp;(`cate_id`)&nbsp;REFERENCES&nbsp;`goods_category`&nbsp;(`id`)&nbsp;ON&nbsp;DELETE&nbsp;RESTRICT&nbsp;ON&nbsp;UPDATE&nbsp;RESTRICT )&nbsp;ENGINE&nbsp;=&nbsp;InnoDB&nbsp;AUTO_INCREMENT&nbsp;=&nbsp;1&nbsp;CHARACTER&nbsp;SET&nbsp;=&nbsp;utf8&nbsp;COLLATE&nbsp;=&nbsp;utf8_general_ci&nbsp;COMMENT&nbsp;=&nbsp;&#39;商品表&#39;&nbsp;ROW_FORMAT&nbsp;=&nbsp;Dynamic; –&nbsp;—————————-–&nbsp;Table&nbsp;structure&nbsp;for&nbsp;goods_attr_key–&nbsp;—————————-DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;goods_attr_key;CREATE&nbsp;TABLE&nbsp;goods_attr_key&nbsp;&nbsp;(&nbsp;&nbsp;id&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;AUTO_INCREMENT,&nbsp;&nbsp;goods_id&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;商品id&#39;,&nbsp;&nbsp;attr&nbsp;varchar(50)&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NOT&nbsp;NULL,&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(id)&nbsp;USING&nbsp;BTREE,&nbsp;&nbsp;INDEX&nbsp;goods_id(goods_id)&nbsp;USING&nbsp;BTREE,&nbsp;&nbsp;CONSTRAINT&nbsp;goods_id&nbsp;FOREIGN&nbsp;KEY&nbsp;(goods_id)&nbsp;REFERENCES&nbsp;goods&nbsp;(id)&nbsp;ON&nbsp;DELETE&nbsp;RESTRICT&nbsp;ON&nbsp;UPDATE&nbsp;RESTRICT)&nbsp;ENGINE&nbsp;=&nbsp;InnoDB&nbsp;AUTO_INCREMENT&nbsp;=&nbsp;1&nbsp;CHARACTER&nbsp;SET&nbsp;=&nbsp;utf8&nbsp;COLLATE&nbsp;=&nbsp;utf8_general_ci&nbsp;COMMENT&nbsp;=&nbsp;&#39;商品规格&#39;&nbsp;ROW_FORMAT&nbsp;=&nbsp;Dynamic; –&nbsp;—————————-–&nbsp;Table&nbsp;structure&nbsp;for&nbsp;goods_attr_value–&nbsp;—————————-DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;goods_attr_value;CREATE&nbsp;TABLE&nbsp;goods_attr_value&nbsp;&nbsp;(&nbsp;&nbsp;id&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;AUTO_INCREMENT,&nbsp;&nbsp;attr_id&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;&#39;属性项目id&#39;,&nbsp;&nbsp;attr_name&nbsp;varchar(50)&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NOT&nbsp;NULL,&nbsp;&nbsp;goods_id&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;商品id&#39;,&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(id)&nbsp;USING&nbsp;BTREE,&nbsp;&nbsp;INDEX&nbsp;goods_id(goods_id)&nbsp;USING&nbsp;BTREE,&nbsp;&nbsp;INDEX&nbsp;attr_id(attr_id)&nbsp;USING&nbsp;BTREE,&nbsp;&nbsp;CONSTRAINT&nbsp;val_goods_id&nbsp;FOREIGN&nbsp;KEY&nbsp;(goods_id)&nbsp;REFERENCES&nbsp;goods&nbsp;(id)&nbsp;ON&nbsp;DELETE&nbsp;RESTRICT&nbsp;ON&nbsp;UPDATE&nbsp;RESTRICT,&nbsp;&nbsp;CONSTRAINT&nbsp;attr_id&nbsp;FOREIGN&nbsp;KEY&nbsp;(attr_id)&nbsp;REFERENCES&nbsp;goods_attr_key&nbsp;(id)&nbsp;ON&nbsp;DELETE&nbsp;RESTRICT&nbsp;ON&nbsp;UPDATE&nbsp;RESTRICT)&nbsp;ENGINE&nbsp;=&nbsp;InnoDB&nbsp;AUTO_INCREMENT&nbsp;=&nbsp;1&nbsp;CHARACTER&nbsp;SET&nbsp;=&nbsp;utf8&nbsp;COLLATE&nbsp;=&nbsp;utf8_general_ci&nbsp;COMMENT&nbsp;=&nbsp;&#39;商品属性&#39;&nbsp;ROW_FORMAT&nbsp;=&nbsp;Dynamic; –&nbsp;—————————-–&nbsp;Table&nbsp;structure&nbsp;for&nbsp;goods_category–&nbsp;—————————-DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;goods_category;CREATE&nbsp;TABLE&nbsp;goods_category&nbsp;&nbsp;(&nbsp;&nbsp;id&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;AUTO_INCREMENT,&nbsp;&nbsp;parent_id&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;父级id&#39;,&nbsp;&nbsp;cate_name&nbsp;varchar(128)&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;&#39;分类名称&#39;,&nbsp;&nbsp;sort&nbsp;tinyint(4)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;排序&#39;,&nbsp;&nbsp;create_at&nbsp;timestamp(0)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;CURRENT_TIMESTAMP&nbsp;COMMENT&nbsp;&#39;创建时间&#39;,&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(id)&nbsp;USING&nbsp;BTREE)&nbsp;ENGINE&nbsp;=&nbsp;InnoDB&nbsp;AUTO_INCREMENT&nbsp;=&nbsp;1&nbsp;CHARACTER&nbsp;SET&nbsp;=&nbsp;utf8&nbsp;COLLATE&nbsp;=&nbsp;utf8_general_ci&nbsp;COMMENT&nbsp;=&nbsp;&#39;商品分类&#39;&nbsp;ROW_FORMAT&nbsp;=&nbsp;Dynamic; –&nbsp;—————————-–&nbsp;Table&nbsp;structure&nbsp;for&nbsp;goods_sku–&nbsp;—————————-DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;goods_sku;CREATE&nbsp;TABLE&nbsp;goods_sku&nbsp;&nbsp;(&nbsp;&nbsp;id&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;AUTO_INCREMENT,&nbsp;&nbsp;goods_id&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;商品id&#39;,&nbsp;&nbsp;mid&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;店铺id&#39;,&nbsp;&nbsp;attr_ids&nbsp;varchar(512)&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;&#39;&#39;&nbsp;COMMENT&nbsp;&#39;规格集合&#39;,&nbsp;&nbsp;attr_names&nbsp;varchar(512)&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;&#39;&#39;&nbsp;COMMENT&nbsp;&#39;属性集合&#39;,&nbsp;&nbsp;goods_sku_sn&nbsp;varchar(64)&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;&#39;商品sku编码&#39;,&nbsp;&nbsp;outer_price&nbsp;decimal(10,&nbsp;2)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0.00&nbsp;COMMENT&nbsp;&#39;外部价格&nbsp;单位：元&#39;,&nbsp;&nbsp;inner_price&nbsp;decimal(10,&nbsp;2)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0.00&nbsp;COMMENT&nbsp;&#39;价格&nbsp;单位：元&#39;,&nbsp;&nbsp;stock_num&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;可用库存&#39;,&nbsp;&nbsp;dj_stock_num&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;冻结库存&#39;,&nbsp;&nbsp;sale_num&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;0&nbsp;COMMENT&nbsp;&#39;销量&#39;,&nbsp;&nbsp;create_at&nbsp;timestamp(0)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;CURRENT_TIMESTAMP&nbsp;COMMENT&nbsp;&#39;添加时间&#39;,&nbsp;&nbsp;update_at&nbsp;timestamp(0)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;CURRENT_TIMESTAMP&nbsp;ON&nbsp;UPDATE&nbsp;CURRENT_TIMESTAMP(0)&nbsp;COMMENT&nbsp;&#39;更新时间&#39;,&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(id)&nbsp;USING&nbsp;BTREE,&nbsp;&nbsp;INDEX&nbsp;goods_id(goods_id)&nbsp;USING&nbsp;BTREE,&nbsp;&nbsp;CONSTRAINT&nbsp;goods_id_sku&nbsp;FOREIGN&nbsp;KEY&nbsp;(goods_id)&nbsp;REFERENCES&nbsp;goods&nbsp;(id)&nbsp;ON&nbsp;DELETE&nbsp;RESTRICT&nbsp;ON&nbsp;UPDATE&nbsp;RESTRICT)&nbsp;ENGINE&nbsp;=&nbsp;InnoDB&nbsp;AUTO_INCREMENT&nbsp;=&nbsp;1&nbsp;CHARACTER&nbsp;SET&nbsp;=&nbsp;utf8&nbsp;COLLATE&nbsp;=&nbsp;utf8_general_ci&nbsp;COMMENT&nbsp;=&nbsp;&#39;商品sku&#39;&nbsp;ROW_FORMAT&nbsp;=&nbsp;Dynamic;字段都有备注，就不一样说明了。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"事务隔离级别","slug":"事务隔离级别","date":"2018-08-12T07:53:46.000Z","updated":"2021-04-13T07:27:23.276Z","comments":true,"path":"2018/08/12/167/","link":"","permalink":"http://github.13sai.com/2018/08/12/167/","excerpt":"","text":"mysql中定义了4中隔离级别，分别是READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE。下面表格列出了可能出现的问题，Y表示可能出现，N表示几乎不可能出现。事务隔离级别脏读不可重复读幻读未提交读（read-uncommitted）YYY不可重复读（read-committed）NYY可重复读（repeatable-read）NNY串行化（serializable）NNN&nbsp;脏读：(针对未提交的数据)A事务在更新一条记录，未提交前，B事务读到了A事务更新后的记录，那么B事务就读到了脏数据，会产生对A未提交数据的依赖。一旦A事务回滚，那么B事务读到的数据，将是错误的脏数据。不可重复读：（读取数据本身的对比）A事务在读取某些数据后的一段时间后，再次读取这个数据，发现其读取出来的数据内容已经发生了改变，就是不可重复读。幻读：（读取结果集条数的对比）A事务按相同的查询条件查询之前检索过的数据，确发现检索出来的结果集条数变多或者减少（由其他事务插入、删除的），类似产生幻觉。事务的基本要素（ACID）:1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。&nbsp;&nbsp;更多可查看mysql手册：事务隔离级别&nbsp;","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"基于redis的秒杀","slug":"基于redis的秒杀","date":"2018-08-09T14:43:58.000Z","updated":"2019-11-27T10:16:38.312Z","comments":true,"path":"2018/08/09/165/","link":"","permalink":"http://github.13sai.com/2018/08/09/165/","excerpt":"","text":"随着电商业务的发展，秒杀是个十分常见的场景，今天我们来利用redis实现一个简单的秒杀系统。 假定我们有一个商品id为1，秒杀数量是5。 一般场景： 1234567891011121314151617181920include &#x27;db.php&#x27;;$db = new db([ &#x27;database_type&#x27; =&gt; &#x27;mysql&#x27;, &#x27;database_name&#x27; =&gt; &#x27;test&#x27;, &#x27;server&#x27; =&gt; &#x27;www.13sai.com&#x27;, &#x27;username&#x27; =&gt; &#x27;13sai&#x27;, &#x27;password&#x27; =&gt; &#x27;*&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;]);$stock_num= $db-&gt;get(&#x27;goods&#x27;, &#x27;stock_num&#x27;, [&#x27;id&#x27; =&gt; 1]);// 检测库存if ($stock_num&gt; 0) &#123; sleep(1); //模拟真实环境 $db-&gt;update(&#x27;goods&#x27;, [&quot;stock_num[-]&quot; =&gt; 1], [&#x27;id&#x27; =&gt; 1]); print_r(&#x27;ok&#x27;)&#125; else &#123; print_r(&#x27;sorry&#x27;)&#125; 我们尝试模拟高并发场景，使用ab压测工具， ab -n 500 -c 500 http://www.13sai.com/test/miaosha.php 运行后发现库存stock_num很可能已经变成负数了，出现了超卖问题。 引入redis 12345678910111213141516171819202122232425262728293031//实例化redis$redis = new Redis();//连接$redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379);$key = &#x27;sale&#x27;;//检测是否连接成功// echo &quot;Server is running: &quot; . $redis-&gt;ping();$redis-&gt;setnx($key, 0);$redis-&gt;watch($key); //监测一个key的值是否被更改$sale_num = $redis-&gt;get($key);if ($sale_num &gt; 4) &#123; exit();&#125;$redis-&gt;multi(); //标记事务$redis-&gt;incr($key); //销量+1sleep(1); //模拟真实环境$ret = $redis-&gt;exec(); // 事务块内所有命令的返回值，按命令执行的先后顺序排列。if ($ret) &#123; include &#x27;db.php&#x27;; $db = new db([ &#x27;database_type&#x27; =&gt; &#x27;mysql&#x27;, &#x27;database_name&#x27; =&gt; &#x27;test&#x27;, &#x27;server&#x27; =&gt; &#x27;www.13sai.com&amp;#39;, &#x27;username&#x27; =&gt; &#x27;13sai&#x27;, &#x27;password&#x27; =&gt; &#x27;*&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27; ]); $db-&gt;update(&#x27;goods&#x27;, [&quot;stock_num[-]&quot; =&gt; 1], [&#x27;id&#x27; =&gt; 1]);&#125; 重新增加库存到5，多次测试，发现库存并无出现负数情况，测试通过。","categories":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"}]},{"title":"LNMP环境搭建","slug":"LNMP环境搭建","date":"2018-07-29T12:45:43.000Z","updated":"2021-04-13T07:32:41.912Z","comments":true,"path":"2018/07/29/164/","link":"","permalink":"http://github.13sai.com/2018/07/29/164/","excerpt":"","text":"最近公司有新项目上线，新买了服务器，便需要搭建环境，便实操了一下。 lnmp包装lnmp的安装时比较轻松的，一行代码， 1wget http://soft.vpser.net/lnmp/lnmp1.5.tar.gz -cO lnmp1.5.tar.gz &amp;&amp; tar zxf lnmp1.5.tar.gz &amp;&amp; cd lnmp1.5 &amp;&amp; ./install.sh lnmp 然后会提示你选择的nginx版本，输入mysql密码，php版本，选择之后坐等安装，大概需要半个小时。 如果显示Nginx: OK，MySQL: OK，PHP: OK。就表示安装成功了。 扩展安装（以redis扩展为例）12345wget https://codeload.github.com/phpredis/phpredis/zip/develop -O phpredis.zipunzip phpredis.zipcd /phpredis-develop/usr/local/php/bin/phpize./configure --with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make install //编译安装 在php.ini中加入 1extension=redis.so 重启php-fpm，通过php -m命令查看 最近公司有新项目上线，新买了服务器，便需要搭建环境，便实操了一下。lnmp包装lnmp的安装时比较轻松的，一行代码，wget&nbsp;http://soft.vpser.net/lnmp/lnmp1.5.tar.gz&nbsp;-cO&nbsp;lnmp1.5.tar.gz&nbsp;&amp;&amp;&nbsp;tar&nbsp;zxf&nbsp;lnmp1.5.tar.gz&nbsp;&amp;&amp;&nbsp;cd&nbsp;lnmp1.5&nbsp;&amp;&amp;&nbsp;./install.sh&nbsp;lnmp然后会提示你选择的nginx版本，输入mysql密码，php版本，选择之后坐等安装，大概需要半个小时。如果显示Nginx: OK，MySQL: OK，PHP: OK。就表示安装成功了。2. 扩展安装（以redis扩展为例）wget&nbsp;https://codeload.github.com/phpredis/phpredis/zip/develop&nbsp;-O&nbsp;phpredis.zip unzip&nbsp;phpredis.zip cd&nbsp;/phpredis-develop /usr/local/php/bin/phpize./configure&nbsp;--with-php-config=/usr/local/php/bin/php-config make&nbsp;&amp;&amp;&nbsp;make&nbsp;install&nbsp;&nbsp;&nbsp;//编译安装在php.ini中加入extension=redis.so重启php-fpm，通过php -m命令查看。","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"LNMP","slug":"LNMP","permalink":"http://github.13sai.com/tags/LNMP/"}]},{"title":"两个关于Linux的问题","slug":"两个关于Linux的问题","date":"2018-07-06T12:57:18.000Z","updated":"2020-12-09T10:35:16.357Z","comments":true,"path":"2018/07/06/163/","link":"","permalink":"http://github.13sai.com/2018/07/06/163/","excerpt":"","text":"最近有点忙，一会下班，也不想敲代码了，写写前段时间遇到的两个关于Linux的问题。虽然两个问题都是同事解决的，但有必要分享一下。 OOM OOM killer（Out-Of-Memory killer），该机制会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程，为了防止内存耗尽而内核会把该进程杀掉。 起因：导出相当大的数据时导致内存溢出的问题，服务器负载很大，然后OOM这个进程每次就把我导出的进程干趴下了。 文件最大打开数12ulimit -n //查看文件最大打开数lsof |wc -l //当前文件打开数量 起因：守护进程里有个程序，一直在fopen，导致文件打开数过大，服务器挂掉了。 解决方案比较简单，就不赘述了。","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"}]},{"title":"几个实用的sql","slug":"几个实用的sql","date":"2018-06-18T10:47:50.000Z","updated":"2021-04-13T07:21:31.587Z","comments":true,"path":"2018/06/18/162/","link":"","permalink":"http://github.13sai.com/2018/06/18/162/","excerpt":"","text":"查看当前所有的数据库和索引大小12345select table_schema, concat(truncate(sum(data_length)/1024/1024,2),&#x27; mb&#x27;) as data_size,concat(truncate(sum(index_length)/1024/1024,2),&#x27;mb&#x27;) as index_sizefrom information_schema.tablesgroup by table_schemaorder by data_length desc; 查看当前某个数据库和数据库下所有的表的大小12345select table_name, concat(truncate(data_length/1024/1024,2),&#x27; mb&#x27;) as data_size,concat(truncate(index_length/1024/1024,2),&#x27; mb&#x27;) as index_sizefrom information_schema.tables where table_schema = &#x27;mysql&#x27;group by table_nameorder by data_length desc; 查看mysql连接数1show full processlist; 按月统计1select sum(money),LEFT(created_at, 7) from sale GROUP BY LEFT(created_at, 7);","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"PHP两个好用的函数处理函数","slug":"PHP两个好用的函数处理函数","date":"2018-06-13T07:36:49.000Z","updated":"2021-04-13T07:37:14.399Z","comments":true,"path":"2018/06/13/161/","link":"","permalink":"http://github.13sai.com/2018/06/13/161/","excerpt":"","text":"call_user_func — 把第一个参数作为回调函数调用demo: function&nbsp;increment($var){&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;hello&nbsp;&#39;.$var;}$a&nbsp;=&nbsp;&#39;13sai&#39;;call_user_func(&#39;increment&#39;,&nbsp;$a); class&nbsp;A{&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;increment($var)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;hello&nbsp;&#39;.$var;&nbsp;&nbsp;&nbsp;&nbsp;}} $a&nbsp;=&nbsp;&#39;world&#39;;call_user_func([(new&nbsp;A()),&nbsp;&#39;increment&#39;],&nbsp;$a);call_user_func_array — 调用回调函数，并把一个数组参数作为回调函数的参数&lt;?phpfunction&nbsp;foobar($arg,&nbsp;$arg2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;FUNCTION,&nbsp;&quot;&nbsp;got&nbsp;$arg&nbsp;and&nbsp;$arg2&quot;;}class&nbsp;foo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;bar($arg,&nbsp;$arg2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;METHOD,&nbsp;&quot;&nbsp;got&nbsp;$arg&nbsp;and&nbsp;$arg2&quot;;&nbsp;&nbsp;&nbsp;&nbsp;}} //&nbsp;Call&nbsp;the&nbsp;foobar()&nbsp;function&nbsp;with&nbsp;2&nbsp;argumentscall_user_func_array(&quot;foobar&quot;,&nbsp;array(&quot;one&quot;,&nbsp;&quot;two&quot;)); //&nbsp;Call&nbsp;the&nbsp;$foo-&gt;bar()&nbsp;method&nbsp;with&nbsp;2&nbsp;arguments$foo&nbsp;=&nbsp;new&nbsp;foo;call_user_func_array(array($foo,&nbsp;&quot;bar&quot;),&nbsp;array(&quot;three&quot;,&nbsp;&quot;four&quot;));说到这里，可以看看可变参数函数(5.6+)&lt;?phpfunction&nbsp;sum(...$numbers)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;$acc&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;($numbers&nbsp;as&nbsp;$n)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$acc&nbsp;+=&nbsp;$n;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$acc;} echo&nbsp;sum(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5);重点来了，当可变参数长度函数遇上call_user_func_array试想，我们希望传入不定长度参数，而参数又只是数组。那么你可以这么做：function&nbsp;sum(...$numbers)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;$acc&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;($numbers&nbsp;as&nbsp;$n)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$acc&nbsp;+=&nbsp;$n;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$acc;} print_r(call_user_func_array(&quot;sum&quot;,&nbsp;[7,8,9,10]));好了，that&#39;s all!","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"关于大表查询最后几页过慢的原因","slug":"关于大表查询最后几页过慢的原因","date":"2018-05-31T04:09:16.000Z","updated":"2021-04-26T03:41:27.682Z","comments":true,"path":"2018/05/31/157/","link":"","permalink":"http://github.13sai.com/2018/05/31/157/","excerpt":"","text":"mysql数据量很大使用limit查询最后几页很慢，你知道原因么？ 我们不妨先来看看几条查询语句与结果。 123select * from test_user where id&gt;9900000 limit 0,10;select * from test_user limit 9900000,10;select * from test_user where id in (select b.id from (select id from test_user where id&gt;9900000 limit 0,10) as b); //子查询 123456789101112131415[SQL]select * from test_user where id&gt;9900000 limit 0,10;受影响的行: 0时间: 0.019s[SQL]select * from test_user limit 9900000,10;受影响的行: 0时间: 1.147s[SQL]select * from test_user where id in (select b.id from (select id from test_user where id&gt;9900000 limit 0,10) as b);受影响的行: 0时间: 0.001s 其实，原因就在于： limit10000,20的意思扫描满足条件的10020行，扔掉前面的10000行，返回最后的20行，问题就在这里。 解决方案： 过一半数据采用倒序查询 运用子查询","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"ArrayAccess（数组式访问）接口","slug":"ArrayAccess（数组式访问）接口","date":"2018-05-09T08:52:23.000Z","updated":"2021-04-13T07:29:15.408Z","comments":true,"path":"2018/05/09/154/","link":"","permalink":"http://github.13sai.com/2018/05/09/154/","excerpt":"","text":"ArrayAccess提供像访问数组一样访问对象的能力的接口。具体有一下几个方法：ArrayAccess&nbsp;{ /*&nbsp;方法&nbsp;*/ abstract&nbsp;public&nbsp;boolean&nbsp;offsetExists&nbsp;(&nbsp;mixed&nbsp;$offset&nbsp;) abstract&nbsp;public&nbsp;mixed&nbsp;offsetGet&nbsp;(&nbsp;mixed&nbsp;$offset&nbsp;) abstract&nbsp;public&nbsp;void&nbsp;offsetSet&nbsp;(&nbsp;mixed&nbsp;$offset&nbsp;,&nbsp;mixed&nbsp;$value&nbsp;) abstract&nbsp;public&nbsp;void&nbsp;offsetUnset&nbsp;(&nbsp;mixed&nbsp;$offset&nbsp;) }文档看手册&nbsp;ArrayAccess（数组式访问）接口调用情况看实例：&lt;?php /** &nbsp;*&nbsp;@author&nbsp;13sai &nbsp;*/ class&nbsp;TestAccess&nbsp;implements&nbsp;ArrayAccess&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;$data&nbsp;=&nbsp;[]; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;__get($key)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_r(__METHOD__); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$this-&gt;data[$key]; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;__set($key,$value)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_r(__METHOD__); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;data[$key]&nbsp;=&nbsp;$value; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;__isset($key)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_r(__METHOD__); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;isset($this-&gt;data[$key]); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;__unset($key)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_r(__METHOD__); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unset($this-&gt;data[$key]); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;offsetSet($offset,$value)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_r(METHOD);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(is_null($offset))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;data[]&nbsp;=&nbsp;$value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;data[$offset]&nbsp;=&nbsp;$value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;offsetGet($offset)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_r(METHOD);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$this-&gt;offsetExists($offset)&nbsp;?&nbsp;$this-&gt;data[$offset]&nbsp;:&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;offsetExists($offset)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_r(METHOD);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;isset($this-&gt;data[$offset]);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;offsetUnset($offset)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_r(METHOD);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($this-&gt;offsetExists($offset))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unset($this-&gt;data[$offset]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;} } $animal&nbsp;=&nbsp;new&nbsp;TestAccess();echo(&#39;&lt;br&gt;1.&#39;);var_dump(empty($animal-&gt;dog)); echo(&#39;&lt;br&gt;2.&#39;);var_dump(empty($animal[&#39;pig&#39;])); echo(&#39;&lt;br&gt;3.&#39;);$animal-&gt;dog&nbsp;=&nbsp;&#39;dog&#39;; echo(&#39;&lt;br&gt;4.&#39;);$animal[&#39;pig&#39;]&nbsp;=&nbsp;&#39;pig&#39;; echo(&#39;&lt;br&gt;13.&#39;);var_dump(empty($animal-&gt;dog)); echo(&#39;&lt;br&gt;14.&#39;);var_dump(empty($animal[&#39;pig&#39;])); echo(&#39;&lt;br&gt;5.&#39;);var_dump(isset($animal-&gt;dog)); echo(&#39;&lt;br&gt;6.&#39;);var_dump(isset($animal[&#39;pig&#39;])); echo(&#39;&lt;br&gt;7.&#39;);var_dump($animal-&gt;pig); echo(&#39;&lt;br&gt;8.&#39;);var_dump($animal[&#39;dog&#39;]); echo(&#39;&lt;br&gt;9.&#39;);unset($animal[&#39;dog&#39;]); echo(&#39;&lt;br&gt;10.&#39;);unset($animal-&gt;pig); echo(&#39;&lt;br&gt;11.&#39;);var_dump($animal[&#39;pig&#39;]); echo(&#39;&lt;br&gt;12.&#39;);var_dump($animal-&gt;dog);输出调用可运行，一看便知！1.TestAccess::__issetD:\\project est\u0007ccess.php:126:boolean&nbsp;true 2.TestAccess::offsetExistsD:\\project est\u0007ccess.php:129:boolean&nbsp;true 3.TestAccess::__set4.TestAccess::offsetSet13.TestAccess::__issetTestAccess::__getD:\\project est\u0007ccess.php:139:boolean&nbsp;false 14.TestAccess::offsetExistsTestAccess::offsetGetTestAccess::offsetExistsD:\\project est\u0007ccess.php:142:boolean&nbsp;false 5.TestAccess::__issetD:\\project est\u0007ccess.php:145:boolean&nbsp;true 6.TestAccess::offsetExistsD:\\project est\u0007ccess.php:148:boolean&nbsp;true 7.TestAccess::__getD:\\project est\u0007ccess.php:151:string&nbsp;&#39;pig&#39;&nbsp;(length=3) 8.TestAccess::offsetGetTestAccess::offsetExistsD:\\project est\u0007ccess.php:154:string&nbsp;&#39;dog&#39;&nbsp;(length=3) 9.TestAccess::offsetUnsetTestAccess::offsetExists10.TestAccess::__unset11.TestAccess::offsetGetTestAccess::offsetExistsD:\\project est\u0007ccess.php:163:null 12.TestAccess::__get(&nbsp;!&nbsp;)&nbsp;Notice:&nbsp;Undefined&nbsp;index:&nbsp;dog&nbsp;in&nbsp;D:\\project est\u0007ccess.php&nbsp;on&nbsp;line&nbsp;26Call&nbsp;Stack Time Memory Function Location1 0.2010 384480 {main}(&nbsp;) …\u0007ccess.php:02 0.2010 385368 TestAccess-&gt;__get(&nbsp;string(3)&nbsp;) …\u0007ccess.php:166&nbsp;D:\\project est\u0007ccess.php:166:null","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"git解决总要输入密码的问题","slug":"git解决总要输入密码的问题","date":"2018-05-09T06:56:28.000Z","updated":"2020-12-09T10:42:41.181Z","comments":true,"path":"2018/05/09/153/","link":"","permalink":"http://github.13sai.com/2018/05/09/153/","excerpt":"","text":"之前每次pull和push总要输入密码，繁琐。操作两步，解决问题！生成公钥cd&nbsp;~/.ssh ssh-keygen&nbsp;-t&nbsp;rsa&nbsp;-C&nbsp;&quot;注释&quot;拷贝公钥到远程主机ssh-copy-id&nbsp;git@xxx.comok！","categories":[{"name":"ci","slug":"ci","permalink":"http://github.13sai.com/categories/ci/"}],"tags":[{"name":"git","slug":"git","permalink":"http://github.13sai.com/tags/git/"}]},{"title":"mysql触发器","slug":"mysql触发器","date":"2018-04-18T05:40:41.000Z","updated":"2021-04-13T07:32:56.730Z","comments":true,"path":"2018/04/18/152/","link":"","permalink":"http://github.13sai.com/2018/04/18/152/","excerpt":"","text":"去年年底做新功能时考虑使用触发器，来聊聊触发器。触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性。实例代码如下：DELIMITER&nbsp;;;&nbsp;&nbsp;//&nbsp;定义结束符 CREATE&nbsp;TRIGGER&nbsp;`updateData`&nbsp;AFTER&nbsp;UPDATE&nbsp;ON&nbsp;`buyer`&nbsp;FOR&nbsp;EACH&nbsp;ROW&nbsp;begin set&nbsp;@phone&nbsp;=&nbsp;right(new.phone,11);&nbsp;//&nbsp;取手机号 set&nbsp;@main_id&nbsp;=&nbsp;(select&nbsp;id&nbsp;from&nbsp;main&nbsp;where&nbsp;u_id&nbsp;=&nbsp;new.u_id);&nbsp;//&nbsp;从表main取id set&amp;nbsp;@new_last_trade_time&amp;nbsp;=&amp;nbsp;IF(&amp;nbsp;UNIX_TIMESTAMP(new.last_trade_time)&amp;nbsp;&amp;gt;&amp;nbsp;@old_last_trade_time,&amp;nbsp;UNIX_TIMESTAMP(new.last_trade_time),&amp;nbsp;@old_last_trade_time); set&amp;nbsp;@add_trade_count&amp;nbsp;=&amp;nbsp;(new.trade_count&amp;nbsp;-&amp;nbsp;old.trade_count); set&amp;nbsp;@add_trade_amount&amp;nbsp;=&amp;nbsp;(new.trade_amount&amp;nbsp;-&amp;nbsp;old.trade_amount); //&amp;nbsp;更新操作 update&amp;nbsp;member&amp;nbsp;set&amp;nbsp; trade_count=trade_count+@add_trade_count, trade_amount=trade_amount+@add_trade_amount, last_trade_time=@new_last_trade_time&amp;nbsp;&amp;nbsp; where&amp;nbsp;main_id&amp;nbsp;=&amp;nbsp;@main_id&amp;nbsp;and&amp;nbsp;phone&amp;nbsp;=&amp;nbsp;@phone; end;;DELIMITER&nbsp;;性能问题：通过测试，若我每秒钟向数据库中插入700条左右的告警信息，此时若使用触发器，每秒中只会插入数据库中50左右，若不开启触发器，那么700条全部可以插入数据库中。（来自网络）","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"php的redis操作","slug":"php的redis操作","date":"2018-03-22T03:37:19.000Z","updated":"2021-04-13T07:37:21.750Z","comments":true,"path":"2018/03/22/151/","link":"","permalink":"http://github.13sai.com/2018/03/22/151/","excerpt":"","text":"1. 连接redis&lt;?php&nbsp; &nbsp;&nbsp;&nbsp;$redis&nbsp;=&nbsp;new&nbsp;Redis();&nbsp; &nbsp;&nbsp;&nbsp;$redis-&gt;connect(&#39;127.0.0.1&#39;,&nbsp;6379);&nbsp; &nbsp;&nbsp;&nbsp;echo&nbsp;&quot;Connection&nbsp;to&nbsp;server&nbsp;sucessfully&quot;;&nbsp; &nbsp;&nbsp;&nbsp;echo&nbsp;&quot;Server&nbsp;is&nbsp;running:&nbsp;&quot;.$redis-&gt;ping();&nbsp; ?&gt;2. String 类型操作$redis-&gt;set(&#39;key&#39;,&#39;TK&#39;); $redis-&gt;set(&#39;number&#39;,&#39;1&#39;); $redis-&gt;setex(&#39;key&#39;,5,&#39;TK&#39;);&nbsp;//设置有效期为5秒的键值 $redis-&gt;psetex(&#39;key&#39;,5000,&#39;TK&#39;);&nbsp;//设置有效期为5000毫秒(同5秒)的键值 $redis-&gt;setnx(&#39;key&#39;,&#39;XK&#39;);&nbsp;//若键值存在返回false&nbsp;不存在返回true $redis-&gt;delete(&#39;key&#39;);&nbsp;删除键值&nbsp;可以传入数组&nbsp;array(&#39;key1&#39;,&#39;key2&#39;)删除多个键 $redis-&gt;getSet(&#39;key&#39;,&#39;XK&#39;);&nbsp;//将键key的值设置为XK，&nbsp;并返回这个键值原来的值TK $ret&nbsp;=&nbsp;$redis-&gt;multi()&nbsp;&nbsp;//批量事务处理,不保证处理数据的原子性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;set(&#39;key1&#39;,&nbsp;&#39;val1&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;get(&#39;key1&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;setnx(&#39;key&#39;,&nbsp;&#39;val2&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;get(&#39;key2&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;exec();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$redis-&gt;watch(&#39;key&#39;);&nbsp;&nbsp;&nbsp;//&nbsp;监控键key&nbsp;是否被其他客户端修改&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果KEY在调用watch()和exec()之间被修改，exec失败&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $redis-&gt;subscribe(array(&#39;chan-1&#39;,&nbsp;&#39;chan-2&#39;,&nbsp;&#39;chan-3&#39;),&nbsp;&#39;f&#39;);&nbsp;//&nbsp;subscribe&nbsp;to&nbsp;3&nbsp;chans $redis-&gt;publish(&#39;chan-1&#39;,&nbsp;&#39;hello,&nbsp;world!&#39;);&nbsp;//&nbsp;send&nbsp;message.&nbsp;$redis-&gt;exists(&#39;key&#39;);&nbsp;//验证键是否存在，存在返回true$redis-&gt;incr(&#39;number&#39;);&nbsp;//键值加1$redis-&gt;incrby(&#39;number&#39;,-10);&nbsp;//键值加减10$redis-&gt;incrByFloat(&#39;number&#39;,&nbsp;+/-&nbsp;1.5);&nbsp;//键值加减小数$redis-&gt;decr(&#39;number&#39;);&nbsp;//&nbsp;键值减1$redis-&gt;decrBy(&#39;number&#39;,10);&nbsp;//&nbsp;键值减10$mget&nbsp;=&nbsp;$redis-&gt;mget(array(&#39;number&#39;,&#39;key&#39;));&nbsp;//&nbsp;批量获取键值,返回一个数组$redis-&gt;mset(array(&#39;key0&#39;&nbsp;=&gt;&nbsp;&#39;value0&#39;,&nbsp;&#39;key1&#39;&nbsp;=&gt;&nbsp;&#39;value1&#39;));&nbsp;//&nbsp;批量设置键值$redis-&gt;msetnx(array(&#39;key0&#39;&nbsp;=&gt;&nbsp;&#39;value0&#39;,&nbsp;&#39;key1&#39;&nbsp;=&gt;&nbsp;&#39;value1&#39;));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;批量设置键值，类似将setnx()方法批量操作$redis-&gt;append(&#39;key&#39;,&nbsp;&#39;-Smudge&#39;);&nbsp;//原键值TK，将值追加到键值后面，键值为TK-Smudge$redis-&gt;getRange(&#39;key&#39;,&nbsp;0,&nbsp;5);&nbsp;//&nbsp;键值截取从0位置开始到5位置结束$redis-&gt;getRange(&#39;key&#39;,&nbsp;-6,&nbsp;-1);&nbsp;//&nbsp;字符串截取从-6(倒数第6位置)开始到-1(倒数第1位置)结束$redis-&gt;setRange(&#39;key&#39;,&nbsp;0,&nbsp;&#39;Smudge&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;键值中替换字符串，0表示从0位置开始,&nbsp;&nbsp;有多少个字符替换多少位置，其中汉字占2个位置$redis-&gt;strlen(&#39;key&#39;);&nbsp;//键值长度$redis-&gt;getBit(&#39;key&#39;);$redis-&gt;setBit(&#39;key&#39;);3. 链表操作$redis-&gt;delete(&#39;list-key&#39;);&nbsp;//&nbsp;删除链表$redis-&gt;lPush(&#39;list-key&#39;,&nbsp;&#39;A&#39;);&nbsp;//插入链表头部/左侧，返回链表长度$redis-&gt;rPush(&#39;list-key&#39;,&nbsp;&#39;B&#39;);&nbsp;//插入链表尾部/右侧，返回链表长度$redis-&gt;lPushx(&#39;list-key&#39;,&nbsp;&#39;C&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;插入链表头部/左侧,链表不存在返回0，存在即插入成功，返回当前链表长度$redis-&gt;rPushx(&#39;list-key&#39;,&nbsp;&#39;C&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;插入链表尾部/右侧,链表不存在返回0，存在即插入成功，返回当前链表长度$redis-&gt;lPop(&#39;list-key&#39;);&nbsp;//返回LIST顶部（左侧）的VALUE&nbsp;,后入先出(栈)$redis-&gt;rPop(&#39;list-key&#39;);&nbsp;//返回LIST尾部（右侧）的VALUE&nbsp;,先入先出（队列）$redis-&gt;blPop();$redis-&gt;brPop();$redis-&gt;lSize(&#39;list-key&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果是链表则返回链表长度，空链表返回0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若不是链表或者不为空，则返回false&nbsp;,判断非链表&nbsp;&quot;&nbsp;===&nbsp;false&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$redis-&gt;lGet(&#39;list-key&#39;,-1);&nbsp;//&nbsp;通过索引获取链表元素&nbsp;0获取左侧一个&nbsp;&nbsp;-1获取最后一个$redis-&gt;lSet(&#39;list-key&#39;,&nbsp;0,&nbsp;&#39;X&#39;);&nbsp;//0位置元素替换为&nbsp;X$redis-&gt;lRange(&#39;list-key&#39;,&nbsp;0,&nbsp;3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//链表截取&nbsp;从0开始&nbsp;3位置结束&nbsp;，结束位置为-1&nbsp;获取开始位置之后的全部$redis-&gt;lTrim(&#39;list-key&#39;,&nbsp;0,&nbsp;1);&nbsp;//&nbsp;截取链表(不可逆)&nbsp;从0索引开始&nbsp;1索引结束&nbsp;$redis-&gt;lRem(&#39;list-key&#39;,&nbsp;&#39;C&#39;,&nbsp;2);&nbsp;//链表从左开始删除元素2个C$redis-&gt;lInsert(&#39;list-key&#39;,&nbsp;Redis::BEFORE,&nbsp;&#39;C&#39;,&nbsp;&#39;X&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;在C元素前面插入X&nbsp;&nbsp;,&nbsp;Redis::AfTER(表示后面插入)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表不存在则插入失败&nbsp;返回0&nbsp;若元素不存在返回-1$redis-&gt;rpoplpush(&#39;list-key&#39;,&nbsp;&#39;list-key2&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从源LIST的最后弹出一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并且把这个元素从目标LIST的顶部（左侧）压入目标LIST。&nbsp;$redis-&gt;brpoplpush();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//rpoplpush的阻塞版本，这个版本有第三个参数用于设置阻塞时间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即如果源LIST为空，那么可以阻塞监听timeout的时间，如果有元素了则执行操作。4. 无序类型set无序集合&nbsp;不允许出现重复的元素&nbsp;服务端可以实现多个&nbsp;集合操作$redis-&gt;sMembers(&#39;key&#39;);&nbsp;//获取容器key中所有元素$redis-&gt;sAdd(&#39;key&#39;&nbsp;,&nbsp;&#39;TK&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;(从左侧插入,最后插入的元素在0位置),集合中已经存在TK&nbsp;则返回false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不存在添加成功&nbsp;返回true$redis-&gt;sRem(&#39;key&#39;&nbsp;,&nbsp;&#39;TK&#39;);&nbsp;//&nbsp;移除容器中的TK$redis-&gt;sMove(&#39;key&#39;,&#39;key1&#39;,&#39;TK&#39;);&nbsp;//将容易key中的元素TK&nbsp;移动到容器key1&nbsp;&nbsp;操作成功返回TRUE$redis-&gt;sIsMember(&#39;key&#39;,&#39;TK&#39;);&nbsp;//检查VALUE是否是SET容器中的成员$redis-&gt;sCard(&#39;key&#39;);&nbsp;//返回SET容器的成员数$redis-&gt;sPop(&#39;key&#39;);&nbsp;//随机返回容器中一个元素，并移除该元素$redis-&gt;sRandMember(&#39;key&#39;);//随机返回容器中一个元素，不移除该元素$redis-&gt;sInter(&#39;key&#39;,&#39;key1&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;返回两个集合的交集&nbsp;没有交集返回一个空数组，若参数只有一个集合，则返回集合对应的完整的数组$redis-&gt;sInterStore(&#39;store&#39;,&#39;key&#39;,&#39;key1&#39;);&nbsp;//将集合key和集合key1的交集&nbsp;存入容器store&nbsp;成功返回1$redis-&gt;sUnion(&#39;key&#39;,&#39;key1&#39;);&nbsp;//集合key和集合key1的并集&nbsp;&nbsp;注意即使多个集合有相同元素&nbsp;只保留一个$redis-&gt;sUnionStore(&#39;store&#39;,&#39;key&#39;,&#39;key1&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//集合key和集合key1的并集保存在集合store中,&nbsp;&nbsp;注意即使多个集合有相同元素&nbsp;只保留一个$redis-&gt;sDiff(&#39;key&#39;,&#39;key1&#39;,&#39;key2&#39;);&nbsp;//返回数组，该数组元素是存在于key集合而不存在于集合key1&nbsp;key25. Zset数据类型(stored&nbsp;set)&nbsp;和&nbsp;set&nbsp;一样是字符串的集合，不同的是每个元素都会关联一个&nbsp;double&nbsp;类型的&nbsp;scoreredis的list类型其实就是一个每个子元素都是string类型的双向链表。$redis-&gt;zAdd(&#39;tkey&#39;,&nbsp;1,&nbsp;&#39;A&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;插入集合tkey中，A元素关联一个分数，插入成功返回1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时集合元素不可以重复,&nbsp;如果元素已经存在返回&nbsp;0$redis-&gt;zRange(&#39;tkey&#39;,0,-1);&nbsp;//&nbsp;获取集合元素，从0位置&nbsp;到&nbsp;-1&nbsp;位置$redis-&gt;zRange(&#39;tkey&#39;,0,-1,&nbsp;true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取集合元素，从0位置&nbsp;到&nbsp;-1&nbsp;位置,&nbsp;返回一个关联数组&nbsp;带分数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array([A]&nbsp;=&gt;&nbsp;0.01,[B]&nbsp;=&gt;&nbsp;0.02,[D]&nbsp;=&gt;&nbsp;0.03)&nbsp;其中小数来自zAdd方法第二个参数$redis-&gt;zDelete(&#39;tkey&#39;,&nbsp;&#39;B&#39;);&nbsp;//&nbsp;移除集合tkey中元素B&nbsp;&nbsp;成功返回1&nbsp;失败返回&nbsp;0$redis-&gt;zRevRange(&#39;tkey&#39;,&nbsp;0,&nbsp;-1);&nbsp;//&nbsp;获取集合元素，从0位置&nbsp;到&nbsp;-1&nbsp;位置，数组按照score降序处理$redis-&gt;zRevRange(&#39;tkey&#39;,&nbsp;0,&nbsp;-1,true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取集合元素，从0位置&nbsp;到&nbsp;-1&nbsp;位置，数组按照score降序处理&nbsp;返回score关联数组$redis-&gt;zRangeByScore(&#39;tkey&#39;,&nbsp;0,&nbsp;0.2,array(&#39;withscores&#39;&nbsp;=&gt;&nbsp;true));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取几个tkey中score在区间[0,0.2]元素&nbsp;,score由低到高排序,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;元素具有相同的score，那么会按照字典顺序排列&nbsp;,&nbsp;withscores&nbsp;控制返回关联数组$redis-&gt;zRangeByScore(&#39;tkey&#39;,&nbsp;0.1,&nbsp;0.36,&nbsp;array(&#39;withscores&#39;&nbsp;=&gt;&nbsp;TRUE,&nbsp;&#39;limit&#39;&nbsp;=&gt;&nbsp;array(0,&nbsp;1)));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//其中limit中&nbsp;0和1&nbsp;表示取符合条件集合中&nbsp;从0位置开始，向后扫描1个&nbsp;返回关联数组$redis-&gt;zCount(&#39;tkey&#39;,&nbsp;2,&nbsp;10);&nbsp;//&nbsp;获取tkey中score在区间[2,&nbsp;10]元素的个数$redis-&gt;zRemRangeByScore(&#39;tkey&#39;,&nbsp;1,&nbsp;3);&nbsp;//&nbsp;移除tkey中score在区间1,&nbsp;3的元素$redis-&gt;zRemRangeByRank(&#39;tkey&#39;,&nbsp;0,&nbsp;1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//默认元素score是递增的，移除tkey中元素&nbsp;从0开始到-1位置结束$redis-&gt;zSize(&#39;tkey&#39;);&nbsp;&nbsp;//返回存储在key对应的有序集合中的元素的个数$redis-&gt;zScore(&#39;tkey&#39;,&nbsp;&#39;A&#39;);&nbsp;//&nbsp;返回集合tkey中元素A的score值$redis-&gt;zRank(&#39;tkey&#39;,&nbsp;&#39;A&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;返回集合tkey中元素A的索引值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z集合中元素按照score从低到高进行排列&nbsp;，即最低的score&nbsp;index索引为0$redis-&gt;zIncrBy(&#39;tkey&#39;,&nbsp;2.5,&nbsp;&#39;A&#39;);&nbsp;//&nbsp;将集合tkey中元素A的score值&nbsp;加&nbsp;2.5$redis-&gt;zUnion(&#39;union&#39;,&nbsp;array(&#39;tkey&#39;,&nbsp;&#39;tkey1&#39;));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;将集合tkey和集合tkey1元素合并于集合union&nbsp;,&nbsp;并且新集合中元素不能重复&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回新集合的元素个数，&nbsp;如果元素A在tkey和tkey1都存在，则合并后的元素A的score相加$redis-&gt;zUnion(&#39;ko2&#39;,&nbsp;array(&#39;k1&#39;,&nbsp;&#39;k2&#39;),&nbsp;array(5,&nbsp;2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;集合k1和集合k2并集于k02&nbsp;，array(5,1)中元素的个数与子集合对应，然后&nbsp;5&nbsp;对应k1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k1每个元素score都要乘以5&nbsp;，同理1对应k2，k2每个元素score乘以1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后元素按照递增排序，默认相同的元素score(SUM)相加$redis-&gt;zUnion(&#39;ko2&#39;,&nbsp;array(&#39;k1&#39;,&nbsp;&#39;k2&#39;),&nbsp;array(10,&nbsp;2),&#39;MAX&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;各个子集乘以因子之后，元素按照递增排序，相同的元素的score取最大值(MAX)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以设置MIN&nbsp;取最小值$redis-&gt;zInter(&#39;ko1&#39;,&nbsp;array(&#39;k1&#39;,&nbsp;&#39;k2&#39;));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;集合k1和集合k2取交集于k01&nbsp;，且按照score值递增排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果集合元素相同，则新集合中的元素的score值相加$redis-&gt;zInter(&#39;ko1&#39;,&nbsp;array(&#39;k1&#39;,&nbsp;&#39;k2&#39;),&nbsp;array(5,&nbsp;1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//集合k1和集合k2取交集于k01&nbsp;，array(5,1)中元素的个数与子集合对应，然后&nbsp;5&nbsp;对应k1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k1每个元素score都要乘以5&nbsp;，同理1对应k2，k2每个元素score乘以1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;，然后元素score按照递增排序，默认相同的元素score(SUM)相加$redis-&gt;zInter(&#39;ko1&#39;,&nbsp;array(&#39;k1&#39;,&nbsp;&#39;k2&#39;),&nbsp;array(5,&nbsp;1),&#39;MAX&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;各个子集乘以因子之后，元素score按照递增排序，相同的元素score取最大值(MAX)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以设置MIN&nbsp;取最小值6. Hash数据类型redis hash是一个string类型的field和value的映射表.它的添加，删除操作都是O(1)（平均）.hash特别适合用于存储对象。$redis-&gt;hSet(&#39;h&#39;,&nbsp;&#39;name&#39;,&nbsp;&#39;TK&#39;);&nbsp;//&nbsp;在h表中&nbsp;添加name字段&nbsp;value为TK$redis-&gt;hSetNx(&#39;h&#39;,&nbsp;&#39;name&#39;,&nbsp;&#39;TK&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;在h表中&nbsp;添加name字段&nbsp;value为TK&nbsp;如果字段name的value存在返回false&nbsp;否则返回&nbsp;true$redis-&gt;hGet(&#39;h&#39;,&nbsp;&#39;name&#39;);&nbsp;//&nbsp;获取h表中name字段value$redis-&gt;hLen(&#39;h&#39;);&nbsp;//&nbsp;获取h表长度即字段的个数$redis-&gt;hDel(&#39;h&#39;,&#39;email&#39;);&nbsp;//&nbsp;删除h表中email&nbsp;字段$redis-&gt;hKeys(&#39;h&#39;);&nbsp;//&nbsp;获取h表中所有字段$redis-&gt;hVals(&#39;h&#39;);&nbsp;//&nbsp;获取h表中所有字段value$redis-&gt;hGetAll(&#39;h&#39;);&nbsp;//&nbsp;获取h表中所有字段和value&nbsp;返回一个关联数组(字段为键值)$redis-&gt;hExists(&#39;h&#39;,&nbsp;&#39;email&#39;);&nbsp;//判断email&nbsp;字段是否存在与表h&nbsp;不存在返回false$redis-&gt;hSet(&#39;h&#39;,&nbsp;&#39;age&#39;,&nbsp;28);$redis-&gt;hIncrBy(&#39;h&#39;,&nbsp;&#39;age&#39;,&nbsp;-2);&nbsp;&nbsp;//&nbsp;设置h表中age字段value加(-2)&nbsp;如果value是个非数值&nbsp;则返回false&nbsp;否则，返回操作后的value$redis-&gt;hIncrByFloat(&#39;h&#39;,&nbsp;&#39;age&#39;,&nbsp;-0.33);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;设置h表中age字段value加(-2.6)&nbsp;如果value是个非数值&nbsp;则返回false&nbsp;否则&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回操作后的value(小数点保留15位)$redis-&gt;hMset(&#39;h&#39;,&nbsp;array(&#39;score&#39;&nbsp;=&gt;&nbsp;&#39;80&#39;,&nbsp;&#39;salary&#39;&nbsp;=&gt;&nbsp;2000));&nbsp;//&nbsp;表h&nbsp;批量设置字段和value$redis-&gt;hMGet(&#39;h&#39;,&nbsp;array(&#39;score&#39;,&#39;salary&#39;));&nbsp;//&nbsp;表h&nbsp;批量获取字段的value","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"常见mysql","slug":"常见mysql","date":"2018-03-19T08:12:50.000Z","updated":"2019-11-27T10:08:50.081Z","comments":true,"path":"2018/03/19/150/","link":"","permalink":"http://github.13sai.com/2018/03/19/150/","excerpt":"","text":"常用的sql语句，方便查询。 一、用户管理：1、新建用户： CREATE USER name IDENTIFIED BY ‘ssapdrow’; 2、更改密码： SET PASSWORD FOR name=PASSWORD(‘fdddfd’); 3、权限管理 SHOW GRANTS FOR name; //查看name用户权限 GRANT SELECT ON db_name.* TO name; //给name用户db_name数据库的所有权限 REVOKE SELECT ON db_name.* TO name; //GRANT的反操作，去除权限； 二、数据库操作：1、查看数据库： SHOW DATABASES; 2、创建数据库： CREATE DATABASE db_name;//db_name为数据库名 3、使用数据库： USE db_name; 4、删除数据库： DROP DATABASE db_name; 三、创建表：1、创建表：12345CREATE TABLE IF NOT EXISTS table_name( id INT UNSIGNED NOT NULL AUTO_INCREMENT, //id值，无符号、非空、递增——唯一性，可做主键。 name VARCHAR(60) NOT NULLscore TINYINT UNSIGNED NOT NULL DEFAULT 0, //设置默认列值 PRIMARY KEY(id))ENGINE=InnoDB //设置表的存储引擎，一般常用InnoDB和MyISAM；InnoDB可靠，支持事务；MyISAM高效不支持全文检索DEFAULT charset=utf8; //设置默认的编码，防止数据库中文乱码 2、复制表： CREATE TABLE tb_name2 SELECT * FROM tb_name; 或者部分复制： CREATE TABLE tb_name2 SELECT id,name FROM tb_name; 3、创建临时表： CREATE TEMPORARY TABLE tb_name(这里和创建普通表一样); 4、查看数据库中可用的表： SHOW TABLES; 5、查看表的结构： DESCRIBE tb_name; 也可以使用： SHOW COLUMNS in tb_name; //from也可以 6、删除表： DROP [ TEMPORARY ] TABLE [ IF EXISTS ] tb_name[ ,tb_name2…….]; 实例： DROP TABLE IF EXISTS tb_name; 7、表重命名： RENAME TABLE name_old TO name_new; 还可以使用： ALTER TABLE name_old RENAME name_new; 四、修改表：1、更改表结构： ALTER TABLE tb_name ADD[CHANGE,RENAME,DROP] …要更改的内容… 实例： ALTER TABLE tb_name ADD COLUMN address varchar(80) NOT NULL; ALTER TABLE tb_name DROP address; ALTER TABLE tb_name CHANGE score grade SMALLINT(4) NOT NULL; 当然，如果不修改字段名，更建议MODIFY，而不是CHANGE ALTER TABLE tb_name MODIFY score INT(10); 五、插入数据：1、插入数据： INSERT INTO tb_name(id,name,score)VALUES(NULL,’张三’,140),(NULL,’张四’,178),(NULL,’张五’,134); 这里的插入多条数据直接在后边加上逗号，直接写入插入的数据即可；主键id是自增的列，可以不用写。 2、插入检索出来的数据： INSERT INTO tb_name(name,score) SELECT name,score FROM tb_name2; 六、更新数据：1、指定更新数据： UPDATE tb_name SET score=189 WHERE id=2; UPDATE tablename SET columnName=NewValue [ WHERE condition ] 七、删除数据：1、删除数据： DELETE FROM tb_name WHERE id=3; 八、条件控制：1、WHERE 语句： SELECT * FROM tb_name WHERE id=3; 2、HAVING 语句： SELECT * FROM tb_name GROUP BY score HAVING count(*)&gt;2 3、相关条件控制符 =、&gt;、&lt;、&lt;&gt;、IN(1,2,3……)、BETWEEN a AND b、NOT AND 、OR Like()用法中 % 为匹配任意、 _ 匹配一个字符（可以是汉字） IS NULL 空值检测 九、MySQL的正则表达式：1、Mysql支持REGEXP的正则表达式： SELECT * FROM tb_name WHERE name REGEXP ‘[1]’ //找出以A-D 为开头的name 2、特殊字符需要转义。十、MySQL的一些函数：1、字符串链接——CONCAT() SELECT CONCAT(name,’=&gt;’,score) FROM tb_name 2、数学函数： AVG、SUM、MAX、MIN、COUNT；3、文本处理函数： TRIM、LOCATE、UPPER、LOWER、SUBSTRING4、运算符： +、-、*、5、时间函数： DATE()、CURTIME()、DAY()、YEAR()、NOW()…..十一、分组查询：1、分组查询可以按照指定的列进行分组： SELECT COUNT() FROM tb_name GROUP BY score HAVING COUNT()&gt;1; 2、条件使用Having；3、ORDER BY 排序 ORDER BY DESC|ASC =&gt;按数据的降序和升序排列 十二、索引相关1、添加PRIMARY KEY（主键索引） ALTER TABLE table_name ADD PRIMARY KEY ( column ) 2、 添加UNIQUE(唯一索引) ALTER TABLE table_name ADD UNIQUE ( column ) 3、添加INDEX(普通索引) ALTER TABLE table_name ADD INDEX index_name ( column ) 4、添加FULLTEXT(全文索引) ALTER TABLE table_name ADD FULLTEXT ( column) 5、添加联合索引 ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3 ) 6、查询索引 SHOW INDEX FROM table_name; 7、删除索引 drop index index_name on table_name ; alter table table_name drop index index_name ; alter table table_name drop primary key ;","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"iconv的小毛病","slug":"iconv的小毛病","date":"2018-03-08T03:32:22.000Z","updated":"2021-04-13T07:31:11.703Z","comments":true,"path":"2018/03/08/149/","link":"","permalink":"http://github.13sai.com/2018/03/08/149/","excerpt":"","text":"最近做csv导出，本地测试ok，发布到线上总是导出失败，同事追根溯源，找出是一导出进程就被Linux干掉了，然后改代码，分片导出，线上还是失败。最后同事说是转码的问题，去掉iconv转码，发布，成功！然而，下载的csv用office打开就尴尬了，中文乱码，最后据说是此函数有bug，改为mb_convert_encoding 函数，成功！看看php手册说明：iconv将字符串 str 从 in_charset 转换编码到 out_charset。string mb_convert_encoding ( string $str , string $to_encoding [, mixed $from_encoding = mb_internal_encoding() ] )参数in_charset 输入的字符集。out_charset 输出的字符集。如果你在 out_charset 后添加了字符串 //TRANSLIT，将启用转写（transliteration）功能。这个意思是，当一个字符不能被目标字符集所表示时，它可以通过一个或多个形似的字符来近似表达。 如果你添加了字符串 //IGNORE，不能以目标字符集表达的字符将被默默丢弃。 否则，会导致一个 E_NOTICE并返回 FALSE。Caution//TRANSLIT 运行细节高度依赖于系统的 iconv() 实现（参见 ICONV_IMPL）。 据悉，某些系统上的实现会直接忽略 //TRANSLIT，所以转换也有可能失败，out_charset 会是不合格的。str 要转换的字符串。返回值返回转换后的字符串， 或者在失败时返回 FALSE。更新日志5.4.0 这个版本起，字符非法时候会返回 FALSE，除非在输出字符里指定了 //IGNORE 。 在之前版本，它会返回一部分字符串。&lt;?php $text&nbsp;=&nbsp;&quot;This&nbsp;is&nbsp;the&nbsp;Euro&nbsp;symbol&nbsp;&#39;€&#39;.&quot;;echo&nbsp;&#39;Original&nbsp;:&nbsp;&#39;,&nbsp;$text,&nbsp;PHP_EOL; echo&nbsp;&#39;TRANSLIT&nbsp;:&nbsp;&#39;,&nbsp;iconv(&quot;UTF-8&quot;,&nbsp;&quot;ISO-8859-1//TRANSLIT&quot;,&nbsp;$text),&nbsp;PHP_EOL; echo&nbsp;&#39;IGNORE&nbsp;&nbsp;&nbsp;:&nbsp;&#39;,&nbsp;iconv(&quot;UTF-8&quot;,&nbsp;&quot;ISO-8859-1//IGNORE&quot;,&nbsp;$text),&nbsp;PHP_EOL; echo&nbsp;&#39;Plain&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&#39;,&nbsp;iconv(&quot;UTF-8&quot;,&nbsp;&quot;ISO-8859-1&quot;,&nbsp;$text),&nbsp;PHP_EOL; ?&gt;Original&nbsp;:&nbsp;This&nbsp;is&nbsp;the&nbsp;Euro&nbsp;symbol&nbsp;&#39;€&#39;. TRANSLIT&nbsp;:&nbsp;This&nbsp;is&nbsp;the&nbsp;Euro&nbsp;symbol&nbsp;&#39;EUR&#39;. IGNORE&nbsp;&nbsp;&nbsp;:&nbsp;This&nbsp;is&nbsp;the&nbsp;Euro&nbsp;symbol&nbsp;&#39;&#39;. Plain&nbsp;&nbsp;&nbsp;&nbsp;: Notice:&nbsp;iconv():&nbsp;Detected&nbsp;an&nbsp;illegal&nbsp;character&nbsp;in&nbsp;input&nbsp;string&nbsp;in&nbsp;.\\iconv-exa","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"近期用到的若干Linux命令","slug":"近期用到的若干Linux命令","date":"2018-02-27T03:53:35.000Z","updated":"2020-12-09T10:34:26.028Z","comments":true,"path":"2018/02/27/148/","link":"","permalink":"http://github.13sai.com/2018/02/27/148/","excerpt":"","text":"查看并发数netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;返回结果示例：&nbsp;LAST_ACK&nbsp;5&nbsp;&nbsp;&nbsp;(正在等待处理的请求数)&nbsp; SYN_RECV&nbsp;30&nbsp;ESTABLISHED&nbsp;1597&nbsp;(正常数据传输状态)&nbsp; FIN_WAIT1&nbsp;51&nbsp;FIN_WAIT2&nbsp;504&nbsp;TIME_WAIT&nbsp;1057&nbsp;(处理完毕，等待超时结束的请求数)&nbsp; &nbsp; 状态：描述&nbsp; CLOSED：无连接是活动的或正在进行&nbsp; LISTEN：服务器在等待进入呼叫&nbsp; SYN_RECV：一个连接请求已经到达，等待确认&nbsp; SYN_SENT：应用已经开始，打开一个连接&nbsp; ESTABLISHED：正常数据传输状态&nbsp; FIN_WAIT1：应用说它已经完成&nbsp; FIN_WAIT2：另一边已同意释放&nbsp; ITMED_WAIT：等待所有分组死掉&nbsp; CLOSING：两边同时尝试关闭&nbsp; TIME_WAIT：另一边已初始化一个释放&nbsp; LAST_ACK：等待所有分组死掉修改文件时间touch -d &quot;6:03pm 05/06/2000&quot; filefind /data/logs/ -mtime +30 -name &#39;*&#39; -exec rm -rf {} ;find /data/logs/&nbsp; -name &quot;*[1,2]&quot; -print;find /data/logs/ -mtime +20 -name &quot;*[1]&quot; -exec rm -rf {} ;find /data/logs/ -mtime +40 -name &#39;*[0-9].log&#39; -exec rm -rf {} ;#&nbsp;删除过期日志0&nbsp;4&nbsp;*&nbsp;*&nbsp;*&nbsp;www&nbsp;find&nbsp;/data/logs/weixin&nbsp;-mtime&nbsp;+32&nbsp;-name&nbsp;&#39;*[0-9].log&#39;&nbsp;-exec&nbsp;rm&nbsp;-rf&nbsp;{}&nbsp;\\;","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"}]},{"title":"Linux下各文件夹的结构说明及用途介绍","slug":"Linux下各文件夹的结构说明及用途介绍","date":"2018-02-27T03:50:29.000Z","updated":"2021-04-13T07:32:39.107Z","comments":true,"path":"2018/02/27/147/","link":"","permalink":"http://github.13sai.com/2018/02/27/147/","excerpt":"","text":"linux下各文件夹的结构说明及用途介绍：/bin：二进制可执行命令。/dev：设备特殊文件。/etc：系统管理和配置文件。/etc/rc.d：启动的配 置文件和脚本。/home：用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示。/lib：标准程序设计库，又 叫动态链接共享库，作用类似windows里的.dll文件。/sbin：系统管理命令，这 里存放的是系统管理员使用的管理程序。/tmp：公用的临时文件存储 点。/root：系统管理员的主目 录。/mnt：系统提供这个目录是 让用户临时挂载其他的文件系统。/lost+found：这个 目录平时是空的，系统非正常关机而留下“无家可归”的文件就在这里。/proc：虚拟的目录，是系 统内存的映射。可直接访问这个目录来获取系统信息。/var：某些大文件的溢出 区，比方说各种服务的日志文件。/usr：最庞大的目录，要用 到的应用程序和文件几乎都在这个目录。其中包含：/usr/x11r6：存放x window的目录。/usr/bin：众多的应用程序。/usr/sbin：超级用户的一些管理程序。/usr/doc：linux文档。/usr/include：linux下开发和编译应用程序所需要的头文件。/usr/lib：常用的动态链接库和软件包的配置文件。/usr/man：帮助文档。/usr/src：源代码，linux内核的源代码就放在/usr/src/linux 里。/usr/local/bin：本地增加的命令。/usr/local/lib：本地增加的库根文件系统。通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大部分文件都不需要经常改动，而且包括严格的文件和一个小的 不经常改变的文件系统不容易损坏。除了可能的一个叫/vmlinuz标准的系统引导映像之外，根目录一般不含任何文 件。所有其他文件在根文件系统的子目录中。1. /bin目录/bin目录包含了引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。这些命 令都是二进制文件的可执行程序(bin是binary的简称)，多是系统中重要的系统文件。2. /sbin目录/sbin目录类似/bin ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使 用。3. /etc目录/etc目录存放着各种系统配置文件，其中包括了用户信息文件/etc/passwd， 系统初始化文件/etc/rc等。linux正是靠这些文件才得以正常地运行。4. /root目录/root目录是超级用户的目录。5. /lib目录/lib目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。 这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本，故可以使得可执行文件变得更小，节省空间。6. /lib/modules目录/lib/modules目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重 新引导系统所需的模块(例如网络和文件系统驱动)。7. /dev目录/dev目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可 以通过访问/dev/mouse来访问鼠标的输入，就像访问其他文件一样。8. /tmp目录/tmp目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用/var/tmp来 代替/tmp，因为前者可能拥有一个更大的磁盘空间。9. /boot目录/boot目录存放引导加载器(bootstrap loader)使用的文件，如lilo，核心映像也经常放在这里，而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的 文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在ide硬盘的前1024柱面内。10. /mnt目录/mnt目录是系统管理员临时安装(mount)文件系统的安装点。程序并不自动支持安装到/mnt 。/mnt下面可以分为许多子目录，例如/mnt/dosa可能是使用 msdos文件系统的软驱，而/mnt/exta可能是使用ext2文件系统的软驱，/mnt/cdrom光 驱等等。11. /proc, /usr, /var, /home目录其他文件系统的安装点。目录树可以分为小的部分，每个部分可以在自己的磁盘或分区上。主要部分是根、/usr 、/var 和 /home 文件系统。每个部分有不同的目的。每台机器都有根文件系统，它包含系统引导和使其他文件系统得以mount所必要的文件，根文件系统应该有单用户状态所必须的足够的内容。还应该包括修复损坏 系统、恢复备份等的工具。/usr 文件系统包含所有命令、库、man页和其他一般操作中所需的不改变的文件。&nbsp;/usr 不应该有 一般使用中要修改的文件。这样允许此文件系统中的文件通过网络共享，这样可以更有效，因为这样节省了磁盘空间(/usr 很容易是数百兆)，且易于管理 (当升级应用时，只有主/usr 需要改变，而无须改变每台机器) 即使此文件系统在本地盘上，也可以只读mount，以减少系统崩溃时文件系统的损 坏。/var 文件系统包含会改变的文件，比如spool目录(mail、news、打印机等用的)， log文件、 formatted manual pages和暂存文件。传统上/var 的所有东西曾在 /usr 下的某个地方，但这样/usr 就不可能只读安装 了。/home 文件系统包含用户家目录，即系统上的所有实际数据。一个大的/home 可能要分为若干文件系统，需要在 /home 下加一级名字，如/home/students 、/home/staff 等。下面详细介绍：/etc文件系统/etc目录包含各种系统配置文件，下面说明其中的一些。其他的你应该知道它们属于哪个程序， 并阅读该程序的man页。许多网络配置文件也在/etc中。1. /etc/rc或/etc/rc.d或/etc/rc?.d：启动、或改变运行级时运 行的脚本或脚本的目录。2. /etc/passwd：用户数据库，其中的域给出了用户名、真实姓名、用户起始目 录、加密口令和用户的其他信息。3. /etc/fdprm：软盘参数表，用以说明不同的软盘格式。可用setfdprm进 行设置。更多的信息见setfdprm的帮助页。4. /etc/fstab：指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的swap区的信息。5. /etc/group：类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。6. /etc/inittab：init 的配置文件。7. /etc/issue：包括用户在登录提示符前的输出信息。通常包括系统的一段短说明 或欢迎信息。具体内容由系统管理员确定。8. /etc/magic：“file”的配置文件。包含不同文件格式的说 明，“file”基于它猜测文件类型。9. /etc/motd：motd是message of the day的缩写，用户成功登录后自动输出。内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等。10. /etc/mtab：当前安装的文件系统列表。由脚本(scritp)初始化，并由 mount命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如df命令)。11. /etc/shadow：在安装了影子(shadow)口令软件的系统上的影子口令 文件。影子口令文件将/etc/passwd文件中的加密口令移动到/etc/shadow中，而后者只对超级用户(root)可读。这使破译口令更困 难，以此增加系统的安全性。12. /etc/login.defs：login命令的配置文件。13. /etc/printcap：类似/etc/termcap ，但针对打印机。语法不同。14. /etc/profile 、/etc/csh.login、/etc/csh.cshrc：登 录或启动时bourne或cshells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。15. /etc/securetty：确认安全终端，即哪个终端允许超级用户(root) 登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器(modem)或网络闯入系统并得到超级用户特权。16. /etc/shells：列出可以使用的shell。chsh命令允许用户在本文件 指定范围内改变登录的shell。提供一台机器ftp服务的服务进程ftpd检查用户shell是否列在/etc/shells文件 中，如果不是，将不允许该用户登录。17. /etc/termcap：终端性能数据库。说明不同的终端用什么“转义序列”控 制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap中查找要做的工作的 正确序列。这样，多数的程序可以在多数终端上运行。/dev文件系统/dev目录包括所有设备的设备文件。设备文件用特定的约定命名，这在设备列表中说明。设备文件在安装时由系 统产生，以后可以用/dev/makedev描述。/dev/makedev.local 是系统管理员为本地设备文件(或连接)写的描述文稿(即如一些非标准设备驱动不是标准makedev 的一部分)。下面简要介绍/dev下 一些常用文件。1. /dev/console：系统控制台，也就是直接和系统连接的监视器。2. /dev/hd：ide硬盘驱动程序接口。如：/dev/hda指的是第一个硬 盘，had1则是指/dev/hda的第一个分区。如系统中有其他的硬盘，则依次为/dev /hdb、/dev/hdc、. . . . . .；如有多个分区则依次为hda1、hda2 . . . . . .3. /dev/sd：scsi磁盘驱动程序接口。如系统有scsi硬盘，就不会访问/dev/had， 而会访问/dev/sda。4. /dev/fd：软驱设备驱动程序。如：/dev/fd0指 系统的第一个软盘，也就是通常所说的a盘，/dev/fd1指第二个软盘，. . . . . .而/dev/fd1 h1440则表示访问驱动器1中的4.5高密盘。5. /dev/st：scsi磁带驱动器驱动程序。6. /dev/tty：提供虚拟控制台支持。如：/dev/tty1指 的是系统的第一个虚拟控制台，/dev/tty2则是系统的第二个虚拟控制台。7. /dev/pty：提供远程登陆伪终端支持。在进行telnet登录时就要用到/dev/pty设 备。8. /dev/ttys：计算机串行接口，对于dos来说就是“com1”口。9. /dev/cua：计算机串行接口，与调制解调器一起使用的设备。10. /dev/null：“黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕 上的输出信息隐藏起来时，只要将输出信息输入到/dev/null中即可。/usr文件系统/usr是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr里 的所有文件一般来自linux发行版；本地安装的程序和其他东西在/usr/local下，因为这样可以在升级新版系 统或新发行版时无须重新安装全部程序。/usr目录下的许多内容是可选的，但这些功能会使用户使用系统更加有效。/usr可容纳许多大型的软件包和它们的 配置文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。1. /usr/x11r6：包含x window系统的所有可执行程序、配置文件和支持文件。为简化x的开发和安装，x的文件没有集成到系统中。x window系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对microsoft windows比较熟悉的话，就不会对x window系统感到束手无策了。2. /usr/x386：类似/usr/x11r6 ，但是是专门给x 11 release 5的。3. /usr/bin：集中了几乎所有用户命令，是系统的软件库。另有些命令在/bin或/usr/local/bin中。4. /usr/sbin：包括了根文件系统不必要的系统管理命令，例如多数服务程序。5. /usr/man、/usr/info、/usr/doc：这些目录包含所有手册页、 gnu信息文档和各种其他文档文件。每个联机手册的“节”都有两个子目录。例如：/usr/man/man1中包含联机手册第一节的源码(没有格式化的原 始文件)，/usr/man/cat1包含第一节已格式化的内容。联机手册分为以下九节：内部命令、系统调用、库函数、设备、文件格式、游戏、宏软件包、 系统管理和核心程序。6. /usr/include：包含了c语言的头文件，这些文件多以.h结尾，用来描述c 语言程序中用到的数据结构、子过程和常量。为了保持一致性，这实际上应该放在/usr/lib下，但习惯上一直沿用了这 个名字。7. /usr/lib：包含了程序或子系统的不变的数据文件，包括一些site – wide配置文件。名字lib来源于库(library); 编程的原始库也存在/usr/lib 里。当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中。8. /usr/local：本地安装的软件和其他文件放在这里。这与/usr很相似。用户 可能会在这发现一些比较大的软件包，如tex、emacs等。/var文件系统/var包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充 的。原来/var目录中有些内容是在/usr中的，但为了保持/usr目录的相对稳定，就把那些需要经常改变的目录放到/var中了。每个系统是特定的， 即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。1. /var/catman：包括了格式化过的帮助(man)页。帮助页的源文件一般存在 /usr/man/catman中；有些man页可能有预格式化的版本，存在/usr/man/cat中。而其他的man页在第一次看时都需要格式化，格 式化完的版本存在/var/man中，这样其他人再看相同的页时就无须等待格式化了。(/var/catman经常被 清除，就像清除临时目录一样。)2. /var/lib：存放系统正常运行时要改变的文件。3. /var/local：存放/usr/local中 安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var目录，例如/var/lock 。4. /var/lock：锁定文件。许多程序遵循在/var/lock中 产生一个锁定文件的约定，以用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。5. /var/log：各种程序的日志(log)文件，尤其是login (/var/log/wtmplog纪 录所有到系统的登录和注销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息)。/var/log 里的文件经常不确定地增长，应该定期清除。6. /var/run：保存在下一次系统引导前有效的关于系统的信息文件。例如，/var/run/utmp包 含当前登录的用户的信息。7. /var/spool：放置“假脱机(spool)”程序的目录，如mail、 news、打印队列和其他队列工作的目录。每个不同的spool在/var/spool下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail 中。8. /var/tmp：比/tmp允许更大的或需要存在较长时间的临时文件。注意系统管理 员可能不允许/var/tmp有很旧的文件。/proc文件系统/proc文件系统是一个伪的文件系统，就是说它是一个实际上不存在的目录，因而这是一个非 常特殊的目录。它并不存在于某个磁盘上，而是由核心在内存中产生。这个目录用于提供关于系统的信息。下面说明一些最重要的文件和目录(/proc文件系统 在proc man页中有更详细的说明)。1. /proc/x：关于进程x的信息目录，这x是这一进程的标识号。每个进程在 /proc下有一个名为自己进程号的目录。2. /proc/cpuinfo：存放处理器(cpu)的信息，如cpu的类型、制造商、 型号和性能等。3. /proc/devices：当前运行的核心配置的设备驱动的列表。4. /proc/dma：显示当前使用的dma通道。5. /proc/filesystems：核心配置的文件系统信息。6. /proc/interrupts：显示被占用的中断信息和占用者的信息，以及被占用 的数量。7. /proc/ioports：当前使用的i/o端口。8. /proc/kcore：系统物理内存映像。与物理内存大小完全一样，然而实际上没有 占用这么多内存；它仅仅是在程序访问它时才被创建。(注意：除非你把它拷贝到什么地方，否则/proc下没有任何东西占用任何磁盘空间。)9. /proc/kmsg：核心输出的消息。也会被送到syslog。10. /proc/ksyms：核心符号表。11. /proc/loadavg：系统“平均负载”；3个没有意义的指示器指出系统当前 的工作量。12. /proc/meminfo：各种存储器使用信息，包括物理内存和交换分区 (swap)。13. /proc/modules：存放当前加载了哪些核心模块信息。14. /proc/net：网络协议状态信息。15. /proc/self：存放到查看/proc的 程序的进程目录的符号连接。当2个进程查看/proc时，这将会是不同的连接。这主要便于程序得到它自己的进程目录。16. /proc/stat：系统的不同状态，例如，系统启动后页面发生错误的次数。17. /proc/uptime：系统启动的时间长度。18. /proc/version：核心版本。/usr/local下一般是你安装软件的目录，这个目录就相当于在windows下的programefiles这个目录&nbsp;/opt这个目录是一些大型软件的安装目录，或者是一些服务程序的安装目录举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。/usr/local这里主要存放那些手动安装的软件，即 不是通过“新立得”或apt-get安装的软件 。 它和/usr目录具有相类似的目录结构 。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意。","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"}]},{"title":"xdebug断点调试安装","slug":"xdebug断点调试安装","date":"2018-01-22T11:16:08.000Z","updated":"2021-04-13T07:34:12.766Z","comments":true,"path":"2018/01/22/146/","link":"","permalink":"http://github.13sai.com/2018/01/22/146/","excerpt":"","text":"安装准备：PHP环境（我使用的是nginx1.12+php7）PHPStorm1. 下载dll扩展放到PHP目录下ext中。2. 修改php.ini;注意是zend_extension zend_extension=php_xdebug.dll ;远程地址,指的是连接本php所在服务器的客户端ip xdebug.remote_host=127.0.0.1 ;远程端口，不要冲突 xdebug.remote_port=9999 xdebug.remote_handler=dbgp xdebug.collect_vars&nbsp;=&nbsp;On xdebug.collect_return&nbsp;=&nbsp;On xdebug.collect_params&nbsp;=&nbsp;On ;编辑器名称 xdebug.idekey=phpstorm xdebug.profiler_output_dir=&quot;D:\\wnmp\\php-7.0.26 mp�bug&quot;&nbsp; ;设定函数调用监测信息的输出文件的路径 xdebug.trace_output_dir=&quot;D:\\wnmp\\php-7.0.26 mp�bug&quot; xdebug.remote_enable&nbsp;=1xdebug.remote_mode&nbsp;=&nbsp;req xdebug.profiler_enable&nbsp;=&nbsp;off xdebug.profiler_enable_trigger&nbsp;=&nbsp;off ;开启远程调试自动 xdebug.remote_autostart&nbsp;=&nbsp;On配置成功，在phpinfo页面会出现xdebug版本和idekey。3. PHPStorm配置settings:&gt;&nbsp;Languages&nbsp;&amp;&nbsp;Frameworks&nbsp;→&nbsp;PHP&nbsp; 配置对应的interpreter，其实就是设置下PHP&nbsp;executable路径 如：D:\\wnmp\\php-7.0.26\\php.exe &gt;&nbsp;Languages&nbsp;&amp;&nbsp;Frameworks&nbsp;→&nbsp;PHP&nbsp;→&nbsp;Debug&nbsp;修改端口 &gt;&nbsp;Languages&nbsp;&amp;&nbsp;Frameworks&nbsp;→&nbsp;PHP&nbsp;→&nbsp;Debug&nbsp;→&nbsp;DBGp&nbsp;Proxy就是上面php设置的idekey，host，port。 &gt;&nbsp;Languages&nbsp;&amp;&nbsp;Frameworks&nbsp;→&nbsp;PHP&nbsp;→&nbsp;Servers添加选择Xdebug完成后Run&nbsp;→&nbsp;Edit&nbsp;Configuration添加一个PHP&nbsp;web&nbsp;application配置，选择刚才配置的Servers这样就完成了！run，debug都能直接用起来了。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"redis的windows尝试","slug":"redis的windows尝试","date":"2018-01-16T03:37:20.000Z","updated":"2021-04-13T07:36:35.188Z","comments":true,"path":"2018/01/16/145/","link":"","permalink":"http://github.13sai.com/2018/01/16/145/","excerpt":"","text":"Redis???Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。下载安装github上下载合适版本，建议msi文件下载。https://github.com/MicrosoftArchive/redis/releases一步步安装即可。启动redis到达redis安装目录，执行启动命令：redis-server --service-start如果启动失败，报1060，执行以下操作：redis-server --service-install redis.windows.conf成功后再次执行启动命令即可。常用命令启动服务：redis-server&nbsp;--service-start停止服务：redis-server&nbsp;--service-stop安装redis Desktop manager链接：https://pan.baidu.com/s/1dL4oHK&nbsp;密码：3v6o安装连接本地redis,可以查看redis数据。使用redis&lt;?php$redis&nbsp;=&nbsp;new&nbsp;Redis(); $ret&nbsp;=&nbsp;$redis-&gt;connect(&#39;127.0.0.1&#39;,&nbsp;6379); if(!$ret){&nbsp;&nbsp;&nbsp;&nbsp; die(&#39;connect&nbsp;error&#39;); } echo&nbsp;&quot;Connection&nbsp;to&nbsp;server&nbsp;sucessfully!&lt;br&gt;&quot;; //存储数据到列表中 $a&nbsp;=&nbsp;$redis-&gt;set(&#39;str&#39;,&#39;wow&#39;); $b&nbsp;=&nbsp;$redis-&gt;get(&#39;str&#39;); $c&nbsp;=&nbsp;$redis-&gt;get(&#39;strwww&#39;); $d&nbsp;=&nbsp;$redis-&gt;delete(&#39;str&#39;); var_dump($a);echo(&quot;&lt;br&gt;&quot;); var_dump($b);echo(&quot;&lt;br&gt;&quot;); var_dump($c);echo(&quot;&lt;br&gt;&quot;); var_dump($d); Connection&nbsp;to&nbsp;server&nbsp;sucessfully!bool(true)&nbsp;string(3)&nbsp;&quot;wow&quot;&nbsp;bool(false)&nbsp;int(1)","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"神奇的软链接","slug":"神奇的软链接","date":"2018-01-15T01:47:10.000Z","updated":"2021-04-13T07:23:28.943Z","comments":true,"path":"2018/01/15/144/","link":"","permalink":"http://github.13sai.com/2018/01/15/144/","excerpt":"","text":"什么是链接？链接简单说实际上是一种文件共享的方式，是 POSIX 中的概念，主流文件系统都支持链接文件。 链接是用来干什么的？你可以将链接简单地理解为 Windows 中常见的快捷方式（或是 OS X 中的替身），Linux 中常用它来解决一些库版本的问题，通常也会将一些目录层次较深的文件链接到一个更易访问的目录中。在这些用途上，我们通常会使用到软链接（也称符号链接）。 软链接和硬链接的区别 硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。 具体区别可看这篇文章：``https://www.jianshu.com/p/dde6a01c4094 1234## Linux创建命令实例： ln -s /home/test /testlink 1234567&gt; ln -s a b 中的 a 就是源文件，b是链接文件名,其作用是当进入b目录，实际上是链接进入了a目录如上面的示例，当我们执行命令 ```cd /testlink/```的时候 实际上是进入了 ```/home/test/```值得注意的是执行命令的时候,应该是a目录已经建立，目录b没有建立。我最开始操作的是也把b目录给建立了，结果就不对了删除软链接： rm -rf b 注意不是rm -rf b/ 1 ln a b 是建立硬链接 123## window创建命令 MKLINK [[/D] | [/H] | [/J]] Link Target /D 创建目录符号链接。默认为文件 符号链接。 /H 创建硬链接，而不是符号链接。 /J 创建目录联接。 Link 指定新的符号链接名称。 Target 指定新链接引用的路径 (相对或绝对)。","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"}]},{"title":"windows7搭建php7+nginx+mysql环境","slug":"windows7搭建php7+nginx+mysql环境","date":"2017-12-22T07:14:37.000Z","updated":"2021-04-13T07:34:27.470Z","comments":true,"path":"2017/12/22/143/","link":"","permalink":"http://github.13sai.com/2017/12/22/143/","excerpt":"","text":"1. 下载nginx，php7，mysql，并放置到你需要的文件夹2. nginx进入nginx目录，命令行start nginx浏览器进入localhost，会看到welcome to nginx！3. 配置phpphp.iniphp.ini-development复制为php.ini修改;这里根据自己的实际情况而定 extension_dir&nbsp;=&nbsp;&quot;D:/wnmp/php-7.0.26/ext&quot; ;加入扩展：选择需要运行哪些扩展，只需将extension前面的注释去掉，例如： extension=php_mbstring.dll extension=php_exif.dll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Must&nbsp;be&nbsp;after&nbsp;mbstring&nbsp;as&nbsp;it&nbsp;depends&nbsp;on&nbsp;it extension=php_mysqli.dllCGI 设置enable_dl&nbsp;=&nbsp;On cgi.force_redirect&nbsp;=&nbsp;0 cgi.fix_pathinfo&nbsp;=&nbsp;1 fastcgi.impersonate&nbsp;=&nbsp;1 cgi.rfc2616_headers&nbsp;=&nbsp;1修改nginx配置打开D:\\wnmp ginx-1.12.2","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"self和static","slug":"self和static","date":"2017-12-07T11:38:59.000Z","updated":"2021-04-13T07:36:17.646Z","comments":true,"path":"2017/12/07/142/","link":"","permalink":"http://github.13sai.com/2017/12/07/142/","excerpt":"","text":"PHP官方也说过，大概是说self调用的就是本身代码片段这个类，而static调用的是从堆内存中提取出来，访问的是当前实例化的那个类，那么 static 代表的就是那个类。 1234567891011121314151617181920212223242526272829303132333435class A &#123; protected static $str = &quot;This is class A&quot;; public static function getStr() &#123; echo self::$str; &#125;&#125;class B extends A&#123; protected static $str = &quot;This is class B&quot;;&#125;B::getStr();// 输出This is class Aclass A &#123; protected static $str = &quot;This is class A&quot;; public static function getStr() &#123; echo static::$str; &#125;&#125;class B extends A&#123; protected static $str = &quot;This is class B&quot;;&#125;B::getStr();// 输出This is class B self - 就是这个类，是代码段里面的这个类。static - PHP 5.3新特性。当前这个类，有点像$this的意思，从堆内存中提取出来，访问的是当前实例化的那个类，那么 static 代表的就是那个类。 1234567891011121314151617181920212223242526272829303132333435363738class A&#123; public function getSelf() &#123; return new self(); &#125; public function getStatic() &#123; return new static(); &#125;&#125;$f = new A();print get_class($f-&gt;getSelf());print get_class($f-&gt;getStatic());class B extends A&#123; public function getSelf2() &#123; return new self(); &#125; public function getStatic2() &#123; return new static(); &#125;&#125;$f = new B();print get_class($f-&gt;getSelf());print get_class($f-&gt;getStatic());print get_class($f-&gt;getSelf2());print get_class($f-&gt;getStatic2());// 输出AAABBB","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2017-11-17T09:23:59.000Z","updated":"2021-04-26T03:36:05.975Z","comments":true,"path":"2017/11/17/141/","link":"","permalink":"http://github.13sai.com/2017/11/17/141/","excerpt":"","text":"之前没用过git，还在持续踩坑中，后续继续更新。。。。。。 列出tag git tag # 在控制台打印出当前仓库的所有tag&gt; git tag -l ‘v0.1.*’ # 搜索符合模式的Tag 打tag git tag分为两种类型：轻量tag和附注tag。轻量tag是指向提交对象的引用，附注Tag则是仓库中的一个独立对象。建议使用附注Tag。 创建轻量Tag git tag v0.1.2-light 创建附注Tag git tag -a v0.1.2 -m “0.1.2版本” 创建轻量Tag不需要传递参数，直接指定Tag名称即可。 创建附注Tag时，参数a即annotated的缩写，指定Tag类型，后附Tag名。参数m指定Tag说明，说明信息会保存在Tag对象中。 切换到Tag与切换分支命令相同，用 git checkout [tagname] 查看Tag信息用git show命令可以查看Tag的版本信息： git show v0.1.2 删除Tag误打或需要修改Tag时，需要先将Tag删除，再打新Tag。 git tag -d v0.1.2 # 删除Tag 参数d即delete的缩写，意为删除其后指定的Tag。 给指定的commit打Tag 打Tag不必要在head之上，也可在之前的版本上打，这需要你知道某个提交对象的校验和（通过git log获取）。 补打Tag git tag -a v0.1.1 9fbc3d0 Tag推送到服务器 通常的git push不会将Tag对象提交到git服务器，我们需要进行显式的操作： git push origin v0.1.2 # 将v0.1.2 Tag提交到git服务器&gt; git push origin –-tags # 将本地所有Tag一次性提交到git服务器 注意：如果想看之前某个Tag状态下的文件，可以这样操作 git tag 查看当前分支下的Tag git checkout v0.21 此时会指向打v0.21 Tag时的代码状态，（但现在处于一个空的分支上） 删除远程分支和tag在Git v1.7.0 之后，可以使用这种语法删除远程分支： git push origin –delete 删除tag这么用： git push origin –delete tag 否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支： git push origin : 这是删除tag的方法，推送一个空tag到远程tag： git tag -d &gt; git push origin :refs/tags/ 重命名远程分支删除远程分支： git push –delete origin devel 重命名本地分支： git branch -m devel develop 推送本地分支： git push origin develop 把本地tag推送到远程 git push –tags # 推送所有tag&gt; git push origin :tag # 推送tag —— 2017/12/04 工作区（Working Directory） 就是你在电脑里能看到的目录，比如我的git文件夹就是一个工作区。 版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 暂存区 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 git add把文件添加进去，实际上就是把文件修改添加到暂存区； git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 命令说明git clone克隆git branch (分支名)创建分支 -D删除分支git checkout (分支名)切换分支 -b创建并切换git checkout (文件名)撤销此文件修改git add将该文件添加到缓存git status查看在你上次提交之后是否有修改git commit将缓存区内容添加到仓库中git diff来查看执行 git status 的结果的详细信息git reset HEAD命令用于取消已缓存的内容git rm 文件删除文件-f强制删除git mv移动文件git merge合并分支git fetch从远程获取最新版本到本地git push :将本地分支的更新，推送到远程主机git push origin --delete test删除远程分支testgit pull :将远程存储库中的更改合并到本地分支中git rebase命令在另一个分支基础之上重新应用，用于把一个分支的修改合并到当前分支。git log命令用于显示提交日志信息。git reflog显示每一次命令git revert生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留git reset HEAD 如果发现错误的将不想暂存的文件被git add进入索引之后，想回退取消，则可以使用 设置用户名邮箱： git config –global user.name “13sai” git config –global user.email “&#57;&#53;&#x37;&#48;&#x34;&#x32;&#x37;&#x38;&#x31;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#109;“ 12fatal: No configured push destination.解决：$ git remote add -f -t master -m master origin git://example.com/git.git/fatal: The current branch test has no upstream branch.解决：git push --set-upstream origin test模仿 git clone，但只跟踪选定的分支$ mkdir project.git$ cd project.git$ git init$ git remote add -f -t master -m master origin git://example.com/git.git/$ git merge originfatal：Unable to create &#x27;E:/project/scrm/.git/index.lock&#x27;: File exists.rm -f ./.git/index.lock 12345678910111213git log-p 查看差异-n(n为正整数) 查看最近n次的提交--pretty 按指定格式显示日志信息,可选项有：oneline,short,medium,full,fuller,email,raw以及format:&lt;string&gt;,默认为medium，可以通过修改配置文件来指定默认的方式。e.g. git log (--pretty=)oneline--stat 列出文件的修改行数--sortstat 只显示--stat中最后行数修改添加移除的统计--graph 以简单的图形方式列出提交记录--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。--name-only 仅在提交信息后显示已修改的文件清单。--name-status 显示新增、修改、删除的文件清单。 ——2017/12/01 命令 说明 git clone 克隆 git branch (分支名) 创建分支 -D删除分支 git checkout (分支名) 切换分支 -b创建并切换 git add 将该文件添加到缓存 git status 查看在你上次提交之后是否有修改 git commit 将缓存区内容添加到仓库中 git diff 来查看执行 git status 的结果的详细信息 git reset HEAD 命令用于取消已缓存的内容 git rm 文件 删除文件-f强制删除 git mv 移动文件 git merge 合并分支 git fetch 从远程获取最新版本到本地 git push : 将本地分支的更新，推送到远程主机 git push origin --delete test 删除远程分支test git pull : 将远程存储库中的更改合并到本地分支中 git rebase 命令在另一个分支基础之上重新应用，用于把一个分支的修改合并到当前分支。 1234567891011fatal: No configured push destination.解决：$ git remote add -f -t master -m master origin git://example.com/git.git/fatal: The current branch test has no upstream branch.解决：git push --set-upstream origin test模仿 git clone，但只跟踪选定的分支$ mkdir project.git$ cd project.git$ git init$ git remote add -f -t master -m master origin git://example.com/git.git/$ git merge origin","categories":[{"name":"ci","slug":"ci","permalink":"http://github.13sai.com/categories/ci/"}],"tags":[{"name":"git","slug":"git","permalink":"http://github.13sai.com/tags/git/"}]},{"title":"初识gulp","slug":"初识gulp","date":"2017-11-12T13:06:16.000Z","updated":"2021-04-26T03:40:53.736Z","comments":true,"path":"2017/11/12/140/","link":"","permalink":"http://github.13sai.com/2017/11/12/140/","excerpt":"","text":"使用 gulp 之前请安装好node和npm，为了速度，可以使用cnpm。 全局安装 cnpm install gulp -g glup -v // 输入版本，则说明安装成功。 新建package.json1234567891011121314&#123; &quot;name&quot;: &quot;sai&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;description&quot;: &quot;gulp css!&quot;, &quot;author&quot;: &#123; &quot;name&quot;: &quot;13sai&quot;, &quot;email&quot;: &quot;95742781@qq.com&quot; &#125;, &quot;license&quot;: &quot;MIT&quot;, &quot;devDependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-minify-css&quot;: &quot;^1.2.4&quot; &#125;&#125; 本地安装gulp，gulp-minify-css。12cnpm install gulp --save-dev cnpm install gulp-minify-css --save-dev 新建gulpfile.js1234567var gulp = require(&#x27;gulp&#x27;), mincss = require(&#x27;gulp-minify-css&#x27;);//定义一个sai任务gulp.task(&#x27;sai&#x27;, function () &#123; gulp.src(&#x27;assets/css/*.css&#x27;) //该任务针对的文件 .pipe(mincss()) //该任务调用的模块 .pipe(gulp.dest(&#x27;assets/mini&#x27;)); //将会在assets/mini下生成css&#125;); gulp.task(&#x27;default&#x27;,[&#x27;sai&#x27;]); //定义默认任务 cmd执行gulp gulp 会看到任务sai开始，完成，这样就完成了gulp压缩css。 此外，gulp还可以压缩js，img。","categories":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/categories/js/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://github.13sai.com/tags/gulp/"}]},{"title":"windows安装redis扩展","slug":"windows安装redis扩展","date":"2017-11-07T14:04:54.000Z","updated":"2021-04-13T07:34:20.376Z","comments":true,"path":"2017/11/07/139/","link":"","permalink":"http://github.13sai.com/2017/11/07/139/","excerpt":"","text":"phpinfo查看php对应VC版本下载redis,igbinaryhttp://windows.php.net/downloads/pecl/releases/igbinary/http://windows.php.net/downloads/pecl/releases/redis/注意下版本与ts，nts分别，这些信息都可以从phpinfo看见。 讲对应dll放入php下面ext。4.修改php.ini，增加extension=php_igbinary.dllextension=php_redis.dll重启服务器，并勾选扩展，搞定！","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"SVN服务器与web站点代码同步更新","slug":"SVN服务器与web站点代码同步更新","date":"2017-10-09T08:50:04.000Z","updated":"2021-04-13T07:36:20.392Z","comments":true,"path":"2017/10/09/138/","link":"","permalink":"http://github.13sai.com/2017/10/09/138/","excerpt":"","text":"因为SVN服务器与web站点代码是放在同一个服务器上的，所以我们尝试来做一个同步更新。 但是文件上传到SVN版本库后,上传的文件不再以文件原来的格式存储,而是被svn以它自定义的格式压缩成版本库数据,存放在版本库中。 这样我们就选择使用SVN自带的hooks来做web站点代码更新。 进入对应版本库下的hooks目录，复制 post-commit.tmpl为post-commit。 打开，修改代码如下： 12345678export.UTF-8 REPOS=&quot;$1&quot; REV=&quot;$2&quot; SVN_PATH=/usr/bin/svn #注意，此处是svn命令目录 WEB_PATH=/web/trunk #站点目录 LOG_PATH=/home/svn/trunk/svn.log echo &quot;##########开始提交 &quot; `date &quot;+%Y-%m-%d %H:%M:%S&quot;` &#x27;##################&#x27; &gt;&gt; $LOG_PATH $SVN_PATH update --username 13sai --password 123456 $WEB_PATH --no-auth-cache &gt;&gt; $LOG_PATH 记得要修改下post-commit的执行权限，然后测试，如果成功了，那恭喜你！","categories":[{"name":"ci","slug":"ci","permalink":"http://github.13sai.com/categories/ci/"}],"tags":[{"name":"svn","slug":"svn","permalink":"http://github.13sai.com/tags/svn/"}]},{"title":"linux搭建svn服务器","slug":"Linux搭建svn服务器","date":"2017-10-09T08:33:02.000Z","updated":"2021-04-13T07:32:31.692Z","comments":true,"path":"2017/10/09/137/","link":"","permalink":"http://github.13sai.com/2017/10/09/137/","excerpt":"","text":"环境：centos6.3安装svn yum install subversion 创建版本库 svnadmin create /home/repo //文件目录自己设置 配置 cd /home/repo/conf // 进入目录 配置目录下有三个文件 12345authz 权限passwd 账号密码svnserve.conf 版本库配置 编辑用户文件passwd，新增两个用户：admin和guest。 123[users]admin = 111111guest = 123456 编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。 123[/]admin = rwguest = r 编辑svnserve.conf： 123456[general]anon-access = none #控制非鉴权用户访问版本库的权限auth-access = write #控制鉴权用户访问版本库的权限password-db = passwd #指定用户名口令文件名authz-db = authz #指定权限配置文件名realm = repo #指定版本库的认证域，即在登录时提示的认证域名称 配置ip，打开3369端口并重启启动svn svnserve -d -r /home/repo 本地测试cmd输入svn checkout svn://***/repo，加入提示输入用户名密码，并能用之前账号登录，就表示配置成功。 如果本地装了类似TortoiseSVN软件，可以新建文件夹，然后checkout，输入用户名密码，测试成功！","categories":[{"name":"ci","slug":"ci","permalink":"http://github.13sai.com/categories/ci/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://github.13sai.com/tags/SVN/"}]},{"title":"linux常用命令","slug":"Linux常用命令","date":"2017-09-30T06:11:16.000Z","updated":"2021-04-13T07:32:22.511Z","comments":true,"path":"2017/09/30/135/","link":"","permalink":"http://github.13sai.com/2017/09/30/135/","excerpt":"","text":"文件操作命令说明cat用于连接文件并打印到标准输出设备上。chmod设定文件权限diff比较文件的差异file辨识文件类型find在指定目录下查找文件grep查找文件里符合条件的字符串cd切换当前工作目录ls显示指定工作目录下之内容exit退出目前的shellkill删除执行中的程序或工作mv用来为文件或目录改名、或将文件或目录移入其它位置rm删除一个文件或者目录 -r递归删除 -f强制删除cp用于复制文件或目录tail输出文件尾部内容mkdir新建目录touch新建文件pwd输出当前目录系统管理命令命令说明who显示在线登陆用户whoami显示当前操作用户ps显示当前进程 (process) 的状态vim使用vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。命令说明:q退出:q!强制退出:wq保存并退出:set number显示行号:set nonumber隐藏行号/sai在文档中查找sai 按n跳到下一个，shift+n上一个u撤销ctrl+r重做yyp复制光标所在行，并粘贴dd剪切当前行nddn表示大于1的数字，剪切n行dw从光标处剪切至一个单子/单词的末尾，包括空格de从光标处剪切至一个单子/单词的末尾，不包括空格d$从当前光标剪切到行末d0从当前光标位置（不包括光标位置）剪切之行首d3l从光标位置（包括光标位置）向右剪切3个字符d5G将当前行（包括当前行）至第5行（不包括它）剪切d3B从当前光标位置（不包括光标位置）反向剪切3个单词dH剪切从当前行至所显示屏幕顶行的全部行dM剪切从当前行至命令M所指定行的全部行dL剪切从当前行至所显示屏幕底的全部行h(左移一个字符←)j(下一行↓)k(上一行↑)l(右移一个字符→)ctrl+f下翻一屏。ctrl+b上翻一屏。ctrl+d下翻半屏。ctrl+u上翻半屏。ctrl+e向下滚动一行。ctrl+y向上滚动一行。n%到文件n%的位置。zz将当前行移动到屏幕中央。zt将当前行移动到屏幕顶端。zb将当前行移动到屏幕底端。附加命令说明yy复制当前行nyyn表示大于1的数字，复制n行yw从光标处复制至一个单子/单词的末尾，包括空格ye从光标处复制至一个单子/单词的末尾，不包括空格y$从当前光标复制到行末y0从当前光标位置（不包括光标位置）复制之行首y3l从光标位置（包括光标位置）向右复制3个字符y5G将当前行（包括当前行）至第5行（不包括它）复制y3B从当前光标位置（不包括光标位置）反向复制3个单词------2017/12/26命令说明cat用于连接文件并打印到标准输出设备上。chmod设定文件权限diff比较文件的差异file辨识文件类型find在指定目录下查找文件grep查找文件里符合条件的字符串cd切换当前工作目录ls显示指定工作目录下之内容exit退出目前的shellkill删除执行中的程序或工作ps显示当前进程 (process) 的状态mv用来为文件或目录改名、或将文件或目录移入其它位置rm删除一个文件或者目录cp用于复制文件或目录-----2017/9/30","categories":[{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"}]},{"title":"初识memcache","slug":"初识memcache","date":"2017-09-19T02:26:04.000Z","updated":"2021-04-26T03:40:59.042Z","comments":true,"path":"2017/09/19/134/","link":"","permalink":"http://github.13sai.com/2017/09/19/134/","excerpt":"","text":"介绍 Memcached是一个内存缓存系统，而Memcache是php的一个扩展，是php用于操作和管理Memcached的工具。如果安装了Memcached但没有安装Memcache，php无法操控Memcached，但是可以使用命令行来操控Memcached；如果安装了Memcache却没安装Memcached，则无法使用。只有同时安装了Memcached和Memcache，才能在PHP中使用Memcached。 Memcache是这个项目的名称，而memcached是它服务器端的主程序文件名。 安装memcache安装memcache分为两个过程： memcache服务器端的安装 memcached客户端的安装 所谓服务器端的安装就是在服务器（一般都是linux系统）上安装Memcache实现数据的存储 所谓客户端的安装就是指php（或者其他程序，Memcache还有其他不错的api接口提供）去使用服务器端的Memcache提供的函数，需要php添加扩展。 下载地址（这是在网上找的下载地址，我试过，可以下载） 解压下载后的文件，把它放到一个目录中，如D:\\memcached 打开cmd，进入memcached解压后存放的目录，运行命令： memcached.exe -d install 如果没有意外的话已经安装成功了。（目录中应该有memcached.exe这个文件） 测试是否安装成功： 打开cmd，进入memcached解压后存放的目录，运行命令： memcached -h 若安装成功，会出现多列提示 启动memcached： 打开cmd，进入memcached解压后存放的目录，运行命令： memcached.exe -d start 安装memcache的php扩展下载地址 （注意：要下载对应php版本和系统位数的dll文件，可在phpinfo里查看需要的版本） 把php_memcache.dll放到php的ext目录下，如： D:\\wamp\bin\\php\\ext 打开php.ini，在extension处添加一行代码： extension=php_memcache.dll 重启wamp。 查看php的extensions服务，php_memcache现在应该可以使用了，即处于打钩状态，之 前是处于叹号状态的，若还处于叹号状态，用鼠标在上面点击一下就好了。 通过代码测试php是否已经可以使用memcached： 1234567891011$memcache = new Memcache;$memcache-&gt;connect(&quot;127.0.0.1&quot;,11211);echo &quot;Memcached&#x27;s version: &quot; . $memcache-&gt;getVersion() . &quot;&lt;br /&gt;&quot;;$data = array( &#x27;url&#x27; =&gt; &quot;http://www.cnblogs.com/wujuntian/&quot;, &#x27;name&#x27; =&gt; &quot;编程人，在天涯&quot;);$memcache-&gt;set(&quot;info&quot;,$data,0,10);$info = $memcache-&gt;get(&quot;info&quot;);echo &#x27;&lt;pre&gt;&#x27;;print_r($info); 若能打印出memcache中的信息，则说明php的memcache扩展已安装成功且能使用了！ 更多操作如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt; ?php//连接$mem = new Memcache;$mem-&gt;connect(&quot;127.0.0.1&quot;,11211);//保存数据$mem-&gt;set(&#x27;key1&#x27;, &#x27;This is first value&#x27;, 0, 60);$val = $mem-&gt;get(&#x27;key1&#x27;);echo &quot;Get key1 value: &quot; . $val .&quot;&lt;br /&gt;&quot;;//替换数据$mem-&gt;replace(&#x27;key1&#x27;, &#x27;This is replace value&#x27;, 0, 60);$val = $mem-&gt;get(&#x27;key1&#x27;);echo &quot;Get key1 value: &quot; . $val . &quot;&lt;br /&gt;&quot;;//保存数组$arr = array(&#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;, &#x27;ddd&#x27;);$mem-&gt;set(&#x27;key2&#x27;, $arr, 0, 60);$val2 = $mem-&gt;get(&#x27;key2&#x27;);echo &quot;Get key2 value: &quot;;print_r($val2);echo &quot;&lt;br /&gt;&quot;;//删除数据$mem-&gt;delete(&#x27;key1&#x27;);$val = $mem-&gt;get(&#x27;key1&#x27;);echo &quot;Get key1 value: &quot; . $val . &quot;&lt;br /&gt;&quot;;//清除所有数据$mem-&gt;flush();$val2 = $mem-&gt;get(&#x27;key2&#x27;);echo &quot;Get key2 value: &quot;;print_r($val2);echo &quot;&lt;br /&gt;&quot;;//关闭连接$mem-&gt;close();如果正常的话，浏览器将输出：Get key1 value: This is first valueGet key1 value: This is replace valueGet key2 value: Array ( [0] =&gt; aaa [1] =&gt; bbb [2] =&gt; ccc [3] =&gt; ddd )Get key1 value:Get key2 value: 程序代码分析初始化一个Memcache的对象： $mem = new Memcache; 连接到我们的Memcache服务器端，第一个参数是服务器的IP地址，也可以是主机名，第二个参数是Memcache的开放的端口： $mem-&gt;connect(&quot;127.0.0.1&quot;,11211); 保存一个数据到Memcache服务器上，第一个参数是数据的key，用来定位一个数据，第二个参数是需要保存的数据内容，这里是一个字符串，第三个参数是一个标记，一般设置为0或者MEMCACHE_COMPRESSED就行了，第四个参数是数据的有效期，就是说数据在这个时间内是有效的，如果过去这个时间，那么会被Memcache服务器端清除掉这个数据，单位是秒，如果设置为0，则是永远有效，我们这里设置了60，就是一分钟有效时间： $mem-&gt;set(&#39;key1&#39;, &#39;This is first value&#39;, 0, 60); 从Memcache服务器端获取一条数据，它只有一个参数，就是需要获取数据的key，我们这里是上一步设置的key1，现在获取这个数据后输出输出： 12$val = $mem-&gt;get(&#x27;key1&#x27;);echo &quot;Get key1 value: &quot; . $val; 现在是使用replace方法来替换掉上面key1的值，replace方法的参数跟set是一样的，不过第一个参数key1是必须是要替换数据内容的key，最后输出了： 123$mem-&gt;replace(&#x27;key1&#x27;, &#x27;This is replace value&#x27;, 0, 60);$val = $mem-&gt;get(&#x27;key1&#x27;);echo &quot;Get key1 value: &quot; . $val; 同样的，Memcache也是可以保存数组的，下面是在Memcache上面保存了一个数组，然后获取回来并输出 12$arr = array(&#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;, &#x27;ddd&#x27;);$mem-&gt;set(&#x27;key2&#x27;, $arr, 0, 60);$val2 = $mem-&gt;get(&#x27;key2&#x27;);print_r($val2); 现在删除一个数据，使用delte接口，参数就是一个key，然后就能够把Memcache服务器这个key的数据删除，最后输出的时候没有结果 123$mem-&gt;delete(&#x27;key1&#x27;);$val = $mem-&gt;get(&#x27;key1&#x27;);echo &quot;Get key1 value: &quot; . $val . &quot;&lt;br&gt;&quot;; 最后我们把所有的保存在Memcache服务器上的数据都清除，会发现数据都没有了，最后输出key2的数据为空，最后关闭连接 12345$mem-&gt;flush();$val2 = $mem-&gt;get(&#x27;key2&#x27;);echo &quot;Get key2 value: &quot;;print_r($val2);echo &quot;&lt;br&gt;&quot;;","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"php中逗号与点号的区别","slug":"php中逗号与点号的区别","date":"2017-09-15T09:03:39.000Z","updated":"2021-04-13T07:36:48.345Z","comments":true,"path":"2017/09/15/133/","link":"","permalink":"http://github.13sai.com/2017/09/15/133/","excerpt":"","text":"前不久笔试有涉及逗号与点号的区别问题，一直没在意。 echo ‘abc’.’def’; //用点号连接字符串echo ‘abc’,’def’; //用逗号连接字符串也许很多人都知道逗号要比点号快，但是不知道为什么.更不知道这两者到底有什么区别. 那么下面我们就举一些例子 echo ‘1+5=’ . 1+5;看看上面的，输出的结果是6，而不是1+5=6.有些神奇吧? 更神奇的是你看下面的例子. 1echo &quot;1+5=&quot; . 5+1; //输出2 结果十分奇怪。我们看到，我们把5和1换下位置.结果就变成2了. 为什么会这样？难道在PHP中加法是没有交换律的?当然不是 我们先不去想为什么，如果我把上面的点号换成逗号试下. 12echo &#x27;1+5=&#x27; , 5+1; //输出 1+5=6echo &#x27;1+5=&#x27; , 1+5; //输出 1+5=6 可以看出，只有使用逗号我们才可以得到意料中的结果. 那为什么点号就不行呢?逗号为什么就行呢? 1echo (&#x27;1+5&#x27; . 5)+1; //输出2 我们给前面的加个括号后，得到的结果是一样的，证明PHP是先连接字符串再进行加法计算了，按照从左向右的方向进行的. 既然是先连接的字符串.那么就应该是”1+55”了，然后再用这个字符串加上1，那为什么就会输出2呢? 这个跟PHP中字符串变成数字的机制是相关的.我们来看下面的例子。 1234echo (int)&#x27;abc1&#x27;; //输出0echo (int)&#x27;1abc&#x27;; //输出1echo (int)&#x27;2abc&#x27;; //输出2echo (int)&#x27;22abc&#x27;; //输出22 从上面的例子我们可以看出，如果将一个字符串强制转换成一个数字，PHP会去搜索这个字符串的开头，如果开头是数字就转换，如果不是就直接返回0。 回到刚才的1+55，既然这个字符串是1+55，所以强制类型转换后就应该是1了，在此基础上加1，当然是2了。 为了证明我们的猜想，我们来验证一下. 1234echo &#x27;5+1=&#x27; . 1+5; //输出10echo &#x27;5+1=&#x27; . 5+1; //输出6echo &#x27;1+5=&#x27; . 1+5; //输出6echo &#x27;1+5=&#x27; . 5+1; //输出2 结果证明，我们的设想是正确的。 那么为什么使用逗号就没有上面的问题了呢? 手册上说了，用逗号是multiple parameters. 也就是说是多参数.换句话说，逗号分隔开的就相当于是N个参数.也就是说把echo当个函数用. 这样的话,echo会对每个参数先进行计算,最后再进行连接后输出,所以我们用逗号就不存在上面的问题了。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"PHP操作MySQL事务实例","slug":"PHP操作MySQL事务实例","date":"2017-09-15T08:52:34.000Z","updated":"2021-04-13T07:37:33.192Z","comments":true,"path":"2017/09/15/132/","link":"","permalink":"http://github.13sai.com/2017/09/15/132/","excerpt":"","text":"一般来说，事务都应该具备ACID特征。所谓ACID是Atomic（原子性），Consistent（一致性），Isolated（隔离性），Durable（持续性）四个词的首字母所写，下面以“银行转帐”为例来分别说明一下它们的含义： 原子性：组成事务处理的语句形成了一个逻辑单元，不能只执行其中的一部分。换句话说，事务是不可分割的最小单元。比如：银行转帐过程中，必须同时从一个帐户减去转帐金额，并加到另一个帐户中，只改变一个帐户是不合理的。 一致性：在事务处理执行前后，数据库是一致的。也就是说，事务应该正确的转换系统状态。比如：银行转帐过程中，要么转帐金额从一个帐户转入另一个帐户，要么两个帐户都不变，没有其他的情况。 隔离性：一个事务处理对另一个事务处理没有影响。就是说任何事务都不可能看到一个处在不完整状态下的事务。比如说，银行转帐过程中，在转帐事务没有提交之前，另一个转帐事务只能处于等待状态。 持久性：事务处理的效果能够被永久保存下来。反过来说，事务应当能够承受所有的失败，包括服务器、进程、通信以及媒体失败等等。比如：银行转帐过程中，转帐后帐户的状态要能被保存下来。 12345678910111213141516171819202122232425262728293031323334353637&lt;?php$sql1 = &quot;update User set ScoreCount = ScoreCount +10 where ID= &#x27;123456&#x27;&quot;;$sql2 = &quot;update ScoreDetail set FScore = 300 where ID= &#x27;123456&#x27;&quot;;$sql3 = &quot;insert into ScoreDetail ID,Score) values (&#x27;123456&#x27;,60)&quot;;$mysqli = new mysqli(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;&#x27;, &#x27;DB_Lib2Test&#x27;);$mysqli-&gt;autocommit(false);//开始事务$mysqli-&gt;query($sql1);$mysqli-&gt;query($sql2);if (!$mysqli-&gt;errno) &#123; $mysqli-&gt;commit(); echo &#x27;ok&#x27;;&#125; else &#123; echo &#x27;err&#x27;; $mysqli-&gt;rollback();&#125;$mysqli-&gt;autocommit(true);$sql1 = &quot;update User set ScoreCount = ScoreCount +10 where ID= &#x27;123456&#x27;&quot;;$sql2 = &quot;update ScoreDetail set FScore = 300 where ID= &#x27;123456&#x27;&quot;;$sql3 = &quot;insert into ScoreDetail ID,Score) values (&#x27;123456&#x27;,60)&quot;;$conn = mysql_connect(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;&#x27;);mysql_select_db(&#x27;test2&#x27;);mysql_query(&#x27;start transaction&#x27;);//mysql_query(&#x27;SET autocommit=0&#x27;);mysql_query($sql1);mysql_query($sql2);if (mysql_errno()) &#123; mysql_query(&#x27;rollback&#x27;); echo &#x27;err&#x27;;&#125; else &#123; mysql_query(&#x27;commit&#x27;); echo &#x27;ok&#x27;;&#125;// mysql_query(&#x27;SET autocommit=1&#x27;);// mysql_query($sql3);","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"微信模板短信","slug":"微信模板短信","date":"2017-07-25T10:06:48.000Z","updated":"2021-04-13T07:27:54.417Z","comments":true,"path":"2017/07/25/131/","link":"","permalink":"http://github.13sai.com/2017/07/25/131/","excerpt":"","text":"``` /* &nbsp;*&nbsp;发送微信模板短信 &nbsp;*&nbsp;$openid&nbsp;&nbsp;微信用户openid &nbsp;*&nbsp;$href&nbsp;&nbsp;&nbsp;&nbsp;短信链接到的网址 &nbsp;*/ function&nbsp;wx_send($openid,&nbsp;$href){ &nbsp;&nbsp;&nbsp;&nbsp;$tpl&nbsp;=&nbsp;array( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//接收者d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;touser&quot;=&gt;$openid, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这里是你要发送的模板类型id &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;template_id&quot;=&gt;&quot;uWkFcjxKGrMLdZZM3WcFEh9Tkk_Dh2bU1SICF92n-RY&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这里是点击模板跳转的页面 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;url&quot;&nbsp;=&gt;&nbsp;$href, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//标题颜色 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;topcolor&quot;&nbsp;=&gt;&nbsp;&quot;#FFAE89&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;data&quot;&nbsp;=&gt;&nbsp;array( //这里的first,keyword&nbsp;都要对应这模板里面的信息写&nbsp;颜色可自定义 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;first&quot;&nbsp;=&gt;&nbsp;array(&quot;value&quot;&nbsp;=&gt;&nbsp;&quot;购车通知&quot;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;keyword1&quot;&nbsp;=&gt;&nbsp;array(&quot;value&quot;&nbsp;=&gt;&nbsp;&quot;195800元&quot;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;keyword2&quot;&nbsp;=&gt;&nbsp;array(&quot;value&quot;&nbsp;=&gt;&nbsp;&quot;奥迪A3&nbsp;2017款&nbsp;Sportback&nbsp;35&nbsp;TFSI&nbsp;风尚型&quot;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;keyword3&quot;&nbsp;=&gt;&nbsp;array(&quot;value&quot;&nbsp;=&gt;&nbsp;&quot;南京市雨花台区&quot;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;keyword4&quot;&nbsp;=&gt;&nbsp;array(&quot;value&quot;&nbsp;=&gt;&nbsp;&quot;02588888888&quot;), //这里是通用的&nbsp;就类似与备注的存在 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;remark&quot;&nbsp;=&gt;&nbsp;array(&quot;value&quot;&nbsp;=&gt;&nbsp;&quot;支付购车款后，请尽快办理车辆过户手续&quot;,&quot;color&quot;&nbsp;=&gt;&nbsp;&quot;#FF7256&quot;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;), &nbsp;&nbsp;&nbsp;&nbsp;); &nbsp;&nbsp;&nbsp;&nbsp;$json_template&nbsp;=&nbsp;json_encode($tpl); &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$url&nbsp;=&nbsp;&quot;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=&quot;.get_access_token(); &nbsp;&nbsp;&nbsp;&nbsp;$res&nbsp;=&nbsp;json_decode(http_request($url,urldecode($json_template)),true); &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($res[&quot;errcode&quot;]&nbsp;==&nbsp;0){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;ok&quot;; &nbsp;&nbsp;&nbsp;&nbsp;}else{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;json_encode($res); &nbsp;&nbsp;&nbsp;&nbsp;} } /* &nbsp;*&nbsp;获取access_token &nbsp;*/ function&nbsp;get_access_token(){ &nbsp;&nbsp;&nbsp;&nbsp;$appid&nbsp;=&nbsp;z_get_config(&#39;wechat_appid&#39;); &nbsp;&nbsp;&nbsp;&nbsp;$appsecret&nbsp;=&nbsp;z_get_config(&#39;wechat_appsecret&#39;); &nbsp;&nbsp;&nbsp;&nbsp;$url_get=&#39;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#39;.$appid.&#39;&amp;secret=&#39;.$appsecret; &nbsp;&nbsp;&nbsp;&nbsp;$json=z_get_json($url_get); &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$json[&#39;access_token&#39;]; } function&nbsp;http_request($url,&nbsp;$data&nbsp;=&nbsp;array()) { &nbsp;&nbsp;&nbsp;&nbsp;$ch&nbsp;=&nbsp;curl_init(); &nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_URL,&nbsp;$url); &nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_RETURNTRANSFER,&nbsp;1); &nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_SSL_VERIFYPEER,&nbsp;FALSE); &nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_SSL_VERIFYHOST,&nbsp;FALSE); &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;post数据 &nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_POST,&nbsp;1); &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;把post的变量加上 &nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_POSTFIELDS,&nbsp;$data); &nbsp;&nbsp;&nbsp;&nbsp;$output&nbsp;=&nbsp;curl_exec($ch); &nbsp;&nbsp;&nbsp;&nbsp;curl_close($ch); &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$output; } function&nbsp;z_get_json($url){ &nbsp;&nbsp;&nbsp;&nbsp;$ch&nbsp;=&nbsp;curl_init(); &nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_URL,&nbsp;$url); &nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_SSL_VERIFYPEER,&nbsp;FALSE);&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_SSL_VERIFYHOST,&nbsp;FALSE);&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_RETURNTRANSFER,&nbsp;1); &nbsp;&nbsp;&nbsp;&nbsp;$output&nbsp;=&nbsp;curl_exec($ch); &nbsp;&nbsp;&nbsp;&nbsp;curl_close($ch); &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;json_decode($output,&nbsp;true); } ```","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"阿里云身份证实名认证","slug":"阿里云身份证实名认证","date":"2017-07-25T10:03:43.000Z","updated":"2020-02-28T01:41:07.290Z","comments":true,"path":"2017/07/25/130/","link":"","permalink":"http://github.13sai.com/2017/07/25/130/","excerpt":"","text":"直接上代码，使用的是阿里云的接口。 12345678910111213141516171819202122232425262728293031323334353637/* * 身份证校验 * */function sfz_verify($idcard, $name)&#123; $host = &quot;http://idcard.market.alicloudapi.com&quot;; $path = &quot;/lianzhuo/idcard&quot;; $method = &quot;GET&quot;; $appcode = z_get_config(&#x27;sfz_appcode&#x27;); $headers = array(); array_push($headers, &quot;Authorization:APPCODE &quot; . $appcode); $querys = &quot;cardno=$idcard&amp;name=$name&quot;; $bodys = &quot;&quot;; $url = $host . $path . &quot;?&quot; . $querys; $curl = curl_init(); curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $method); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_HTTPHEADER, $headers); curl_setopt($curl, CURLOPT_FAILONERROR, false); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_HEADER, true); if (1 == strpos(&quot;$&quot;.$host, &quot;https://&quot;))&#123; curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false); &#125; $output = curl_exec($curl); if (curl_getinfo($curl, CURLINFO_HTTP_CODE) == &#x27;200&#x27;) &#123; list($header, $body) = explode(&quot;\\r\\n\\r\\n&quot;, $output, 2); &#125; //dump($output); curl_close($curl); return $body;&#125; 正确返回值如下： 1234567891011&#123; &quot;resp&quot;: &#123; &quot;code&quot;: 0, &quot;desc&quot;: &quot;匹配&quot; &#125;, &quot;data&quot;: &#123; &quot;sex&quot;: &quot;男&quot;, &quot;address&quot;: &quot;广东省清远市清新县&quot;, &quot;birthday&quot;: &quot;1989-05-25&quot; &#125;&#125;","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"解决动态添加元素绑定事件在ios上面失效问题","slug":"解决动态添加元素绑定事件在ios上面失效问题","date":"2017-07-15T03:41:22.000Z","updated":"2020-12-09T10:34:18.343Z","comments":true,"path":"2017/07/15/128/","link":"","permalink":"http://github.13sai.com/2017/07/15/128/","excerpt":"","text":"当你的DOM节点是动态生成在页面上的时候。 普通的点击$(element).click()会因为获取不到dom元素而致使点击失效。这种情况下一般使用时间托管例如jq的:$(document).on(element,&#39;click&#39;,fn)这个通过事件托管可以让jquery获取到动态生成的dom节点，以此解决点击失效的问题。然而在iOS上这样的方法解决不了这个问题,原因是:在ios系统中,例如document,div,body这些本身并没有可以被点击的属性的元素不能作为托管点击事件的父元素。所以,用这样的方法进行事件托管，ios会获取不到你的document的点击事件，自然无法获取到你想要绑定的元素身上。解决办法就是把document换成你想要绑定元素的父元素上可以是最大的那个div，然后在最大元素的样式中加入cursor:pointer;&nbsp;这个属性可以让父元素变成拥有可被点击属性的盒子，这样就可以解决动态数据无法绑定事件的问题。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"ueditor远程图片本地化的实现","slug":"ueditor远程图片本地化的实现","date":"2017-07-13T02:02:31.000Z","updated":"2021-04-26T03:31:29.512Z","comments":true,"path":"2017/07/13/127/","link":"","permalink":"http://github.13sai.com/2017/07/13/127/","excerpt":"","text":"前不久客户反馈说，在秀米网上编辑好文章，发布到我们后台，前台图片无法显示，最先想到的是图片域名限制。发邮件给秀米，秀米给出的建议是类似微信后台做图片本地化。开发组内部讨论后，看到了这篇文章，UEditor编辑器如何关闭抓取远程图片本地化功能，so easy?按文章说明设置，测试,失败！百度看了下，大都是这样解答，说明应该是有人实现了，秀米编辑器核心代码也正是ueditor核心代码，那就只能自己捣鼓了。具体捣鼓过程如下：注意：捣鼓前先备份下，以备修改错误导致其他问题打开ueditor.config.js，在配置项中加入,catchRemoteImageEnable:true打开ueditor.config.js，搜索catchremoteimage，在加入console.warn(url)，看看上传地址。前台测试后看到/Skin/public/ueditor/php/controller.php?action=catchimage打开php/controller.php 可以看到case&nbsp;&#39;catchimage&#39;: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$result&nbsp;=&nbsp;include(&quot;action_crawler.php&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;接着打开统计目录下action_crawler.phpinclude(&quot;Uploader.class.php&quot;); $item&nbsp;=&nbsp;new&nbsp;Uploader($imgUrl,&nbsp;$config,&nbsp;&quot;remote&quot;);看到这两段代码。继续打开统计目录下Uploader.class.php//构造函数如下 public&nbsp;function&nbsp;__construct($fileField,&nbsp;$config,&nbsp;$type&nbsp;=&nbsp;&quot;upload&quot;) &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;fileField&nbsp;=&nbsp;$fileField;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;config&nbsp;=&nbsp;$config;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;type&nbsp;=&nbsp;$type; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($type&nbsp;==&nbsp;&quot;remote&quot;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;saveRemote(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if($type&nbsp;==&nbsp;&quot;base64&quot;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;upBase64(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;upFile(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;stateMap[&#39;ERROR_TYPE_NOT_ALLOWED&#39;]&nbsp;=&nbsp;iconv(&#39;unicode&#39;,&nbsp;&#39;utf-8&#39;,&nbsp;$this-&gt;stateMap[&#39;ERROR_TYPE_NOT_ALLOWED&#39;]); &nbsp;&nbsp;&nbsp;&nbsp;}搜索saveRemote，主要修复fileType与oriName两块。/** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;拉取远程图片 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;mixed &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/ &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;function&nbsp;saveRemote() &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$imgUrl&nbsp;=&nbsp;htmlspecialchars($this-&gt;fileField); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$imgUrl&nbsp;=&nbsp;str_replace(&quot;&amp;amp;&quot;,&nbsp;&quot;&amp;&quot;,&nbsp;$imgUrl); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//http开头验证&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strpos($imgUrl,&nbsp;&quot;http&quot;)&nbsp;!==&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;stateInfo&nbsp;=&nbsp;$this-&gt;getStateInfo(&quot;ERROR_HTTP_LINK&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preg_match(&#39;/(^https*://[^:/]+)/&#39;,&nbsp;$imgUrl,&nbsp;$matches);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$host_with_protocol&nbsp;=&nbsp;count($matches)&nbsp;&gt;&nbsp;1&nbsp;?&nbsp;$matches[1]&nbsp;:&nbsp;&#39;&#39;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;判断是否是合法&nbsp;url&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!filter_var($host_with_protocol,&nbsp;FILTER_VALIDATE_URL))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;stateInfo&nbsp;=&nbsp;$this-&gt;getStateInfo(&quot;INVALID_URL&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preg_match(&#39;/^https*://(.+)/&#39;,&nbsp;$host_with_protocol,&nbsp;$matches);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$host_without_protocol&nbsp;=&nbsp;count($matches)&nbsp;&gt;&nbsp;1&nbsp;?&nbsp;$matches[1]&nbsp;:&nbsp;&#39;&#39;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;此时提取出来的可能是&nbsp;ip&nbsp;也有可能是域名，先获取&nbsp;ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ip&nbsp;=&nbsp;gethostbyname($host_without_protocol);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;判断是否是私有&nbsp;ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!filter_var($ip,&nbsp;FILTER_VALIDATE_IP,&nbsp;FILTER_FLAG_NO_PRIV_RANGE))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;stateInfo&nbsp;=&nbsp;$this-&gt;getStateInfo(&quot;INVALID_IP&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取请求头并检测死链&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$heads&nbsp;=&nbsp;get_headers($imgUrl,&nbsp;1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!(stristr($heads[0],&nbsp;&quot;200&quot;)&nbsp;&amp;&amp;&nbsp;stristr($heads[0],&nbsp;&quot;OK&quot;)))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;stateInfo&nbsp;=&nbsp;$this-&gt;getStateInfo(&quot;ERROR_DEAD_LINK&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//格式验证(扩展名验证和Content-Type验证)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$fileType&nbsp;=&nbsp;strtolower(strrchr($imgUrl,&nbsp;&#39;.&#39;));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//13sai&nbsp;20170712&nbsp;&nbsp;秀米网链接接如下http://img.xiumi.us/xmi/ua/h4qG/i/b8f2af6986e8dba51615a9d85cc82f3b-sz_1952250.JPG?x-oss-process=style/xm&nbsp;，我们完善下&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$fileType&nbsp;=&nbsp;(strpos($fileType,&nbsp;&#39;?&#39;)&nbsp;&gt;&nbsp;0)?&nbsp;strtolower(substr($fileType,0,strpos($fileType,&#39;?&#39;)))&nbsp;:&nbsp;strtolower($fileType);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;$fileType;die();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!in_array($fileType,&nbsp;$this-&gt;config[&#39;allowFiles&#39;])&nbsp;||&nbsp;!isset($heads[&#39;Content-Type&#39;])&nbsp;||&nbsp;!stristr($heads[&#39;Content-Type&#39;],&nbsp;&quot;image&quot;))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;stateInfo&nbsp;=&nbsp;$this-&gt;getStateInfo(&quot;ERROR_HTTP_CONTENTTYPE&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//打开输出缓冲区并获取远程图片&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ob_start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$context&nbsp;=&nbsp;stream_context_create(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array(&#39;http&#39;&nbsp;=&gt;&nbsp;array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;follow_location&#39;&nbsp;=&gt;&nbsp;false&nbsp;//&nbsp;don&#39;t&nbsp;follow&nbsp;redirects&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readfile($imgUrl,&nbsp;false,&nbsp;$context);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$img&nbsp;=&nbsp;ob_get_contents();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ob_end_clean();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//13sai&nbsp;20170712&nbsp;&nbsp;此处正则有问题，修改如下&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//preg_match(&quot;//[.]?[^./]*$/&quot;,&nbsp;$imgUrl,&nbsp;$m);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preg_match(&quot;//[A-za-z0-9-]+.&quot;.$fileType.&quot;/&quot;,&nbsp;strtolower($imgUrl),&nbsp;$m);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//var_dump($m);die(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;oriName&nbsp;=&nbsp;$m&nbsp;?&nbsp;ltrim($m[0],&#39;/&#39;):&quot;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//$this-&gt;oriName&nbsp;=&nbsp;$m&nbsp;?&nbsp;$m[1]:&quot;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;$this-&gt;oriName;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//die();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;fileSize&nbsp;=&nbsp;strlen($img);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;fileType&nbsp;=&nbsp;$this-&gt;getFileExt();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;fullName&nbsp;=&nbsp;$this-&gt;getFullName();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;filePath&nbsp;=&nbsp;$this-&gt;getFilePath();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;fileName&nbsp;=&nbsp;$this-&gt;getFileName();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$dirname&nbsp;=&nbsp;dirname($this-&gt;filePath); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//检查文件大小是否超出限制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!$this-&gt;checkSize())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;stateInfo&nbsp;=&nbsp;$this-&gt;getStateInfo(&quot;ERROR_SIZE_EXCEED&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//创建目录失败&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!file_exists($dirname)&nbsp;&amp;&amp;&nbsp;!mkdir($dirname,&nbsp;0777,&nbsp;true))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;stateInfo&nbsp;=&nbsp;$this-&gt;getStateInfo(&quot;ERROR_CREATE_DIR&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(!is_writeable($dirname))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;stateInfo&nbsp;=&nbsp;$this-&gt;getStateInfo(&quot;ERROR_DIR_NOT_WRITEABLE&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//移动文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!(file_put_contents($this-&gt;filePath,&nbsp;$img)&nbsp;&amp;&amp;&nbsp;file_exists($this-&gt;filePath)))&nbsp;{&nbsp;//移动失败&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;stateInfo&nbsp;=&nbsp;$this-&gt;getStateInfo(&quot;ERROR_WRITE_CONTENT&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;//移动成功&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;stateInfo&nbsp;=&nbsp;$this-&gt;stateMap[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;}打开php/config.json，修改大小、格式、存储路径等参数/&nbsp;抓取远程图片配置&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&quot;catcherLocalDomain&quot;:&nbsp;[&quot;127.0.0.1&quot;,&nbsp;&quot;localhost&quot;,&nbsp;&quot;img.baidu.com&quot;],&nbsp;&nbsp;&nbsp;&nbsp;&quot;catcherActionName&quot;:&nbsp;&quot;catchimage&quot;,&nbsp;/&nbsp;执行抓取远程图片的action名称&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&quot;catcherFieldName&quot;:&nbsp;&quot;source&quot;,&nbsp;/&nbsp;提交的图片列表表单名称&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&quot;catcherPathFormat&quot;:&nbsp;&quot;/Upload/ueditor/image/{yyyy}{mm}{dd}/{time}{rand:6}&quot;,&nbsp;/&nbsp;上传保存路径,可以自定义保存路径和文件名格式&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&quot;catcherUrlPrefix&quot;:&nbsp;&quot;&quot;,&nbsp;/&nbsp;图片访问路径前缀&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&quot;catcherMaxSize&quot;:&nbsp;20480000,&nbsp;/&nbsp;上传大小限制，单位B&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&quot;catcherAllowFiles&quot;:&nbsp;[&quot;.png&quot;,&nbsp;&quot;.jpg&quot;,&nbsp;&quot;.jpeg&quot;,&nbsp;&quot;.gif&quot;,&nbsp;&quot;.bmp&quot;],&nbsp;/&nbsp;抓取图片格式显示&nbsp;/5.保存修改上传，测试成功！","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"csv导出导入","slug":"csv导出导入","date":"2017-05-31T03:22:24.000Z","updated":"2021-04-13T07:29:44.012Z","comments":true,"path":"2017/05/31/124/","link":"","permalink":"http://github.13sai.com/2017/05/31/124/","excerpt":"","text":"CSV（逗号分隔值文件格式）逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。通常，所有记录都有完全相同的字段序列。对于大数量的导出，csv导出的速度ko excel导出速度，而csv文件也能用excel打开，这大大提高了页面性能。唯一不好的就是csv导出不比excel导出灵活，加单元格样式、合并单元格就显示不出优势来了。我们来看看代码：&lt;?php $data&nbsp;=&nbsp;array&nbsp;( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array&nbsp;( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;姓名&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;性别&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;年龄&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;城市&#39; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array&nbsp;( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;张三&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;男&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;34岁&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;北京&#39; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array&nbsp;( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;李四&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;男&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;38岁&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;天津&#39; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array&nbsp;( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;王五&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;男&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;90岁&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;湖北&#39; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array&nbsp;( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;赵六&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;男&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;12岁&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;陕西&#39; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) ); /* &nbsp;*&nbsp;功能描述:将数组数据写入cvs文件 &nbsp;* &nbsp;*&nbsp;参数: &nbsp;*&nbsp;$data:需要写入的数组格式的数据 &nbsp;*&nbsp;$filename:csv文件的名称,如果没有确定,默认为当前时间(格式为:YmdHis) &nbsp;* &nbsp;* &nbsp;*&nbsp;*/ function&nbsp;write_csv($data&nbsp;=&nbsp;null,&nbsp;$filename&nbsp;=&nbsp;null)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!&nbsp;($data&nbsp;||&nbsp;$filename))&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;$fp&nbsp;=&nbsp;fopen&nbsp;(&nbsp;$filename&nbsp;,&nbsp;&#39;w&#39;&nbsp;); &nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(&nbsp;$data&nbsp;as&nbsp;$fields&nbsp;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fputcsv&nbsp;(&nbsp;$fp,&nbsp;$fields&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;fclose&nbsp;(&nbsp;$fp&nbsp;);}/*&nbsp;&nbsp;功能描述:不写入cvs文件,并且输出的到浏览器&nbsp;&nbsp;&nbsp;参数:&nbsp;&nbsp;$data:需要写入的数组格式的数据&nbsp;&nbsp;$filename:csv文件的名称,如果没有确定,默认为当前时间(格式为:YmdHis)&nbsp;&nbsp;*&nbsp;&nbsp;/function&nbsp;output_csv($data&nbsp;=&nbsp;null,&nbsp;$filename&nbsp;=&nbsp;null)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!&nbsp;($data&nbsp;||&nbsp;$filename))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;header(&#39;Content-Type:application/force-download&#39;);&nbsp;&nbsp;&nbsp;&nbsp;header(&quot;content-Disposition:attachment;filename={$filename}&quot;); &nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(&nbsp;$data&nbsp;as&nbsp;$fields&nbsp;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;($fields&nbsp;as&nbsp;$value){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$value.&#39;,&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;}}/*&nbsp;&nbsp;功能描述:读取cvs文件&nbsp;&nbsp;&nbsp;参数:&nbsp;&nbsp;$filename:要读取的csv文件的名称&nbsp;*&nbsp;*&nbsp;&nbsp;/function&nbsp;read_csv($filename=null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if(!$filename){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;$handle=fopen($filename,&#39;r&#39;);&nbsp;&nbsp;&nbsp;&nbsp;if(!$handle){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;&lt;meta&nbsp;charset=&#39;utf-8&#39;/&gt;&quot;; &nbsp;&nbsp;&nbsp;&nbsp;$row=1;&nbsp;&nbsp;&nbsp;&nbsp;while($data=fgetcsv($handle,1000,&quot;,&quot;)){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$num=count($data);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;&lt;br&gt;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;&quot;&lt;h1&gt;&nbsp;&nbsp;第&nbsp;$row&nbsp;行&nbsp;,共有&nbsp;$num&nbsp;个字段&nbsp;&lt;br&nbsp;/&gt;&lt;/h1&gt;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$row&nbsp;++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;($c=0;$c&lt;$num;$c++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$data[$c].&quot; &quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;} }/*&nbsp;&nbsp;功能描述:读取cvs文件,输出到浏览器,采用file_get_contents处理&nbsp;&nbsp;&nbsp;参数:&nbsp;&nbsp;$filename:要读取的csv文件的名称&nbsp;*&nbsp;*&nbsp;&nbsp;/function&nbsp;read_output_file_get_contents($filename=null){&nbsp;&nbsp;&nbsp;&nbsp;if(!$filename){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;header(&#39;Content-Type:application/force-download&#39;);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;header(&quot;content-Disposition:filename={$filename}&quot;); &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;file_get_contents($filename);}/*&nbsp;&nbsp;功能描述:读取cvs文件,输出到浏览器,采用fopen处理&nbsp;&nbsp;&nbsp;参数:&nbsp;&nbsp;$filename:要读取的csv文件的名称&nbsp;*&nbsp;*&nbsp;&nbsp;/function&nbsp;read_output_fopen($filename=null){&nbsp;&nbsp;&nbsp;&nbsp;if(!$filename){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;$file_handle&nbsp;=&nbsp;fopen($filename,&nbsp;&quot;r&quot;);&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;&lt;meta&nbsp;charset=&#39;utf-8&#39;/&gt;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(!feof($file_handle))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$line&nbsp;=&nbsp;fgets($file_handle);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$line.&#39;&lt;br/&gt;&#39;;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fclose($file_handle);} //&nbsp;output_csv($data,&#39;ggg.xls&#39;);//output_csv($data,&#39;ggg.csv&#39;); //&nbsp;read_csv(&#39;ggg.csv&#39;); //read_output_file_get_contents(&#39;ggg.csv&#39;); //&nbsp;read_output_fopen(&#39;ggg.csv&#39;);简单明了，无需多言。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"js浮点数计算误差bug","slug":"js浮点数计算误差bug","date":"2017-05-24T06:04:14.000Z","updated":"2021-04-13T07:31:24.987Z","comments":true,"path":"2017/05/24/123/","link":"","permalink":"http://github.13sai.com/2017/05/24/123/","excerpt":"","text":"最近在做项目测试时，用到了JS浮点数计算，0.2+0.1结果为0.30000000000000004。因为都是取一位小数，就把计算后面加了个toFixed(1).虽然解决了问题，但还是详细看了下其中缘由。计算机中的浮点数：浮点指的是带有小数的数值，浮点运算即是小数的四则运算，常用来测量电脑运算速度。大部份计算机采用二進制（b=2）的表示方法。位(bit)是衡量浮点数所需存储空间的单位，通常为32位或64位，分别被叫作单精度和双精度。误差现象： console.log(0.1+0.2);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出&nbsp;0.30000000000000004console.log(0.15+0.15);&nbsp;&nbsp;//&nbsp;输出&nbsp;0.3 console.log(0.7+0.1);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出&nbsp;0.7999999999999999console.log(0.6+0.2);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出&nbsp;0.8 console.log(0.3*3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出&nbsp;0.8999999999999999console.log(3*3/10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出&nbsp;0.9从以上现象可以看出，并不是所有的浮点数运算都会出问题，只是部分。0.7+0.1&nbsp;输出有偏差0.6+0.2&nbsp;输出正确具体是什么原因呢？误差原因：不仅在 JavaScript 中存在这个「问题」，所有的支持二进制浮点数运算（绝大部分都是 IEEE 754[1] 的实现）的系统都存在这个现象。其原因就是，在有限的存储空间下，绝大部分的十进制小数都不能用二进制浮点数来精确表示。例如，0.1 这个简单的十进制小数就不能用二进制浮点数来表示。所谓「计算机浮点数」，其实就是二进制的「科学计数法」。在十进制中，科学计数法的形式是：相应的，二进制的科学计数法就是：而在有限的存储空间下，十进制小数 0.1 无论如何也不能用这种形式来表示，因此，计算机在存储它时，产生了精度丢失，所以就出现了问题中所描述的现象。二进制浮点数具体的储存、运算细节，可以查阅现在应用最广的 IEEE 754。解决方案：如何解决呢？看这个例子： console.log(0.3*3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出&nbsp;0.8999999999999999console.log(3*3/10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出&nbsp;0.9浮点数计算有问题，整数计算是没问题的，那么将浮点转化成正数运算，之后再切回浮点就可以保证没有偏差了注：不推荐js做太多的浮点运算。以下方法可以帮助你修正浮点运算的偏差：//&nbsp;浮点数求和function&nbsp;add(a,&nbsp;b)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c,&nbsp;d,&nbsp;e; &nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;a.toString().split(&quot;.&quot;)[1].length; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(f)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;b.toString().split(&quot;.&quot;)[1].length; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(f)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;0; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;e&nbsp;=&nbsp;Math.pow(10,&nbsp;Math.max(c,&nbsp;d)),&nbsp;(mul(a,&nbsp;e)&nbsp;+&nbsp;mul(b,&nbsp;e))&nbsp;/&nbsp;e; }&nbsp; //&nbsp;浮点数相减function&nbsp;sub(a,&nbsp;b)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c,&nbsp;d,&nbsp;e; &nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;a.toString().split(&quot;.&quot;)[1].length; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(f)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;b.toString().split(&quot;.&quot;)[1].length; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(f)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;0; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;e&nbsp;=&nbsp;Math.pow(10,&nbsp;Math.max(c,&nbsp;d)),&nbsp;(mul(a,&nbsp;e)&nbsp;-&nbsp;mul(b,&nbsp;e))&nbsp;/&nbsp;e; }&nbsp; //&nbsp;浮点数相乘function&nbsp;mul(a,&nbsp;b)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;=&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;a.toString(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;=&nbsp;b.toString(); &nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;+=&nbsp;d.split(&quot;.&quot;)[1].length; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(f)&nbsp;{} &nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;+=&nbsp;e.split(&quot;.&quot;)[1].length; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(f)&nbsp;{}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Number(d.replace(&quot;.&quot;,&nbsp;&quot;&quot;))&nbsp;*&nbsp;Number(e.replace(&quot;.&quot;,&nbsp;&quot;&quot;))&nbsp;/&nbsp;Math.pow(10,&nbsp;c); }&nbsp; //&nbsp;浮点数相除function&nbsp;div(a,&nbsp;b)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c,&nbsp;d,&nbsp;e&nbsp;=&nbsp;0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;0; &nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;=&nbsp;a.toString().split(&quot;.&quot;)[1].length; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(g)&nbsp;{} &nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;b.toString().split(&quot;.&quot;)[1].length; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(g)&nbsp;{}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;c&nbsp;=&nbsp;Number(a.toString().replace(&quot;.&quot;,&nbsp;&quot;&quot;)),&nbsp;d&nbsp;=&nbsp;Number(b.toString().replace(&quot;.&quot;,&nbsp;&quot;&quot;)),&nbsp;mul(c&nbsp;/&nbsp;d,&nbsp;Math.pow(10,&nbsp;f&nbsp;-&nbsp;e)); }验证：console.log(0.1+0.2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出&nbsp;0.30000000000000004console.log(add(0.1,&nbsp;0.2));&nbsp;&nbsp;//&nbsp;输出&nbsp;0.3 console.log(0.7+0.1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出&nbsp;0.7999999999999999console.log(add(0.7,&nbsp;0.1));&nbsp;&nbsp;//&nbsp;输出&nbsp;0.8 console.log(0.3*3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出&nbsp;0.8999999999999999console.log(mul(0.3,&nbsp;3));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出&nbsp;0.9采用优化方法后计算的结果都是正确的。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"利用formdata提交表单","slug":"利用formdata提交表单","date":"2017-05-11T13:38:44.000Z","updated":"2019-11-27T10:29:17.478Z","comments":true,"path":"2017/05/11/121/","link":"","permalink":"http://github.13sai.com/2017/05/11/121/","excerpt":"","text":"XMLHttpRequest Level 2 添加了一个新的接口——FormData。利用 FormData&nbsp;对象，我们可以通过&nbsp;JavaScript;用一些键值对来模拟一系列表单控件，我们还可以使用 XMLHttpRequest 的 send()&nbsp;方法来异步的提交表单。与普通的 Ajax 相比，使用 FormData&nbsp;的最大优点就是我们可以异步上传二进制文件。直接上实例：&lt;form&nbsp;id=&quot;artCreateForm&quot;&nbsp;action=&quot;{:U(&#39;artCreate&#39;)}&quot;&nbsp;method=&quot;POST&quot;&nbsp;enctype=&quot;multipart/form-data&quot;&nbsp;class=&quot;form-horizontal&quot;&nbsp;role=&quot;form&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;hidden&quot;&nbsp;name=&quot;column_id&quot;&nbsp;value=&quot;{$artColumn}&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;col-sm-3&nbsp;control-label&nbsp;no-padding-right&quot;&nbsp;for=&quot;form-field-1&quot;&gt;&nbsp;标题&nbsp;&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;col-sm-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;art_name&quot;&nbsp;placeholder=&quot;标题&quot;&nbsp;class=&quot;col-xs-10&nbsp;col-sm-5&nbsp;validate[required,maxSize[128]]&quot;&nbsp;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;col-sm-3&nbsp;control-label&nbsp;no-padding-right&quot;&nbsp;for=&quot;form-field-1&quot;&gt;&nbsp;所属分类&nbsp;&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;col-sm-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;select&nbsp;name=&quot;art_category_id&quot;&nbsp;id=&quot;art_category_id&quot;&nbsp;class=&quot;&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option&nbsp;value=&quot;1&quot;&gt;默认分类&lt;/option&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;volist&nbsp;name=&quot;categoryList&quot;&nbsp;id=&quot;vo&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option&nbsp;value=&quot;{$vo.cate_id}&quot;&gt;{$vo.cate_name}&lt;/option&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/volist&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/select&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;col-sm-3&nbsp;control-label&nbsp;no-padding-right&quot;&nbsp;for=&quot;form-field-1&quot;&gt;&nbsp;摘要&nbsp;&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;col-sm-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;textarea&nbsp;class=&quot;form-control&quot;&nbsp;name=&quot;art_summary&quot;&nbsp;placeholder=&quot;摘要&quot;&gt;&lt;/textarea&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;col-sm-3&nbsp;control-label&nbsp;no-padding-right&quot;&nbsp;for=&quot;form-field-1&quot;&gt;&nbsp;缩略图&nbsp;&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;col-sm-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;class=&quot;preview&quot;&nbsp;type=&quot;file&quot;&nbsp;name=&quot;art_thumb&quot;&nbsp;value=&quot;&quot;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;class=&quot;&quot;&nbsp;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;col-sm-3&nbsp;control-label&nbsp;no-padding-right&quot;&nbsp;for=&quot;form-field-1&quot;&gt;&nbsp;相关附件&nbsp;&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;col-sm-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;file&quot;&nbsp;name=&quot;art_upload_file&quot;&nbsp;value=&quot;&quot;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;col-sm-3&nbsp;control-label&nbsp;no-padding-right&quot;&nbsp;for=&quot;form-field-1&quot;&gt;&nbsp;内容&nbsp;&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;col-sm-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/plain&quot;&nbsp;id=&quot;art_content&quot;&nbsp;name=&quot;art_content&quot;&nbsp;style=&quot;width:90%;height:240px;&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;col-sm-3&nbsp;control-label&nbsp;no-padding-right&quot;&nbsp;for=&quot;form-field-1&quot;&gt;&nbsp;排序&nbsp;&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;col-sm-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;art_order&quot;&nbsp;value=&quot;0&quot;&nbsp;placeholder=&quot;排序&quot;&nbsp;class=&quot;col-xs-10&nbsp;col-sm-5&nbsp;validate[required,custom[integer]]&quot;&nbsp;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&nbsp;class=&quot;help-inline&nbsp;col-xs-12&nbsp;col-sm-7&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&nbsp;class=&quot;middle&quot;&gt;默认为0，数值越大越靠前&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;col-sm-3&nbsp;control-label&nbsp;no-padding-right&quot;&nbsp;for=&quot;form-field-1&quot;&gt;&nbsp;点击次数&nbsp;&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;col-sm-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;art_view_number&quot;&nbsp;value=&quot;0&quot;&nbsp;placeholder=&quot;点击次数&quot;&nbsp;class=&quot;col-xs-10&nbsp;col-sm-5&nbsp;validate[required,custom[integer]]&quot;&nbsp;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;col-sm-3&nbsp;control-label&nbsp;no-padding-right&quot;&nbsp;for=&quot;form-field-1&quot;&gt;&nbsp;发布时间&nbsp;&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;col-sm-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;art_post_time&quot;&nbsp;value=&quot;&lt;?php&nbsp;echo&nbsp;date(&#39;Y-m-d&nbsp;H:i:s&#39;,time());?&gt;&quot;&nbsp;onClick=&quot;WdatePicker({dateFmt:&#39;yyyy-MM-dd&nbsp;HH:mm:ss&#39;})&quot;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;clearfix&nbsp;form-actions&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;col-md-offset-3&nbsp;col-md-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;class=&quot;btn&nbsp;btn-info&quot;&nbsp;id=&quot;confirm&quot;&nbsp;type=&quot;button&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i&nbsp;class=&quot;icon-ok&nbsp;bigger-110&quot;&gt;&lt;/i&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提交 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/button&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp;&nbsp;&amp;nbsp;&nbsp;&amp;nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;class=&quot;btn&quot;&nbsp;id=&quot;backid&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i&nbsp;class=&quot;icon-undo&nbsp;bigger-110&quot;&gt;&lt;/i&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回列表 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &lt;/form&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;配置文件&nbsp;--&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=&quot;/webui/ueditor/ueditor.config.js&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;编辑器源码文件&nbsp;--&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=&quot;/webui/ueditor/ueditor.all.js&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(function&nbsp;()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;ue&nbsp;=&nbsp;UE.getEditor(&#39;art_content&#39;,&nbsp;{}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*返回列表*/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&quot;#backid&quot;).on(&#39;click&#39;,function(){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.location.href=&quot;{:U(&#39;artList&#39;,array(&#39;column_id&#39;=&gt;$artColumn))}&quot;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#confirm&#39;).on(&#39;click&#39;,function(){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!$(&#39;#artCreateForm&#39;).validationEngine(&#39;validate&#39;))&nbsp;return&nbsp;false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;$This&nbsp;=&nbsp;$(this); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$This.attr(&#39;disabled&#39;,&#39;disabled&#39;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;formData&nbsp;=&nbsp;new&nbsp;FormData($(&quot;#artCreateForm&quot;)[0]);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;iUrl&nbsp;=&nbsp;&#39;{:U(&#39;artCreate&#39;)}&#39;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$.ajax({ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url:&nbsp;iUrl, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&#39;POST&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;formData, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataType:&nbsp;&#39;JSON&#39;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache:&nbsp;false, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processData:&nbsp;false, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contentType:&nbsp;false&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).done(function(ret){&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ret.code){&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sysTips(ret.info,1,function(){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location.href=&quot;{:U(&#39;artList&#39;,array(&#39;column_id&#39;=&gt;$artColumn))}&quot;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sysTips(ret.info,2);&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$This.removeAttr(&#39;disabled&#39;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}); &nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"html","slug":"html","permalink":"http://github.13sai.com/tags/html/"}]},{"title":"数据库设计的范式与反范式","slug":"数据库设计的范式与反范式","date":"2017-05-02T14:50:44.000Z","updated":"2021-04-13T07:27:26.107Z","comments":true,"path":"2017/05/02/120/","link":"","permalink":"http://github.13sai.com/2017/05/02/120/","excerpt":"","text":"之前有些过关于数据库设计范式的总结文章，其实很多时候，实际操作时并非完全遵循范式去设计数据库。通常在设计数据库时需要遵循以下原则：核心业务使用范式。在类似交易有关的这种敏感和核心业务中，强调数据安全和一致性，需要遵循范式保证机密数据不被破坏，核心业务不出现不一致的情况。什么样的业务才能叫核心业务，这个需要根据实际情况而定。弱一致性需求------反ACID。在对一些数据一致性要求不高的场合，不必完全遵循ACID，出现适当的数据不一致时可以容忍的。如在线人数统计等。最近几年流行的NoSQL技术，就是基于弱一致性需求，降低数据完整性和一致性换取效率的。空间换时间，冗余换效率。由于一条可见记录被拆分到了多个表中进行记录，当数据量比较大的时候，联表查询就变得比较费时，SQL语句也变得复杂，难于优化。此时就需要适当的冗余了。就拿前不久做的考试系统导出学生信息与答题明细时，一共需要联查6个表，这是非常耗时的。我们后面试着在考完试之后，把这些需要导出的信息统一放进一张新表，导出时的查询效率大大提升。避免不必要的冗余。范式理论不是想反就能反的，反范式不是说不要范式，而是在必要的时候创建冗余表或总结表。不必要的冗余仍然是要避免的。所有的原则都是有使用场景的，我们不应该固守规则，在某些情况，要懂得变通。就如做人一样，不能墨守成规，要学会变通。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]},{"title":"wamp一直橙色，而80端口又未被占用","slug":"wamp一直橙色，而80端口又未被占用","date":"2017-04-13T15:12:53.000Z","updated":"2021-04-26T03:31:51.683Z","comments":true,"path":"2017/04/13/119/","link":"","permalink":"http://github.13sai.com/2017/04/13/119/","excerpt":"","text":"因为前几天把电脑系统玩崩了，又得重装wamp，这次发现wamp安装后一直是橙色，apache一直没有正常启动。经测试，80端口未被占用，百度很多解决方案，都没有解决问题，最后在豆瓣看到一个解决方案。apache-&gt;services-&gt;安装服务，安装成功后，重启，久违的绿。后来想了想，应该还是网络设置问题，因为安装的时候跳出启动服务的提示。总算是解决了，心情舒畅。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"wamp","slug":"wamp","permalink":"http://github.13sai.com/tags/wamp/"}]},{"title":"mouseover,mouseout,mouseenter,mouseleave的区别","slug":"mouseover,mouseout,mouseenter,mouseleave的区别","date":"2017-04-05T06:00:53.000Z","updated":"2021-04-13T07:32:53.568Z","comments":true,"path":"2017/04/05/117/","link":"","permalink":"http://github.13sai.com/2017/04/05/117/","excerpt":"","text":"mouseover与mouseenter:不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。 只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。mouseout与mouseleave:不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。 只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"windows7搭建PHP开发环境","slug":"windows7搭建PHP开发环境","date":"2017-03-09T13:38:29.000Z","updated":"2021-04-13T07:34:23.251Z","comments":true,"path":"2017/03/09/111/","link":"","permalink":"http://github.13sai.com/2017/03/09/111/","excerpt":"","text":"上个月电脑突然连不上无线网了，便又一次重装了系统，恰好之前主管介绍过windows搭建PHP环境，便考虑操作一下。主管的文档很详尽，但安装是确实遇到了其他问题，便记录下。安装PHPphp-5.3.29-nts-Win32-VC9-x86.zip解析到E:\\PHP\\PHP5.3.29下，并创建temp和sessions两个目录；&nbsp;给文件夹PHP5.2.29加上users组的读写权限；将php_5.3.29.ini文件名改为php.ini并复制到E:\\PHP\\PHP5.3.29下；添加环境变量，右击计算机选择属性---打开系统属性---高级---环境变量---在系统变量一栏中选择Path点击编辑，加上E:\\PHP\\PHP5.3.29，注意有分号；而后在点击新建，变量名填写PHPRC，变量值添加E:\\PHP\\PHP5.3.29安装下vcredist_x86.exe；（这步骤一定不能省，装的是window7旗舰版，不知道为啥安装个*86的）WIN+R打开运行窗口，输cmd打开批处理窗口，输入php -v&nbsp;如果能显示版本号说明环境配置成功。这里添加权限与配置环境变量就不详细说明了，百度一下你就知道。2.配置IISwindows7旗舰版自带的是IIS6.0，记得要打开IIS服务，并勾选对应服务（尤其注意万维网服务下面应用程序开发功能里的CGI务必打开）添加PHP映射，打开IIS，打开处理程序映射；点击添加模块映射，请求路径”输入*.php，“模块”选择FastCgiModule，“可执行文件”选择PHP存放目录下的php-cgi.exe，注意，选择时需要将筛选后缀由*.dll改为*.exe，“名称”处输入相应的标示。3.安装MYSQL根据系统版本选择对应的安装包，将MYSQL安装包解压后，将my.ini文件复制到根目录下；输入cmd打开窗口，进入mysql文件夹下的bin目录下。例如演示的是解压在E:PHP\\mysql-5.6.17-winx64，就参考如下操作；输入mysqld.exe&nbsp;install MYSQL&nbsp;--defaults-file=&quot;D:\\mysql-5.6.17-winx64\\my.ini&quot;，回车后会提示有success的提示；安装成功后直接用命令启动即可，还是之前的cmd窗口，输入net start mysql启动服务此处我输入命令时提示Install/Remove of the Service Denied，如果你也遇到，请以管理员身份运行cmd，然后运行命令，就会看到success了。三步我们就搭建好了PHP开发环境：IIS+MYSQL+PHP。打开浏览器输入127.0.0.1你可以看到What&#39;s wrong?打开C:\\inetpub\\wwwroot,新建php文件test.php输入&lt;?php echo(&#39;Good&nbsp;job!&#39;); ?&gt;浏览器输入127.0.0.0.1/test.php，你就会看到干得不错！","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"php图片上加文字","slug":"php图片上加文字","date":"2017-03-07T01:16:56.000Z","updated":"2021-04-13T07:37:01.036Z","comments":true,"path":"2017/03/07/110/","link":"","permalink":"http://github.13sai.com/2017/03/07/110/","excerpt":"","text":"最近需要使用PHP合成证书图片，便于用户保存，就考虑使用的php的GD库，在图片上加文字。原理比较简单，请看代码：&lt;?php //指定图片路径 $src&nbsp;=&nbsp;&#39;time.jpg&#39;; //获取图片信息 $info&nbsp;=&nbsp;getimagesize($src); //获取图片扩展名 $type&nbsp;=&nbsp;image_type_to_extension($info[2],false); //动态的把图片导入内存中$image&nbsp;=&nbsp;imagecreatefromjpeg($src); //文字颜色$col2&nbsp;=&nbsp;imagecolorallocate($image,500,100,0); //指定字体内容与字体$content&nbsp;=&nbsp;&quot;小清新&quot;;$font&nbsp;=&nbsp;&#39;C:\\Windows\\Fonts\\simfang.ttf&#39;; //给图片添加文字imagefttext($image,24,0,80,180,$col2,$font,$content); //指定输入类型header(&quot;Content-type:&quot;.$info[&#39;mime&#39;]);imagejpeg($image);//保存图片&nbsp;&nbsp;imagejpeg($image,&#39;12.jpg&#39;);imagedestroy($image);?&gt;注意：中文要用imagefttext，并指定的字体要支持中文。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"关于ThinkPHP的几个跨模块或项目的问题","slug":"关于ThinkPHP的几个跨模块或项目的问题","date":"2017-03-02T08:32:50.000Z","updated":"2021-04-26T03:41:39.666Z","comments":true,"path":"2017/03/02/100/","link":"","permalink":"http://github.13sai.com/2017/03/02/100/","excerpt":"","text":"最近同事TP开发时遇到引入不同项目模板文件的问题，查找后发现可以这么用： 1&lt;include file=&quot;主题名@模块名:操作名&quot; /&gt; demo: 1&lt;include file=&quot;Home@Index:index&quot; /&gt; 然而，需要引用Tpl里面的公共文件，这就闹腾了，后面脑洞大开，写成了这样。 1&lt;include file=&quot;Home@:header&quot; /&gt; 目录结构如下：Admin/Index/index引入Home公共Tpl下的header 此外想到不同模块掉方法的方法A，也是十分常见的。 12语法：A(&#x27;[项目://][分组/]模块&#x27;,&#x27;控制器层名称&#x27;) 用起来也很好。 就是这些了，这就是不同项目调用模板与调用方法的方法。 注意：我用的是3.1，其他版本可能略有不同。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://github.13sai.com/tags/ThinkPHP/"}]},{"title":"移动端定位","slug":"移动端定位","date":"2017-02-16T07:29:18.000Z","updated":"2021-04-13T07:28:55.458Z","comments":true,"path":"2017/02/16/99/","link":"","permalink":"http://github.13sai.com/2017/02/16/99/","excerpt":"","text":"去年年底，有个O2O的项目，需要手机定位，之前定位都是根据ip定位，只能精确到地级市，可客户怎么着也要定位到区县一级，不得不做一些改进。当时正好有另一个网站，用到了手机定位，而且经度不错，copy了代码，够此项目使用了。后面搞技术分享的时候就考虑说下这个问题，便整理了下。思路：获取经纬度，进行逆向地址解析。方法：微信jssdk。（只能用于微信）使用浏览器geolocation获取经纬度，百度api逆地址解析。（ios对geolocation并不友好）腾讯地图提供的前端定位api。baidumap &lt;html&gt;&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;http-equiv=&quot;Content-Type&quot;&nbsp;content=&quot;text/html;&nbsp;charset=utf-8&quot;&nbsp;/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;name=&quot;viewport&quot;&nbsp;content=&quot;initial-scale=1.0,&nbsp;user-scalable=no&quot;&nbsp;/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;style&nbsp;type=&quot;text/css&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body,&nbsp;html{width:&nbsp;100%;height:&nbsp;100%;margin:0;font-family:&quot;微软雅黑&quot;;font-size:14px;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#allmap&nbsp;{width:100%;height:500px;}&nbsp;&nbsp;&nbsp;&nbsp;&lt;/style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=NAmyvPsMlhSHds2GfAGEvAB76blt1G4j&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;百度地图–逆地址解析&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&nbsp;id=&quot;demo&quot;&gt;&lt;/div&gt;&lt;div&nbsp;id=&quot;detail&quot;&gt;&lt;/div&gt;&lt;button&nbsp;onclick=&quot;getLocation()&quot;&gt;点击定位&lt;/button&gt;注意：ios10以上暂不支持geolocation&lt;div&nbsp;id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;script&gt;var&nbsp;x=document.getElementById(&quot;demo&quot;);var&nbsp;d=document.getElementById(&quot;detail&quot;);function&nbsp;getLocation(){&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(navigator.geolocation){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigator.geolocation.getCurrentPosition(showPosition);&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.innerHTML=&quot;Geolocation&nbsp;is&nbsp;not&nbsp;supported&nbsp;by&nbsp;this&nbsp;browser.&quot;;&nbsp;&nbsp;&nbsp;&nbsp;}}function&nbsp;showPosition(pos){&nbsp;&nbsp;x.innerHTML=&quot;Latitude:&nbsp;&quot;&nbsp;+&nbsp;pos.coords.latitude&nbsp;+&nbsp;&nbsp;&nbsp;&quot;&lt;br&nbsp;/&gt;Longitude:&nbsp;&quot;&nbsp;+&nbsp;pos.coords.longitude;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;百度地图API功能&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;map&nbsp;=&nbsp;new&nbsp;BMap.Map(&quot;allmap&quot;);&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;point&nbsp;=&nbsp;new&nbsp;BMap.Point(pos.coords.longitude,pos.coords.latitude);&nbsp;&nbsp;&nbsp;&nbsp;map.centerAndZoom(point,10);&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;geoc&nbsp;=&nbsp;new&nbsp;BMap.Geocoder();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;geoc.getLocation(point,&nbsp;function(rs){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;addComp&nbsp;=&nbsp;rs.addressComponents;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.innerHTML&nbsp;=&nbsp;addComp.province&nbsp;+&nbsp;&quot;,&nbsp;&quot;&nbsp;+&nbsp;addComp.city&nbsp;+&nbsp;&quot;,&nbsp;&quot;&nbsp;+&nbsp;addComp.district&nbsp;+&nbsp;&quot;,&nbsp;&quot;&nbsp;+&nbsp;addComp.street&nbsp;+&nbsp;&quot;,&nbsp;&quot;&nbsp;+&nbsp;addComp.streetNumber;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.addEventListener(&quot;touchend&quot;,&nbsp;function(e){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;pt&nbsp;=&nbsp;e.point;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;geoc.getLocation(pt,&nbsp;function(rs){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;addComp&nbsp;=&nbsp;rs.addressComponents;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.innerHTML&nbsp;=&nbsp;addComp.province&nbsp;+&nbsp;&quot;,&nbsp;&quot;&nbsp;+&nbsp;addComp.city&nbsp;+&nbsp;&quot;,&nbsp;&quot;&nbsp;+&nbsp;addComp.district&nbsp;+&nbsp;&quot;,&nbsp;&quot;&nbsp;+&nbsp;addComp.street&nbsp;+&nbsp;&quot;,&nbsp;&quot;&nbsp;+&nbsp;addComp.streetNumber;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;qqmap &lt;!DOCTYPE&nbsp;html&gt;&lt;html&gt;&nbsp;&lt;head&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;http-equiv=&quot;Content-Type&quot;&nbsp;content=&quot;text/html;&nbsp;charset=UTF-8&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;前端定位模块–腾讯地图&lt;/title&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;name=&quot;viewport&quot;&nbsp;content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;margin:&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding:&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;border:&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position:&nbsp;absolute;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;100%;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;100%;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text-align:&nbsp;center;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pos-area&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-color:&nbsp;#009DDC;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;margin-top:&nbsp;10px;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;100%;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overflow:&nbsp;scroll;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text-align:&nbsp;left;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;white;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#demo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding:&nbsp;8px;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font-size:&nbsp;small;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#btn-area&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;100px;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;margin-bottom:&nbsp;10px;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding:&nbsp;12px&nbsp;8px;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;42%;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;border-radius:&nbsp;8px;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-color:&nbsp;#009DDC;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color:&nbsp;white;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&lt;/style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=&quot;https://3gimg.qq.com/lightmap/components/geolocation/geolocation.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;btn-area&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;onclick=&quot;geolocation.getLocation(showPosition,&nbsp;showErr,&nbsp;options)&quot;&gt;获取精确定位信息&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;onclick=&quot;geolocation.getIpLocation(showPosition,&nbsp;showErr)&quot;&gt;获取粗糙定位信息&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;onclick=&quot;showWatchPosition()&quot;&gt;开始监听位置&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;onclick=&quot;showClearWatch()&quot;&gt;停止监听位置&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;pos-area&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&nbsp;id=&quot;demo&quot;&gt;点击上面的按钮，获得对应信息：&lt;br&nbsp;/&gt;&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/JavaScript&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;geolocation&nbsp;=&nbsp;new&nbsp;qq.maps.Geolocation(&quot;OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-WPB77&quot;,&nbsp;&quot;myapp&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(&quot;pos-area&quot;).style.height&nbsp;=&nbsp;(document.body.clientHeight&nbsp;-&nbsp;110)&nbsp;+&nbsp;&#39;px&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;positionNum&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;options&nbsp;=&nbsp;{timeout:&nbsp;8000};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;showPosition(position)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;positionNum&nbsp;++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(&quot;demo&quot;).innerHTML&nbsp;+=&nbsp;&quot;序号：&quot;&nbsp;+&nbsp;positionNum;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(&quot;demo&quot;).appendChild(document.createElement(&#39;pre&#39;)).innerHTML&nbsp;=&nbsp;JSON.stringify(position,&nbsp;null,&nbsp;4);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(&quot;pos-area&quot;).scrollTop&nbsp;=&nbsp;document.getElementById(&quot;pos-area&quot;).scrollHeight;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;showErr()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;positionNum&nbsp;++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(&quot;demo&quot;).innerHTML&nbsp;+=&nbsp;&quot;序号：&quot;&nbsp;+&nbsp;positionNum;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(&quot;demo&quot;).appendChild(document.createElement(&#39;p&#39;)).innerHTML&nbsp;=&nbsp;&quot;定位失败！&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(&quot;pos-area&quot;).scrollTop&nbsp;=&nbsp;document.getElementById(&quot;pos-area&quot;).scrollHeight;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;showWatchPosition()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(&quot;demo&quot;).innerHTML&nbsp;+=&nbsp;&quot;开始监听位置！&lt;br&nbsp;/&gt;&lt;br&nbsp;/&gt;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;geolocation.watchPosition(showPosition);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(&quot;pos-area&quot;).scrollTop&nbsp;=&nbsp;document.getElementById(&quot;pos-area&quot;).scrollHeight;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;showClearWatch()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;geolocation.clearWatch();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(&quot;demo&quot;).innerHTML&nbsp;+=&nbsp;&quot;停止监听位置！&lt;br&nbsp;/&gt;&lt;br&nbsp;/&gt;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(&quot;pos-area&quot;).scrollTop&nbsp;=&nbsp;document.getElementById(&quot;pos-area&quot;).scrollHeight;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;更多请参考：geolocation：https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation/Using_geolocationhttp://www.w3school.com.cn/html5/html_5_geolocation.asp百度地图api：http://developer.baidu.com/map/jsdemo.htm#i7_2腾讯地图api：http://lbs.qq.com/tool/component-geolocation.html","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"python爬虫","slug":"python爬虫","date":"2017-01-14T01:59:32.000Z","updated":"2021-04-13T07:36:42.072Z","comments":true,"path":"2017/01/14/98/","link":"","permalink":"http://github.13sai.com/2017/01/14/98/","excerpt":"","text":"最近在玩Python，自己平时喜欢和同事看电影，就寻思写了个爬虫来定时爬取优惠电影。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# author: 13sai # code: utf-8 from urllib.request import urlopen from bs4 import BeautifulSoup import re import datetime now = datetime.datetime.now() week = now.weekday() if week &lt; 5: week = 4 - week else: week = 12 - week delta = datetime.timedelta(days=week) n_days = now + delta nowtime = n_days.strftime(&#x27;%Y-%m-%d&#x27;) # 每周五 jiage = int(30) #价格 url_gwl = urlopen(&quot;http://www.gewara.com/cinema/ajax/getOpiItemPage.xhtml?cid=cinemaid&amp;mid=&amp;fyrq=&quot;+nowtime).read().decode(&quot;utf-8&quot;) soupurl_gwl = BeautifulSoup(url_gwl,&quot;html.parser&quot;) ids_gwl = soupurl_gwl.findAll(&quot;a&quot;,attrs =&#123;&quot;href&quot;:&quot;javascript:void(0);&quot;&#125;) str = &#x27;&#x27; str1 = &#x27;&#x27; str2 = &#x27;&#x27; for idattr_gwl in ids_gwl: res_gwl = urlopen(&quot;http://www.gewara.com/movie/ajax/getOpiItemNew.xhtml?movieid=&quot;+idattr_gwl[&#x27;id&#x27;]+&quot;&amp;fyrq=&quot;+nowtime+&quot;&amp;cid=cinemaid&quot;).read().decode(&quot;utf-8&quot;) soup_gwl = BeautifulSoup(res_gwl,&quot;html.parser&quot;) # print(soup) links_gwl = soup_gwl.findAll(&quot;span&quot;,attrs =&#123;&quot;class&quot;:&quot;opiPrice&quot;&#125;) arrtime_gwl = soup_gwl.findAll(&quot;span&quot;,attrs =&#123;&quot;class&quot;:&quot;opitime&quot;&#125;) for i in range(0,len(links_gwl)): if links_gwl[i].find(&quot;b&quot;) != None: if int(links_gwl[i].find(&quot;b&quot;).get_text()) &lt; jiage: str1 = str1+&quot;&lt;p&gt;&quot;+arrtime_gwl[i].get_text()+&quot;票价：&quot;+links_gwl[i].find(&quot;b&quot;).get_text()+idattr_gwl.find(&#x27;img&#x27;)[&#x27;alt&#x27;]+&quot;&lt;a href=&#x27;http://www.gewara.com/movie/ajax/getOpiItemNew.xhtml?movieid=&quot;+idattr_gwl[&#x27;id&#x27;]+&quot;&amp;fyrq=&quot;+nowtime+&quot;&amp;cid=cinemaid&#x27;&gt;点击查看&lt;/a&gt;&lt;/p&gt;&quot; url_tb = urlopen(&quot;http://dianying.taobao.com/showList.htm?spm=a1z21.3046609.w2.3.9ilG5t&amp;n_s=new&quot;).read().decode(&quot;utf-8&quot;) soupurl_tb = BeautifulSoup(url_tb,&quot;html.parser&quot;) ids_tb = soupurl_tb.findAll(&quot;a&quot;,attrs =&#123;&quot;class&quot;:&quot;movie-card&quot;&#125;) for idattr_tb in ids_tb: pattern = re.compile(r&quot;showId=(\\d+)&quot;) id_group_tb = pattern.search(idattr_tb[&#x27;href&#x27;]) if id: res_tb = urlopen(&quot;http://dianying.taobao.com/cinemaDetailSchedule.htm?cinemaId=cinemaid&amp;activityId=&amp;fCode=&amp;showId=&quot;+id_group_tb.group(1)+&quot;&amp;showDate=&quot;+nowtime).read().decode(&quot;utf-8&quot;) soup_tb = BeautifulSoup(res_tb,&quot;html.parser&quot;) # print(soup) links_tb = soup_tb.findAll(&quot;td&quot;,attrs =&#123;&quot;class&quot;:&quot;hall-price&quot;&#125;) arrtime_tb = soup_tb.findAll(&quot;td&quot;,attrs =&#123;&quot;class&quot;:&quot;hall-time&quot;&#125;) for i in range(0,len(links_tb)): if links_tb[i].find(&quot;em&quot;) != None: if float(links_tb[i].find(&quot;em&quot;).get_text()) &lt; jiage: name_tb = idattr_tb.find(&#x27;span&#x27;,attrs=&#123;&quot;class&quot;:&quot;bt-l&quot;&#125;) str2 = str2+&quot;&lt;p&gt;&quot;+arrtime_tb[i].get_text()+&quot;票价：&quot;+links_tb[i].find(&quot;em&quot;).get_text()+name_tb.get_text()+&quot;&lt;a href=&#x27;http://dianying.taobao.com/cinemaDetailSchedule.htm?cinemaId=cinemaid&amp;activityId=&amp;fCode=&amp;showId=&quot;+id_group_tb.group(1)+&quot;&amp;showDate=&quot;+nowtime+&quot;&#x27;&gt;点击查看&lt;/a&gt;&lt;/p&gt;&quot; str1 = str1.strip() str2 = str2.strip() if str1 != &#x27;&#x27; or str2 != &#x27;&#x27;: from email import encoders from email.header import Header from email.mime.text import MIMEText from email.utils import parseaddr, formataddr import smtplib # 第三方 SMTP 服务 mail_host=&quot;smtp.qq.com&quot; #设置服务器 mail_user=&quot;@&quot; #用户名 mail_pass=&quot;@&quot; #口令,QQ邮箱是输入授权码 sender = &#x27;@&#x27; receivers = [&#x27;@&#x27;] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 if str1 != &#x27;&#x27;: str = &quot;格瓦拉：&lt;br/&gt;&quot;+str1+&quot;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&quot; if str2 != &#x27;&#x27;: str = str+&quot;淘票票：&lt;br/&gt;&quot;+str2+&quot;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&quot; message = MIMEText(str, &#x27;html&#x27;, &#x27;utf-8&#x27;) message[&#x27;From&#x27;] = Header(&quot;@&quot;, &#x27;utf-8&#x27;) message[&#x27;To&#x27;] = Header(&quot;@&quot;, &#x27;utf-8&#x27;) subject = &#x27;优惠电影&#x27; message[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) try: smtpObj = smtplib.SMTP_SSL(mail_host, 465) smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) smtpObj.quit() print(&quot;邮件发送成功&quot;) except smtplib.SMTPException: print(smtplib.SMTPException) else: print(&quot;暂无优惠电影&quot;)","categories":[{"name":"python","slug":"python","permalink":"http://github.13sai.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://github.13sai.com/tags/python/"}]},{"title":"javascript函数设置默认参数","slug":"javascript函数设置默认参数","date":"2017-01-12T11:10:24.000Z","updated":"2021-04-13T07:31:14.259Z","comments":true,"path":"2017/01/12/97/","link":"","permalink":"http://github.13sai.com/2017/01/12/97/","excerpt":"","text":"PHP函数中，可以直接在参数后面加=，设置默认值，如：function&nbsp;sum($a,$b,$c=0){ &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c; }例：echo&nbsp;sum(1,2)；&nbsp;//输出3假如你认为javascript也可以这样写，你就大错特错了。在javascript中如何为函数设置默认参数值，下面提供几种方法供大家参考。 第一种方法：function&nbsp;example(a,b){&nbsp; &nbsp;&nbsp;var&nbsp;a&nbsp;=&nbsp;arguments[0]&nbsp;?&nbsp;arguments[0]&nbsp;:&nbsp;1;//设置参数a的默认值为1&nbsp; &nbsp;&nbsp;var&nbsp;b&nbsp;=&nbsp;arguments[1]&nbsp;?&nbsp;arguments[1]&nbsp;:&nbsp;2;//设置参数b的默认值为2&nbsp; &nbsp;&nbsp;return&nbsp;a+b;&nbsp; }注意以上函数也可写作如下：function&nbsp;example(){&nbsp; &nbsp;&nbsp;var&nbsp;a&nbsp;=&nbsp;arguments[0]&nbsp;?&nbsp;arguments[0]&nbsp;:&nbsp;1;//设置第一个参数的默认值为1&nbsp; &nbsp;&nbsp;var&nbsp;b&nbsp;=&nbsp;arguments[1]&nbsp;?&nbsp;arguments[1]&nbsp;:&nbsp;2;//设置第二个参数的默认值为2&nbsp; &nbsp;&nbsp;return&nbsp;a+b;&nbsp; }例：alert(&nbsp;example()&nbsp;);&nbsp;//输出3&nbsp;alert(&nbsp;example(10)&nbsp;);&nbsp;//输出12&nbsp;alert(&nbsp;example(10,20)&nbsp;);&nbsp;//输出30&nbsp;alert(&nbsp;example(null,20)&nbsp;);&nbsp;//输出20第二种方法：function&nbsp;example(name,age){&nbsp; &nbsp;&nbsp;name=name||&#39;貂蝉&#39;;&nbsp; &nbsp;&nbsp;age=age||21;&nbsp; &nbsp;&nbsp;alert(&#39;你好！我是&#39;+name+&#39;，今年&#39;+age+&#39;岁。&#39;);&nbsp; }该函数也可以写作如下：function&nbsp;example(name,age){&nbsp; &nbsp;&nbsp;if(!name){name=&#39;貂蝉&#39;;}&nbsp; &nbsp;&nbsp;if(!age){age=21;}&nbsp; &nbsp;&nbsp;alert(&#39;你好！我是&#39;+name+&#39;，今年&#39;+age+&#39;岁。&#39;);&nbsp; }例：example(&#39;杨胖子&#39;);//输出：你好！我是杨胖子，今年21岁。&nbsp;&nbsp;example(&#39;西施&#39;,305);//输出：你好！我是西施，今年305岁。&nbsp;&nbsp;example(null,10);//输出：你好！我是貂蝉，今年10岁。第三种方法，这种方法适合用于参数较多的情况，Jquery插件中很常见：function&nbsp;example(setting){&nbsp; &nbsp;&nbsp;var&nbsp;defaultSetting={&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;name:&#39;小明&#39;,&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;age:&#39;16&#39;,&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;sex:&#39;男&#39;,&nbsp; &nbsp;&nbsp;};&nbsp; &nbsp;&nbsp;$.extend(defaultSetting,settings);&nbsp; &nbsp;&nbsp;var&nbsp;message=&#39;姓名：&#39;+defaultSetting.name&nbsp; &nbsp;&nbsp;+&#39;，年龄：&#39;+defaultSetting.age&nbsp; &nbsp;&nbsp;+&#39;，性别：&#39;+defaultSetting.sex&nbsp; &nbsp;&nbsp;+&#39;。&#39;;&nbsp; &nbsp;&nbsp;alert(message);&nbsp; }例：example({&nbsp; &nbsp;&nbsp;name:&#39;小红&#39;,&nbsp; &nbsp;&nbsp;sex:&#39;女&#39;});&nbsp; //输出：姓名：小红，性别：女，年龄：16。三种方法都可以，最后一种需要引用jquery库。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"ThinkPHP中order使用方法","slug":"ThinkPHP中order使用方法","date":"2017-01-06T06:05:51.000Z","updated":"2021-04-26T03:30:59.278Z","comments":true,"path":"2017/01/06/96/","link":"","permalink":"http://github.13sai.com/2017/01/06/96/","excerpt":"","text":"order方法属于模型的连贯操作方法之一，用于对数据库操作的结果进行排序，相当于是在select语句中一个order by的子句。例：$Model-&gt;where(&#39;status=1&#39;)-&gt;order(&#39;id&nbsp;desc&#39;)-&gt;limit(5)-&gt;select();支持对多个字段的排序，例如：$Model-&gt;where(&#39;status=1&#39;)-&gt;order(&#39;id&nbsp;desc,time&nbsp;asc&#39;)-&gt;limit(5)-&gt;select();如果没有指定排序规则，默认为asc。如果你的字段和mysql关键字有冲突，那么建议采用数组方式调用，例如：$Model-&gt;where(&#39;status=1&#39;)-&gt;order(array(&#39;order&#39;,&#39;id&#39;=&gt;&#39;desc&#39;))-&gt;limit(5)-&gt;select();","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://github.13sai.com/tags/ThinkPHP/"}]},{"title":"windows7创建任务计划","slug":"windows7创建任务计划","date":"2017-01-05T05:30:54.000Z","updated":"2021-04-26T03:31:57.483Z","comments":true,"path":"2017/01/05/95/","link":"","permalink":"http://github.13sai.com/2017/01/05/95/","excerpt":"","text":"最近在做个程序，爬取优惠电影票的程序，程序存在本地，每次需要cmd运行下，有点麻烦，有时候会忘记，因为考虑创建任务计划。创建其实很简单，第一步，进入任务计划管理（控制面板或者直接搜索程序）你可以看见本机的任务计划列表。点击右侧创建基本任务，名称描述触发时间就由你定，选择启动程序，程序脚本写在上面，起始于写入改程序所在目录。点击下一步，点击完成，这样就完成了。是不是很简单。","categories":[{"name":"windows","slug":"windows","permalink":"http://github.13sai.com/categories/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://github.13sai.com/tags/windows/"}]},{"title":"微信JSSDK分享","slug":"微信JSSDK分享","date":"2016-12-27T07:50:49.000Z","updated":"2021-04-13T07:28:07.874Z","comments":true,"path":"2016/12/27/94/","link":"","permalink":"http://github.13sai.com/2016/12/27/94/","excerpt":"","text":"微信JS-SDK是微信公众平台面向网页开发者提供的基于微信内的网页开发工具包。通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验。此文档面向网页开发者介绍微信JS-SDK如何使用及相关注意事项。JSSDK使用步骤步骤一：绑定域名先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。备注：登录后可在“开发者中心”查看对应的接口权限。步骤二：引入JS文件在需要调用JS接口的页面引入如下JS文件，（支持https）：http://res.wx.qq.com/open/js/jweixin-1.0.0.js请注意，如果你的页面启用了https，务必引入 https://res.wx.qq.com/open/js/jweixin-1.0.0.js ，否则将无法在iOS9.0以上系统中成功使用JSSDK如需使用摇一摇周边功能，请引入 jweixin-1.1.0.js备注：支持使用 AMD/CMD 标准模块加载方法加载步骤三：通过config接口注入权限验证配置所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用（同一个url仅需调用一次，对于变化url的SPA的web app可在每次url变化时进行调用,目前Android微信客户端不支持pushState的H5新特性，所以使用pushState来实现web app的页面会导致签名失败，此问题会在Android6.2中修复）。wx.config({ &nbsp;&nbsp;&nbsp;&nbsp;debug:&nbsp;true,&nbsp;//&nbsp;开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 &nbsp;&nbsp;&nbsp;&nbsp;appId:&nbsp;&#39;&#39;,&nbsp;//&nbsp;必填，公众号的唯一标识 &nbsp;&nbsp;&nbsp;&nbsp;timestamp:&nbsp;,&nbsp;//&nbsp;必填，生成签名的时间戳 &nbsp;&nbsp;&nbsp;&nbsp;nonceStr:&nbsp;&#39;&#39;,&nbsp;//&nbsp;必填，生成签名的随机串 &nbsp;&nbsp;&nbsp;&nbsp;signature:&nbsp;&#39;&#39;,//&nbsp;必填，签名，见附录1 &nbsp;&nbsp;&nbsp;&nbsp;jsApiList:&nbsp;[]&nbsp;//&nbsp;必填，需要使用的JS接口列表，所有JS接口列表见附录2 });步骤四：通过ready接口处理成功验证wx.ready(function(){ &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。});步骤五：通过error接口处理失败验证wx.error(function(res){ &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。 });接口调用说明所有接口通过wx对象(也可使用jWeixin对象)来调用，参数是一个对象，除了每个接口本身需要传的参数之外，还有以下通用参数：success：接口调用成功时执行的回调函数。fail：接口调用失败时执行的回调函数。complete：接口调用完成时执行的回调函数，无论成功或失败都会执行。cancel：用户点击取消时的回调函数，仅部分有用户取消操作的api才会用到。trigger: 监听Menu中的按钮点击时触发的方法，该方法仅支持Menu中的相关接口。备注：不要尝试在trigger中使用ajax异步请求修改本次分享的内容，因为客户端分享操作是一个同步操作，这时候使用ajax的回包会还没有返回。以上几个函数都带有一个参数，类型为对象，其中除了每个接口本身返回的数据之外，还有一个通用属性errMsg，其值格式如下：调用成功时：&quot;xxx:ok&quot; ，其中xxx为调用的接口名用户取消时：&quot;xxx:cancel&quot;，其中xxx为调用的接口名调用失败时：其值为具体错误信息我们重点介绍生成这些配置信息&lt;?phpclass&nbsp;JssdkAction&nbsp;extends&nbsp;AppbaseAction{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;$appId&nbsp;=&nbsp;&quot;@&quot;;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;$appSecret&nbsp;=&nbsp;&quot;@&quot;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/继承父类/&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;function&nbsp;_initialize()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent::_initialize();&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;getSignPackage()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$jsapiTicket&nbsp;=&nbsp;$this-&gt;getJsApiTicket(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;注意&nbsp;URL&nbsp;一定要动态获取，不能&nbsp;hardcode.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$protocol&nbsp;=&nbsp;(!empty($_SERVER[&#39;HTTPS&#39;])&nbsp;&amp;&amp;&nbsp;$_SERVER[&#39;HTTPS&#39;]&nbsp;!==&nbsp;&#39;off&#39;&nbsp;||&nbsp;$_SERVER[&#39;SERVER_PORT&#39;]&nbsp;==&nbsp;443)&nbsp;?&nbsp;&quot;https://&quot;&nbsp;:&nbsp;&quot;http://&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$url&nbsp;=&nbsp;&quot;$protocol$_SERVER[HTTP_HOST]$_SERVER[REQUEST_URI]&quot;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$timestamp&nbsp;=&nbsp;time();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$nonceStr&nbsp;=&nbsp;$this-&gt;createNonceStr(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;这里参数的顺序要按照&nbsp;key&nbsp;值&nbsp;ASCII&nbsp;码升序排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$string&nbsp;=&nbsp;&quot;jsapi_ticket=$jsapiTicket&amp;noncestr=$nonceStr&amp;timestamp=$timestamp&amp;url=$url&quot;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$signature&nbsp;=&nbsp;sha1($string); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$signPackage&nbsp;=&nbsp;array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;appId&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;$this-&gt;appId,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;nonceStr&quot;&nbsp;&nbsp;=&gt;&nbsp;$nonceStr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;timestamp&quot;&nbsp;=&gt;&nbsp;$timestamp,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;url&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;$url,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&quot;jsapiTicket&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;$jsapiTicket,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;signature&quot;&nbsp;=&gt;&nbsp;$signature,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;rawString&quot;&nbsp;=&gt;&nbsp;$string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$signPackage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;function&nbsp;createNonceStr($length&nbsp;=&nbsp;16)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$chars&nbsp;=&nbsp;&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$str&nbsp;=&nbsp;&quot;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;($i&nbsp;=&nbsp;0;&nbsp;$i&nbsp;&lt;&nbsp;$length;&nbsp;$i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$str&nbsp;.=&nbsp;substr($chars,&nbsp;mt_rand(0,&nbsp;strlen($chars)&nbsp;-&nbsp;1),&nbsp;1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$str;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;function&nbsp;getJsApiTicket()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;jsapi_ticket&nbsp;应该全局存储与更新，以下代码以写入到文件中做示例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data&nbsp;=&nbsp;json_decode(file_get_contents(&quot;jsapi_ticket.json&quot;),true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($data-&gt;expire_time&nbsp;&lt;&nbsp;time())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$accessToken&nbsp;=&nbsp;$this-&gt;getAccessToken();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果是企业号用以下&nbsp;URL&nbsp;获取&nbsp;ticket&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;$url&nbsp;=&nbsp;&quot;https://qyapi.weixin.qq.com/cgi-bin/get_jsapi_ticket?access_token=$accessToken&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$url&nbsp;=&nbsp;&quot;https://api.weixin.qq.com/cgi-bin/ticket/getticket?type=jsapi&amp;access_token=$accessToken&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$res&nbsp;=&nbsp;z_get_json($url);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ticket&nbsp;=&nbsp;$res[&#39;ticket&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($ticket)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data-&gt;expire_time&nbsp;=&nbsp;time()&nbsp;+&nbsp;7200;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data-&gt;jsapi_ticket&nbsp;=&nbsp;$ticket;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$fp&nbsp;=&nbsp;fopen(&quot;jsapi_ticket.json&quot;,&nbsp;&quot;w&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fwrite($fp,&nbsp;json_encode($data));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose($fp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;$accessToken;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ticket&nbsp;=&nbsp;$data[&#39;jsapi_ticket&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;$ticket;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//die();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$ticket;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;function&nbsp;getAccessToken()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;access_token&nbsp;应该全局存储与更新，以下代码以写入到文件中做示例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data&nbsp;=&nbsp;json_decode(file_get_contents(&quot;access_token.json&quot;));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($data-&gt;expire_time&nbsp;&lt;&nbsp;time())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果是企业号用以下URL获取access_token&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;$url&nbsp;=&nbsp;&quot;https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=$this-&gt;appId&amp;corpsecret=$this-&gt;appSecret&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$url&nbsp;=&nbsp;&quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$this-&gt;appId&amp;secret=$this-&gt;appSecret&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$res&nbsp;=&nbsp;z_get_json($url);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$access_token&nbsp;=&nbsp;$res[&#39;access_token&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($access_token)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data-&gt;expire_time&nbsp;=&nbsp;time()&nbsp;+&nbsp;7200;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data-&gt;access_token&nbsp;=&nbsp;$access_token;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$fp&nbsp;=&nbsp;fopen(&quot;access_token.json&quot;,&nbsp;&quot;w&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fwrite($fp,&nbsp;json_encode($data));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose($fp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//var_dump($res);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//die();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$access_token&nbsp;=&nbsp;$data-&gt;access_token;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$access_token;&nbsp;&nbsp;&nbsp;&nbsp;} }另一个组的调用&lt;?php class&nbsp;ActivityAction&nbsp;extends&nbsp;BaseAction&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;/继承父类/&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;function&nbsp;_initialize()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent::_initialize();&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;detail(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;navname&nbsp;=&nbsp;&#39;活动信息&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$a&nbsp;=&nbsp;M(&quot;vw_activity&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data&nbsp;=&nbsp;$a-&gt;where(&quot;a_id=&#39;%s&#39;&quot;,$a_id)-&gt;find(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$jssdk&nbsp;=&nbsp;A(&#39;Jssdk&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;signPackage&nbsp;=&nbsp;$jssdk-&gt;getSignPackage();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;data&nbsp;=&nbsp;$data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;display();&nbsp;&nbsp;&nbsp;&nbsp;} }前台tpl：&lt;script&nbsp;src=&quot;http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(function(){&nbsp;&nbsp;&nbsp;&nbsp;wx.config({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug:&nbsp;false,&nbsp;&nbsp;//true为调试模式，调试时可启用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;appId:&nbsp;&#39;{$signPackage[&quot;appId&quot;]}&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp:&nbsp;&#39;{$signPackage[&quot;timestamp&quot;]}&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonceStr:&nbsp;&#39;{$signPackage[&quot;nonceStr&quot;]}&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signature:&nbsp;&#39;{$signPackage[&quot;signature&quot;]}&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsApiList:&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;checkJsApi&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;onMenuShareTimeline&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;onMenuShareAppMessage&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;wx.ready(function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.onMenuShareAppMessage({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title:&nbsp;&#39;{$data[&#39;a_name&#39;]}&#39;,&nbsp;//&nbsp;分享标题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;desc:&nbsp;&#39;{$data[&#39;a_desc&#39;]}&#39;,&nbsp;//&nbsp;分享描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link:&nbsp;&#39;&#39;,&nbsp;//&nbsp;分享链接&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgUrl:&nbsp;&#39;http://{:$_SERVER[&#39;SERVER_NAME&#39;].$data[&#39;a_thumb&#39;]}&#39;,&nbsp;//&nbsp;分享图标&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//type:&nbsp;&#39;&#39;,&nbsp;//&nbsp;分享类型,music、video或link，不填默认为link&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//dataUrl:&nbsp;&#39;&#39;,&nbsp;//&nbsp;如果type是music或video，则要提供数据链接，默认为空&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success:&nbsp;function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aideTips(&#39;分享成功！&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cancel:&nbsp;function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aideTips(&#39;分享失败！&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.onMenuShareTimeline({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title:&nbsp;&#39;{$data[&#39;a_name&#39;]}&#39;,&nbsp;//&nbsp;分享标题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//desc:&nbsp;&#39;{$data[&#39;a_desc&#39;]}&#39;,&nbsp;//&nbsp;分享描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link:&nbsp;&#39;&#39;,&nbsp;//&nbsp;分享链接&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgUrl:&nbsp;&#39;http://{:$_SERVER[&#39;SERVER_NAME&#39;].$data[&#39;a_thumb&#39;]}&#39;,&nbsp;//&nbsp;分享图标，注意不要用相对地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success:&nbsp;function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aideTips(&#39;分享成功！&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cancel:&nbsp;function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aideTips(&#39;分享失败！&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;//aideTips(&#39;分享失败！&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&lt;/script&gt;看看效果，更多时间请看 微信jssdk","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"分享几个免费能用的ip地址查询接口","slug":"分享几个免费能用的ip地址查询接口","date":"2016-12-24T02:32:50.000Z","updated":"2021-04-26T03:41:23.232Z","comments":true,"path":"2016/12/24/93/","link":"","permalink":"http://github.13sai.com/2016/12/24/93/","excerpt":"","text":"分享几个获取ip地址api，亲测。 淘宝IP地址库接口使用例子(PHP)： 123$ip = &#x27;xxx&#x27;;$data = file_get_contents(&quot;http://ip.taobao.com/service/getIpInfo.php?ip=&quot;.$ip);print_r($data); 返回值： 123456789101112131415161718&#123; &quot;code&quot;: 0, &quot;data&quot;: &#123; &quot;ip&quot;: &quot;xxx&quot;, &quot;country&quot;: &quot;中国&quot;, &quot;area&quot;: &quot;&quot;, &quot;region&quot;: &quot;浙江&quot;, &quot;city&quot;: &quot;杭州&quot;, &quot;county&quot;: &quot;XX&quot;, &quot;isp&quot;: &quot;电信&quot;, &quot;country_id&quot;: &quot;CN&quot;, &quot;area_id&quot;: &quot;&quot;, &quot;region_id&quot;: &quot;330000&quot;, &quot;city_id&quot;: &quot;330100&quot;, &quot;county_id&quot;: &quot;xx&quot;, &quot;isp_id&quot;: &quot;200017&quot; &#125;&#125; 126 IP API接口使用例子(PHP)： 123456&lt;?php$ip = &#x27;xxx&#x27;;$data = @file_get_contents(&quot;http://ip.ws.126.net/ipquery?ip=&quot;.$ip);print_r($data);?&gt; 返回数据： 1var lo=&quot;江苏省&quot;, lc=&quot;南京市&quot;; var localAddress=&#123;city:&quot;南京市&quot;, province:&quot;江苏省&quot;&#125;; 新浪IP API(已失效)接口使用例子(PHP)： 1234&lt;?php$ip = &#x27;xxx&#x27;;$data = file_get_contents(&quot;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js&amp;ip=&quot;.$ip);print_r($data); 返回数据： 123456789101112&#123; “ret”:1, ”start”:”59.37.164.179″, ”end”:”59.37.165.17″, ”country”:”u4e2d\\u56fd”, ”province”:”u5e7f\\u4e1c”, ”city”:”u6c5f\\u95e8″, ”district”:””, ”isp”:”u7535\\u4fe1″, ”type”:””, ”desc”:””&#125;;","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"移动端美观的城市列表","slug":"移动端美观的城市列表","date":"2016-12-24T02:12:15.000Z","updated":"2021-04-13T07:28:58.822Z","comments":true,"path":"2016/12/24/92/","link":"","permalink":"http://github.13sai.com/2016/12/24/92/","excerpt":"","text":"最近项目中有一个需求是要定位到城市的，因为风格参照美团，所以找了个类似风格的demo。直接上代码吧：citylist.zip文件不大，但可惜的是，只能定位到地级市，恰好配合sina的开放api配合使用。perfect！具体获取地理位置请看：js获取当前地理位置与ip","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"js实现上传图片前本地预览","slug":"js实现上传图片前本地预览","date":"2016-12-13T05:32:03.000Z","updated":"2021-04-13T07:31:41.135Z","comments":true,"path":"2016/12/13/91/","link":"","permalink":"http://github.13sai.com/2016/12/13/91/","excerpt":"","text":"直接上代码：&lt;script&nbsp;type=&quot;text/javascript&quot;&gt; /** *&nbsp;从&nbsp;file&nbsp;域获取&nbsp;本地图片&nbsp;url */ function&nbsp;getFileUrl(sourceId)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;url; &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(navigator.userAgent.indexOf(&quot;MSIE&quot;)&gt;=1)&nbsp;{&nbsp;//&nbsp;IE &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;document.getElementById(sourceId).value; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;//&nbsp;Chrome &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;window.URL.createObjectURL(document.getElementById(sourceId).files.item(0)); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;url; } /***&nbsp;将本地图片&nbsp;显示到浏览器上*/function&nbsp;preImg(sourceId,&nbsp;targetId)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;url&nbsp;=&nbsp;getFileUrl(sourceId);&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;imgPre&nbsp;=&nbsp;document.getElementById(targetId);&nbsp;&nbsp;&nbsp;&nbsp;imgPre.src&nbsp;=&nbsp;url;}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&nbsp;action=&quot;&quot;&gt;&lt;input&nbsp;type=&quot;file&quot;&nbsp;name=&quot;imgOne&quot;&nbsp;id=&quot;imgOne&quot;&nbsp;onchange=&quot;preImg(this.id,&#39;imgPre&#39;);&quot;&nbsp;/&gt;&lt;img&nbsp;id=&quot;imgPre&quot;&nbsp;src=&quot;&quot;&nbsp;width=&quot;300px&quot;&nbsp;height=&quot;300px&quot;&nbsp;style=&quot;display:&nbsp;block;&quot;&nbsp;/&gt;&lt;/form&gt;效果如图：","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"ASP连接mysql数据库","slug":"ASP连接mysql数据库","date":"2016-11-30T08:52:47.000Z","updated":"2021-04-13T07:29:18.528Z","comments":true,"path":"2016/11/30/90/","link":"","permalink":"http://github.13sai.com/2016/11/30/90/","excerpt":"","text":"最近公司主站要上个抽奖页面，后台也要增加查询功能，我就负责增加后台列表页，其实就一个页面而已。自己之前从没接触过asp，貌似也out了，但还是试着用ASP来写这个页面。之前主站的数据都是存在sqlserver里，而这次我们把数据表放在了mysql数据库里，不得不写个连接数据库的config，那么我们开始：dim&nbsp;myHost,myDB,myUID,myPWD myHost&nbsp;=&nbsp;&quot;localhost&quot; myDB&nbsp;=&nbsp;&quot;db&quot; myUID&nbsp;=&nbsp;&quot;user&quot; myPWD&nbsp;=&nbsp;&quot;pw&quot; myCharSet&nbsp;=&nbsp;&quot;utf8&quot; strconnection=&quot;driver={MySQL&nbsp;ODBC&nbsp;3.51&nbsp;Driver};server=&quot;&nbsp;&amp;&nbsp;myHost&nbsp;&amp;&nbsp;&quot;;database=&quot;&nbsp;&amp;&nbsp;myDB&nbsp;&amp;&nbsp;&quot;;uid=&quot;&nbsp;&amp;&nbsp;myUID&nbsp;&amp;&nbsp;&quot;;password=&quot;&nbsp;&amp;&nbsp;myPWD set&nbsp;conn&nbsp;=&nbsp;Server.CreateObject(&quot;ADODB.Connection&quot;) conn.open&nbsp;strconnection conn.execute(&quot;set&nbsp;names&nbsp;&#39;&quot;&nbsp;&amp;&nbsp;myCharSet&nbsp;&amp;&nbsp;&quot;&#39;&quot;)然后报错：驱动没装，装好odbc驱动，注意版本（3.51或其他版本）要与程序对应。重试，报错消失。查询name&nbsp;=&nbsp;Request.Form(&quot;name&quot;) mobile&nbsp;=&nbsp;Request.Form(&quot;mobile&quot;) where&nbsp;=&nbsp;&quot;&nbsp;where&nbsp;1=1&quot; If&nbsp;name&lt;&gt;&quot;&quot;&nbsp;Then &nbsp;&nbsp;&nbsp;&nbsp;where&nbsp;=&nbsp;where&nbsp;&amp;&nbsp;&quot;&nbsp;and&nbsp;name&nbsp;like&nbsp;&#39;%&quot;&amp;&nbsp;name&nbsp;&amp;&quot;%&#39;&quot; End&nbsp;If If&nbsp;mobile&lt;&gt;&quot;&quot;&nbsp;Then &nbsp;&nbsp;&nbsp;&nbsp;where&nbsp;=&nbsp;where&nbsp;&amp;&nbsp;&quot;&nbsp;and&nbsp;mobile&nbsp;like&nbsp;&#39;%&quot;&amp;&nbsp;mobile&nbsp;&amp;&quot;%&#39;&quot; End&nbsp;If &lt;table&nbsp;id=&quot;example2&quot;&nbsp;class=&quot;table&nbsp;table-hover&nbsp;table-striped&nbsp;dataTable&nbsp;&quot;&nbsp;&gt; &nbsp;&nbsp;&lt;thead&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&nbsp;role=&quot;row&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;th&gt;序号&lt;/th&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;th&gt;姓名&lt;/th&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;th&gt;手机号&lt;/th&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt; &nbsp;&nbsp;&nbsp;&lt;/thead&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tbody&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;% sql&nbsp;=&nbsp;&quot;select&nbsp;*&nbsp;from&nbsp;activity_customer&nbsp;&quot;&amp;&nbsp;where&nbsp;&amp;&quot;&nbsp;order&nbsp;by&nbsp;ac_id&nbsp;desc&quot; set&nbsp;rs=server.CreateObject(&quot;adodb.recordset&quot;) call&nbsp;manage()&nbsp; sub&nbsp;manage() &nbsp;&nbsp;&nbsp;&nbsp;&#39;必须 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;rs.CursorLocation=3&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;rs.open&nbsp;sql,adodataconn,1,1 &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i=1&nbsp;to&nbsp;rs.recordcount %&amp;gt; &amp;lt;tr&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;td&amp;gt;&amp;lt;%=rs(&amp;quot;id&amp;quot;)%&amp;gt;&amp;lt;/td&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;td&amp;gt;&amp;lt;%=rs(&amp;quot;name&amp;quot;)%&amp;gt;&amp;lt;/td&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;td&amp;gt;&amp;lt;%=rs(&amp;quot;mobile&amp;quot;)%&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;% &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;#39;******************上面是你要显示的******************&amp;#39; rs.movenext if&amp;nbsp;rs.eof&amp;nbsp;then &amp;nbsp;&amp;nbsp;Exit&amp;nbsp;For End&amp;nbsp;if Next &amp;nbsp;response.write&amp;nbsp;&amp;quot;&amp;lt;/tbody&amp;gt;&amp;quot; &amp;nbsp;response.write&amp;nbsp;&amp;quot;&amp;lt;/table&amp;gt;&amp;quot; rs.close set&amp;nbsp;rs=nothing end&amp;nbsp;sub set&amp;nbsp;conn=nothing&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;注意下&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;rs.CursorLocation=3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/ueditor/image/20161130/1480495561126675.png&quot; title=&quot;1480495561126675.png&quot; alt=&quot;blob.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;CursorLocation 属性可设置或返回一个 long 值，该值指示游标服务的位置。默认值是 AdUseServer。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style=&quot;white-space: normal;&quot;&gt;还有一个就是每次记得关闭数据库与数据集。&lt;/p&gt;&lt;p style=&quot;white-space: normal;&quot;&gt;也就是&lt;/p&gt;&lt;pre class=&quot;brush:html;toolbar:false&quot;&gt;set&amp;nbsp;rs=nothing set&nbsp;conn=nothing好了，这样就实现了数据库连接与查询搜索。所以说，遇到不熟悉的语言不要怕，有强大的搜索引擎与结果呢。多读书，多看报，少吃零食，多睡觉，我行，你也行。希望对你有所帮助！","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"asp","slug":"asp","permalink":"http://github.13sai.com/tags/asp/"}]},{"title":"七牛云上传视频","slug":"七牛云上传视频","date":"2016-11-28T07:31:00.000Z","updated":"2021-04-26T03:42:42.067Z","comments":true,"path":"2016/11/28/89/","link":"","permalink":"http://github.13sai.com/2016/11/28/89/","excerpt":"","text":"近期客户需要做一个视频上传的功能，又嫌弃优酷、腾讯平台的广告，客户不差钱，因而选择了七牛云。七牛云的开发者文档还是很详尽的，上传、重命名、转码，一应俱全，而且PHP,JAVA,PYTHON等各种语言sdk都很详细。我用的是3.1版本的ThinkPHP，先去七牛开发者中心下载PHP的sdk到TP的扩展库Vendor目录下，命名为Qiniu。接着新建QiniuAction.class.php&lt;?php //&nbsp;引入鉴权类&nbsp;引入上传类 use&nbsp;Qiniu\\Auth; use&nbsp;Qiniu\\Storage\\UploadManager; use&nbsp;Qiniu\\Processing\\PersistentFop; class&nbsp;QiniuAction&nbsp;extends&nbsp;AppbaseAction&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;upload(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//防止盗用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(session(&#39;m_id&#39;)&nbsp;==&nbsp;&#39;&#39;){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;小样，不给你上传！&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;die();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return&nbsp;=&nbsp;array();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return[&#39;status&#39;]&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//判断文件大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$maxSize&nbsp;=&nbsp;z_get_config(&#39;max_upload_video_size&#39;)&nbsp;&nbsp;1024&nbsp;&nbsp;1024; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($_FILES[&#39;uploadv&#39;][size]&nbsp;&gt;&nbsp;$maxSize){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return[&#39;info&#39;]&nbsp;=&nbsp;&#39;文件过大，不能超过&#39;.z_get_config(&#39;max_upload_video_size&#39;).&#39;M&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;json_encode($return);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;die();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//判断类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$arr_type&nbsp;=&nbsp;array(&#39;mp4&#39;,&#39;avi&#39;,&#39;rmvb&#39;,&#39;mp4&#39;,&#39;mpeg&#39;,&#39;wmv&#39;,,&#39;mpv&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$fileType&nbsp;=&nbsp;pathinfo($_FILES[&#39;uploadv&#39;][&#39;name&#39;],PATHINFO_EXTENSION);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!in_array($fileType,&nbsp;$arr_type)){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return[&#39;info&#39;]&nbsp;=&nbsp;&#39;不支持此格式，请上传&#39;.implode(&#39;,&#39;,$arr_type).&#39;类型的视频&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;json_encode($return);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;die();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//引入库&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vendor(&#39;Qiniu.autoload&#39;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;构建鉴权对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$accessKey&nbsp;=&nbsp;ak;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$secretKey&nbsp;=&nbsp;sk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$auth&nbsp;=&nbsp;new&nbsp;Auth($accessKey,&nbsp;$secretKey);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;要上传的空间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$bucket&nbsp;=&nbsp;&#39;train&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;要上传文件的本地路径&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$filePath&nbsp;=&nbsp;$_FILES[&#39;uploadv&#39;][&#39;tmp_name&#39;]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;上传到七牛后保存的文件名&nbsp;采用id加当前时间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$filename&nbsp;=&nbsp;&#39;qn_&#39;.$mid.&#39;_&#39;.time().&#39;.&#39;.$fileType;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//要进行转码的转码操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$fops&nbsp;=&nbsp;&quot;avthumb/mp4/s/1280x720/vb/5m&quot;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//可以对转码后的文件进行使用saveas参数自定义命名，当然也可以不指定文件会默认命名并保存在当间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$savekey&nbsp;=&nbsp;Qiniu\base64_urlSafeEncode($bucket.&#39;:&#39;.$filename);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$fops&nbsp;=&nbsp;$fops.&#39;|saveas/&#39;.$savekey; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$policy&nbsp;=&nbsp;array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;persistentOps&#39;&nbsp;=&gt;&nbsp;$fops,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;persistentPipeline&#39;&nbsp;=&gt;&nbsp;$pipeline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$uptoken&nbsp;=&nbsp;$auth-&gt;uploadToken($bucket,&nbsp;null,&nbsp;3600,&nbsp;$policy); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$uploadMgr&nbsp;=&nbsp;new&nbsp;UploadManager(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list($ret,&nbsp;$err)&nbsp;=&nbsp;$uploadMgr-&gt;putFile($uptoken,&nbsp;null,&nbsp;$filePath); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//返回&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($err&nbsp;!==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;json_encode($err);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return&nbsp;=&nbsp;$ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return[&#39;status&#39;]&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return[&#39;video&#39;]&nbsp;=&nbsp;$filename;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;json_encode($return);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;}}前台：&nbsp;&nbsp;&nbsp;&nbsp;&lt;style&nbsp;type=&quot;text/css&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.type2{display:&nbsp;none;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#progress{position:relative;&nbsp;margin-left:150px;&nbsp;&nbsp;width:200px;padding:&nbsp;1px;&nbsp;border-radius:3px;&nbsp;display:none;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#bar&nbsp;{background-color:&nbsp;#D0333A;&nbsp;display:block;&nbsp;width:0%;&nbsp;height:30px;&nbsp;&nbsp;border-radius:3px;&nbsp;color:&nbsp;#666;&nbsp;text-align:&nbsp;center;&nbsp;line-height:&nbsp;30px;}&nbsp;&nbsp;&nbsp;&nbsp;&lt;/style&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;fabu&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;&lt;span&nbsp;class=&quot;wd-fr&quot;&gt;&lt;a&nbsp;href=&quot;{:U(&#39;Home/Train/index&#39;)}&quot;&gt;返回课程列表&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;method=&quot;post&quot;&nbsp;action=&quot;{:U(&#39;Home/Train/fabu&#39;)}&quot;&nbsp;&nbsp;id=&quot;fabuForm&quot;&nbsp;enctype=&quot;multipart/form-data&quot;&nbsp;onsubmit=&quot;return&nbsp;jQuery(this).validationEngine(&#39;validate&#39;);&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;hidden&quot;&nbsp;value=&quot;{$data_t[&#39;t_id&#39;]}&quot;&nbsp;name=&quot;teacher_id&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;hidden&quot;&nbsp;id=&quot;t-video&quot;&nbsp;name=&quot;t_video&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;课程标题：&lt;/label&gt;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;t_name&quot;&nbsp;class=&quot;validate[required,maxSize[100]]&quot;/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;课程分类：&lt;/label&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;volist&nbsp;name=&quot;list_lx&quot;&nbsp;id=&quot;vo&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;radio&quot;&nbsp;name=&quot;t_type&quot;&nbsp;value=&quot;{$vo[&#39;d_value&#39;]}&quot;&nbsp;class=&quot;validate[required,groupRequired[lx]]&quot;&nbsp;&lt;if&nbsp;condition=&quot;$i&nbsp;eq&nbsp;1&quot;&gt;checked&lt;/if&gt;&gt;{$vo[&#39;d_title&#39;]}&amp;nbsp;&amp;nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/volist&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;type2&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;课程地点：&lt;/label&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;t_didian&quot;&nbsp;class=&quot;validate[required,maxSize[50]]&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;type2&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;课程时间：&lt;/label&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;t_shijian&quot;&nbsp;class=&quot;validate[required]&quot;&nbsp;onFocus=&quot;WdatePicker({lang:&#39;zh-cn&#39;,dateFmt:&#39;yyyy-M-d&nbsp;HH:mm:ss&#39;})&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;课程描述：&lt;/label&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;t_desc&quot;&nbsp;class=&quot;validate[required,maxSize[500]]&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;type=&quot;submit&quot;&nbsp;class=&quot;tijiao-btn&nbsp;wd-fr&quot;&gt;提交&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;id=&quot;form1&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&lt;label&nbsp;for=&quot;&quot;&gt;上传视频区：&lt;/label&gt;&lt;input&nbsp;style=&quot;padding-left:&nbsp;10px;display:&nbsp;inline-block;width:&nbsp;600px;&quot;&nbsp;type=&quot;file&quot;&nbsp;name=&quot;uploadv&quot;&nbsp;id=&quot;uploadvideo&quot;&nbsp;accept=&quot;video/*&quot;&gt;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;progress&quot;&gt;&lt;div&nbsp;id=&quot;bar&quot;&gt;&lt;/div&gt;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;for=&quot;&quot;&gt;&lt;/label&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;type=&quot;button&quot;&nbsp;id=&quot;upload-vb&quot;&nbsp;class=&quot;tijiao-btn&quot;&gt;上传&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt;&lt;div&nbsp;class=&quot;am-modal&nbsp;am-modal-alert&quot;&nbsp;tabindex=&quot;-1&quot;&nbsp;id=&quot;my-alert&quot;&gt;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-modal-dialog&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-modal-hd&quot;&gt;爱的温馨提示&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-modal-bd&quot;&nbsp;id=&quot;tips-text&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-modal-footer&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&nbsp;class=&quot;am-modal-btn&quot;&gt;我知道了&lt;/span&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&lt;/div&gt;&lt;/div&gt;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=&quot;/Skin/public/uploadify/jquery.uploadify.min.js&quot;&gt;&lt;/script&gt; &lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;charset=&quot;utf-8&quot;&nbsp;src=&quot;/Skin/public/ueditor/ueditor.config.js&quot;&gt;&lt;/script&gt;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;charset=&quot;utf-8&quot;&nbsp;src=&quot;/Skin/public/ueditor/ueditor.all.min.js&quot;&gt;&nbsp;&lt;/script&gt;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;charset=&quot;utf-8&quot;&nbsp;src=&quot;/Skin/public/ueditor/lang/zh-cn/zh-cn.js&quot;&gt;&lt;/script&gt;&lt;script&nbsp;type=&quot;text/javascript&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;ue&nbsp;=&nbsp;UE.getEditor(&#39;editor&#39;,{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toolbars:[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&#39;bold&#39;,&nbsp;&#39;cleardoc&#39;,&nbsp;&#39;lineheight&#39;,&nbsp;&#39;|&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;customstyle&#39;,&nbsp;&#39;fontfamily&#39;,&nbsp;&#39;fontsize&#39;,&nbsp;&#39;|&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;justifyleft&#39;,&nbsp;&#39;justifycenter&#39;,&nbsp;&#39;justifyright&#39;,&nbsp;&#39;justifyjustify&#39;,&nbsp;&#39;|&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;imagenone&#39;,&nbsp;&#39;imageleft&#39;,&nbsp;&#39;imageright&#39;,&nbsp;&#39;imagecenter&#39;,&nbsp;&#39;insertimage&#39;,&#39;attachment&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;&nbsp;&nbsp;});&lt;/script&gt;&lt;script&nbsp;src=&quot;/Skin/public/My97datepicker/WdatePicker.js&quot;&nbsp;charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;script&gt;&nbsp;&nbsp;&nbsp;&nbsp;$(function(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#uploadvideo&#39;).on(&#39;change&#39;,function(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;filename&nbsp;=&nbsp;$(this).val();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;filetype&nbsp;=&nbsp;filename.substr(filename.lastIndexOf(&quot;.&quot;)).toLowerCase();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr&nbsp;=&nbsp;[&#39;.rmvb&#39;,&#39;.mp4&#39;,&#39;.mpeg&#39;,&#39;.wmv&#39;,&#39;.avi&#39;,&#39;.mov&#39;,&#39;.mpv&#39;,&#39;.png&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//console.log(arr.toString().indexOf(filetype))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(arr.toString().indexOf(filetype)&gt;-1){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#upload-vb&#39;).on(&#39;click&#39;,fsubmit);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#upload-vb&#39;).unbind(&#39;click&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;不支持此格式，请上传&#39;+arr.join(&#39;,&#39;)+&#39;格式视频&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&lt;script&gt;function&nbsp;fsubmit(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;data&nbsp;=&nbsp;new&nbsp;FormData($(&#39;#form1&#39;)[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$.ajax({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url:&nbsp;&#39;{:U(&#39;Home/Qiniu/upload&#39;)}&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&#39;POST&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;data,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataType:&nbsp;&#39;JSON&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache:&nbsp;false,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processData:&nbsp;false,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contentType:&nbsp;false,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beforeSend:&nbsp;function(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#progress&#39;).show()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr:&nbsp;function(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//进度条&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;xhr&nbsp;=&nbsp;$.ajaxSettings.xhr();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.upload.onprogress&nbsp;=&nbsp;function(progress)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(progress.lengthComputable)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jindu&nbsp;=&nbsp;(progress.loaded&nbsp;/&nbsp;progress.total&nbsp;&nbsp;100).toFixed(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#bar&#39;).css(&#39;width&#39;,jindu2).html(jindu+&#39;%&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;xhr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success:&nbsp;function(data)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(data.status&nbsp;==&nbsp;1){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#t-video&#39;).val(data.video);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tips(&#39;上传成功！&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tips(data.info);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;function(err){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tips(&#39;上传失败！&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;}&lt;/script&gt;&lt;include&nbsp;file=&quot;./Tpl/foot&quot;&nbsp;/&gt;这样就完成了，希望对你有所帮助，少走弯路。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"makedown","slug":"makedown","date":"2016-11-08T01:07:08.000Z","updated":"2021-04-13T07:32:48.744Z","comments":true,"path":"2016/11/08/81/","link":"","permalink":"http://github.13sai.com/2016/11/08/81/","excerpt":"","text":"最近捣鼓github，写文档要用到makedown，便简单地学习了下语法，真的很好用，效果佳，上手快。1. 标题设置（让字体变大，和word的标题意思一样） 在Markdown当中设置标题，有两种方式： 第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。 第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 2. 块注释（blockquote） 通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 3. 斜体 将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 4. 粗体 将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 5. 无序列表 在文字开头添加(*, +, and -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 6. 有序列表 使用数字后面跟上句号。（还要有空格） 7. 链接（Links） Markdown中有两种方式，实现链接，分别为内联方式和引用方式。 内联方式：This is an [example link](http://example.com/).引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. &nbsp;[1]: http://google.com/ &nbsp; &nbsp; &nbsp; &nbsp;&quot;Google&quot; [2]: http://search.yahoo.com/ &nbsp;&quot;Yahoo Search&quot; [3]: http://search.msn.com/ &nbsp; &nbsp;&quot;MSN Search&quot;&nbsp;8. 图片（Images） 图片的处理方式和链接的处理方式，非常的类似。 内联方式：![alt text](/path/to/img.jpg &quot;Title&quot;) 引用方式： ![alt text][id] &nbsp; &nbsp; [id]: /path/to/img.jpg &quot;Title&quot; &nbsp; 9. 代码（HTML中所谓的Code） 实现方式有两种： 第一种：简单文字出现一个代码框。使用`&lt;blockquote&gt;`。（`不是单引号而是左上角的ESC下面~中的`） 第二种：大片文字需要实现代码框。使用Tab和四个空格。 &nbsp; 10. 脚注（footnote） 实现方式如下： hello[^hello] &nbsp; &nbsp; [^hello]: hi &nbsp; 11. 下划线 在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）12. 插入源代码用```包含起来。比如插入php```php &lt;?php echo&nbsp;1; ?&gt; ```是不是够简洁，写小说文档蛮好的。另外推荐一款编辑器cmd makedown，兼容各种系统，虽然觉得不是特强大，但足够日常使用。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/tags/web/"}]},{"title":"js之匿名函数与闭包","slug":"js之匿名函数与闭包","date":"2016-10-23T01:47:21.000Z","updated":"2021-04-13T07:31:51.606Z","comments":true,"path":"2016/10/23/79/","link":"","permalink":"http://github.13sai.com/2016/10/23/79/","excerpt":"","text":"1、匿名函数简单说就是没有函数名的函数。创建匿名函数：(function(x,&nbsp;y){&nbsp;&nbsp;&nbsp;&nbsp;alert(x&nbsp;+&nbsp;y);&nbsp;&nbsp;})(2,&nbsp;3);这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。比较典型的还有jquery源码。(function(&nbsp;window,&nbsp;undefined&nbsp;)&nbsp;{...})(&nbsp;window&nbsp;);比较常用的就是这两种。当然，还有很多方法2、闭包说到匿名函数，就不得不说说闭包。使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，功能十分强大。闭包的含义：说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕。function checkClosure(){&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;var&nbsp;str&nbsp;=&nbsp;&#39;rain-man&#39;;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;setTimeout(function(){&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;alert(str);&nbsp; &nbsp; &nbsp;}&nbsp;//这是一个匿名函数&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;,&nbsp;2000);}checkClosure();这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的，在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为 setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。function&nbsp;forTimeout(x,&nbsp;y){&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;alert(x&nbsp;+&nbsp;y);}function&nbsp;delay(x&nbsp;,&nbsp;y&nbsp;&nbsp;,&nbsp;time){&nbsp;&nbsp;&nbsp;&nbsp; setTimeout(&#39;forTimeout(&#39;&nbsp;+&nbsp;&nbsp;x&nbsp;+&nbsp;&#39;,&#39;&nbsp;+&nbsp;&nbsp;y&nbsp;+&nbsp;&#39;)&#39;&nbsp;,&nbsp;time);&nbsp;&nbsp;&nbsp;&nbsp;}/* 上面的delay函数十分难以阅读，也不容易编写，但如果使用闭包就可以让代码更加清晰&nbsp;* /function&nbsp;delay(x&nbsp;,&nbsp;y&nbsp;,&nbsp;time){ &nbsp;&nbsp;&nbsp;setTimeout( function(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;forTimeout(x&nbsp;,&nbsp;y)&nbsp; &nbsp;&nbsp; },&nbsp;time);&nbsp;&nbsp;&nbsp;&nbsp;}闭包的作用&nbsp;在了解闭包的作用之前，我们先了解一下 javascript中的GC机制:在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收，否则这个对象一直会保存在内存中。在上述例子中，B定义在A中，因此B依赖于A,而外部变量 c 又引用了B, 所以A间接的被 c 引用，也就是说，A不会被GC回收，会一直保存在内存中。为了证明我们的推理，举例：function&nbsp;A(){&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;B(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(count);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;B;}var&nbsp;c&nbsp;=&nbsp;A();c();//&nbsp;1c();//&nbsp;2c();//&nbsp;3count是A中的一个变量，它的值在B中被改变，函数B每执行一次，count的值就在原来的基础上累加1。因此，A中的count一直保存在内存中。这就是闭包的作用，有时候我们需要一个模块中定义这样一个变量：希望这个变量一直保存在内存中但又不会“污染”全局的变量，这个时候，我们就可以用闭包来定义这个模块。匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。高端写法上面的写法其实是最简单最原始的写法，而在实际应用中，没人这么玩，特别是在一些大型JS框架中更不会这么写。下面是一个简单的demo组件：(function(document){ &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;viewport; &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init:function(id){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewport&nbsp;=&nbsp;document.querySelector(&quot;#&quot;+id); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addChild:function(child){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewport.appendChild(child); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removeChild:function(child){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewport.removeChild(child); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;window.jView&nbsp;=&nbsp;obj; })(document);这个组件的作用是：初始化一个容器，然后可以给这个容器添加子容器，也可以移除一个容器。功能很简单，但这里涉及到了另外一个概念：立即执行函数。 简单了解一下就行。主要是要理解这种写法是怎么实现闭包功能的。可以将上面的代码结构分成两部分：(function(){}) 和 () , 第1个()是一个表达式，而这个表达式本身是一个匿名函数，所以在这个表达式后面加()就表示执行这个匿名函数。因此这段代码执行执行过程可以分解如下：var&nbsp;fun =&nbsp;function(document){&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;viewport;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init:function(id){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewport&nbsp;=&nbsp;document.querySelector(&quot;#&quot;+id);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addChild:function(child){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewport.appendChild(child);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removeChild:function(child){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewport.removeChild(child);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;window.jView&nbsp;=&nbsp;obj;};fun(document);在这段代码中似乎看到了闭包的影子，但 fun 中没有任何返回值，似乎不具备闭包的条件，注意这句代码：window.jView&nbsp;=&nbsp;obj;obj 是在 fun 中定义的一个对象，这个对象中定义了一系列方法， 执行window.jView = obj 就是在 window 全局对象定义了一个变量 jView，并将这个变量指向 obj 对象，即全局变量 jView 引用了 obj 。而 obj 对象中的函数又引用了 fun 中的变量 viewport ,因此 fun 中的 viewport 不会被GC回收，会一直保存到内存中，所以这种写法满足闭包的条件。4、内存泄露使用闭包十分容易造成浏览器的内存泄露，所以切勿滥用，感兴趣的可以自行查看相关文章，如JavaScript之详述闭包导致的内存泄露。参考：让你分分钟学会 javascript 闭包JavaScript中的匿名函数及函数的闭包","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"js正则函数match、exec、test、search、replace、split","slug":"js正则函数match、exec、test、search、replace、split","date":"2016-10-19T04:33:20.000Z","updated":"2021-04-13T07:31:48.586Z","comments":true,"path":"2016/10/19/78/","link":"","permalink":"http://github.13sai.com/2016/10/19/78/","excerpt":"","text":"js正则函数test、search、match、exec、replace、split使用介绍:1.testtest() 方法用于检测一个字符串是否匹配某个模式.返回值如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。例：var&nbsp;str1&nbsp;=&nbsp;&quot;000&quot;;var&nbsp;str2&nbsp;=&nbsp;&quot;0a2b3c4d5e&quot;; var&nbsp;pattern&nbsp;=&nbsp;/([a-z])(\\d)[a-z]/g; console.log(pattern.test(str1)); console.log(pattern.test(str2));2.searchsearch() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回值stringObject 中第一个与 regexp 相匹配的子串的起始位置。注释：如果没有找到任何匹配的子串，则返回 -1。说明search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。例：var&nbsp;str1&nbsp;=&nbsp;&quot;000&quot;; var&nbsp;str2&nbsp;=&nbsp;&quot;0a2b3c4d5e&quot;; var&nbsp;pattern&nbsp;=&nbsp;/([a-z])(\\d)[a-z]/g; console.log(str1.search(pattern)); console.log(str2.search(pattern));3.matchmatch() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。返回值存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。说明match() 方法将检索字符串 stringObject，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。 index 属性声明的是匹配文本的起始字符在 stringObject 中的位置，input 属性声明的是对 stringObject 的引用。如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。若没有找到任何匹配的子串，则返回 null。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性。例：var&nbsp;str1&nbsp;=&nbsp;&quot;000&quot;; var&nbsp;str2&nbsp;=&nbsp;&quot;0a2b3c4d5e&quot;; var&nbsp;pattern&nbsp;=&nbsp;/([a-z])(\\d)[a-z]/g; console.log(str1.match(pattern));console.log(str2.match(pattern));注意：在全局检索模式下，match() 即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的位置。如果您需要这些全局检索的信息，可以使用下面介绍的exec()。4.execexec() 方法用于检索字符串中的正则表达式的匹配。返回值返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。说明exec() 方法的功能非常强大，它是一个通用的方法，而且使用起来也比 test() 方法以及支持正则表达式的 String 对象的方法更为复杂。如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。我们可以看得出，在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。提示和注释重要事项：如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把 lastIndex 属性重置为 0。有没有看晕，哈哈，还是看例子吧！例1：var&nbsp;str1&nbsp;=&nbsp;&quot;000&quot;;var&nbsp;str2&nbsp;=&nbsp;&quot;0a2b3c4d5e&quot;;var&nbsp;pattern&nbsp;=&nbsp;/([a-z])(\\d)[a-z]/g; console.log(pattern.exec(str2));console.log(pattern.exec(str2));例2：var&nbsp;str1&nbsp;=&nbsp;&quot;000&quot;;var&nbsp;str2&nbsp;=&nbsp;&quot;0a2b3c4d5e&quot;;var&nbsp;pattern&nbsp;=&nbsp;/([a-z])(\\d)[a-z]/g; while&nbsp;((result2&nbsp;=&nbsp;pattern.exec(str2))&nbsp;!=&nbsp;null)&nbsp;&nbsp;{console.log(result2);console.log(result2.index);console.log(pattern.lastIndex);}5.replacereplace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。返回值一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。说明字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。例1：var&nbsp;str1&nbsp;=&nbsp;&quot;000&quot;;var&nbsp;str2&nbsp;=&nbsp;&quot;0a2b3c4d5e&quot;;var&nbsp;pattern&nbsp;=&nbsp;/([a-z])(\\d)[a-z]/g; console.log(str2);console.log(str2.replace(pattern,&#39;s&#39;));console.log(str2.replace(pattern,&#39;$1&#39;));例2：var&nbsp;str1&nbsp;=&nbsp;&quot;000&quot;;var&nbsp;str2&nbsp;=&nbsp;&quot;0a2b3c4d5e&quot;;var&nbsp;pattern&nbsp;=&nbsp;/([a-z])(\\d)[a-z]/g; console.log(str2);console.log(str2.replace(pattern,function(match,$1,index,origin){ console.log(index) console.log(match) return&nbsp;$1;}));[object&nbsp;Object]例3：var&nbsp;str2&nbsp;=&nbsp;&quot;0a2b3c4d5e&quot;;var&nbsp;pattern&nbsp;=&nbsp;/([a-z])(\\d)[a-z]/g; console.log(str2);console.log(str2.replace(pattern,function(match,group1,group2,index,origin){ console.log(index) console.log(match) num&nbsp;=&nbsp;parseInt(group2);&nbsp;+&nbsp;1; return&nbsp;group1&nbsp;+&nbsp;num;}));6.splitsplit() 方法用于把一个字符串分割成字符串数组。返回值一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 stringObject 分割成子串创建的。返回的数组中的字串不包括 separator 自身。但是，如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本）。例1：var&nbsp;str1&nbsp;=&nbsp;&quot;000&quot;;var&nbsp;str2&nbsp;=&nbsp;&quot;a,b,c,d&quot;; console.log(str2);console.log(str2.split(&#39;,&#39;));例2：var&nbsp;str1&nbsp;=&nbsp;&quot;000&quot;;var&nbsp;str2&nbsp;=&nbsp;&quot;0a2b3c4d5e&quot;;var&nbsp;pattern&nbsp;=&nbsp;/[a-z]\\d[a-z]/g; console.log(str2);console.log(str2.split(pattern));最后来看个有趣的，例3：var&nbsp;str1&nbsp;=&nbsp;&quot;a,b,c,d&quot;;var&nbsp;str2&nbsp;=&nbsp;&quot;0a2b3c4d5e&quot;;var&nbsp;pattern5&nbsp;=&nbsp;/\\d/g;var&nbsp;pattern&nbsp;=&nbsp;/[a-z]\\d[a-z]/g;var&nbsp;pattern1&nbsp;=&nbsp;/([a-z])\\d[a-z]/g;var&nbsp;pattern2&nbsp;=&nbsp;/[a-z]\\d([a-z])/g;var&nbsp;pattern3&nbsp;=&nbsp;/([a-z])(\\d)[a-z]/g;var&nbsp;pattern4&nbsp;=&nbsp;/([a-z])(\\d)([a-z])/g;var&nbsp;pattern5&nbsp;=&nbsp;/([a-z]\\d[a-z])/g; console.log(str2);console.log(str1.split(&#39;,&#39;,2));console.log(str2.split(pattern));console.log(str2.split(pattern1));console.log(str2.split(pattern2));console.log(str2.split(pattern3));console.log(str2.split(pattern4));console.log(str2.split(pattern5));split第二个参数是限制数组长度，而正则如果使用了group（也就是小括号），返回数组也会把group里的字符包含进去。好了，是不是对这些函数有更深的理解，希望对你有所帮助。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"click事件触发了两次事件","slug":"click事件触发了两次事件","date":"2016-10-12T06:12:42.000Z","updated":"2021-04-13T07:29:26.896Z","comments":true,"path":"2016/10/12/77/","link":"","permalink":"http://github.13sai.com/2016/10/12/77/","excerpt":"","text":"之前遇到过click事件触发了两次alert，不明原因，近几天又想起这事，边查查，开放性问题，其实我还不是很明白。直接上网友的例子。&lt;!doctype&nbsp;html&gt; &lt;html&gt; &lt;head&gt; &lt;meta&nbsp;charset=&quot;utf-8&quot;&gt; &lt;title&gt;test&lt;/title&gt; &lt;script&nbsp;src=&quot;http://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .toggle&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;margin:4px; &nbsp;&nbsp;&nbsp;&nbsp;background-color:#EFEFEF; &nbsp;&nbsp;&nbsp;&nbsp;border-radius:4px; &nbsp;&nbsp;&nbsp;&nbsp;border:1px&nbsp;solid&nbsp;#D0D0D0; &nbsp;&nbsp;&nbsp;&nbsp;overflow:auto; &nbsp;&nbsp;&nbsp;&nbsp;float:left; } .toggle&nbsp;label&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;/*float:left;*/ &nbsp;&nbsp;&nbsp;&nbsp;width:4.0em; &nbsp;&nbsp;&nbsp;&nbsp;position:&nbsp;relative; } .toggle&nbsp;label&nbsp;span&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;text-align:center;&nbsp;&nbsp;&nbsp;&nbsp;padding:3px;&nbsp;&nbsp;&nbsp;&nbsp;display:block;&nbsp;&nbsp;&nbsp;&nbsp;cursor:&nbsp;pointer;} .toggle&nbsp;label&nbsp;input&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;position:absolute;&nbsp;&nbsp;&nbsp;&nbsp;top:-20px;} .toggle&nbsp;.input-checked&nbsp;/,&nbsp;.bounds&nbsp;input:checked&nbsp;+&nbsp;span&nbsp;works&nbsp;for&nbsp;firefox&nbsp;and&nbsp;ie9&nbsp;but&nbsp;breaks&nbsp;js&nbsp;for&nbsp;ie8(ONLY)&nbsp;/&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;background-color:#404040;&nbsp;&nbsp;&nbsp;&nbsp;color:#F7F7F7;} .toggle&nbsp;input:checked&nbsp;+&nbsp;span&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;background-color:#404040;&nbsp;&nbsp;&nbsp;&nbsp;color:#F7F7F7;} &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&nbsp;class=&quot;toggle&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;&lt;input&nbsp;type=&quot;radio&quot;&nbsp;name=&quot;toggle&quot;&nbsp;value=&quot;1&quot;&gt;&lt;span&gt;radio1&lt;/span&gt;&lt;/label&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&lt;div&nbsp;class=&quot;toggle&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;&lt;input&nbsp;type=&quot;radio&quot;&nbsp;name=&quot;toggle&quot;&nbsp;value=&quot;2&quot;&gt;&lt;span&gt;radio2&lt;/span&gt;&lt;/label&gt;&lt;/div&gt;&lt;div&nbsp;class=&quot;toggle&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt;&lt;input&nbsp;type=&quot;radio&quot;&nbsp;name=&quot;toggle&quot;&nbsp;value=&quot;3&quot;&gt;&lt;span&gt;radio3&lt;/span&gt;&lt;/label&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;$(&#39;label&#39;).click(function(){&nbsp;&nbsp;&nbsp;&nbsp;$(this).children(&#39;span&#39;).addClass(&#39;input-checked&#39;);&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;value&nbsp;=&nbsp;$(this).children(&#39;input&#39;).val();&nbsp;&nbsp;&nbsp;&nbsp;$(this).parent(&#39;.toggle&#39;).siblings(&#39;.toggle&#39;).children(&#39;label&#39;).children(&#39;span&#39;).removeClass(&#39;input-checked&#39;);&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);});&lt;/script&gt;有网友改了下js$(&#39;label&#39;).click(function(event){&nbsp;&nbsp;&nbsp;&nbsp;$(this).children(&#39;span&#39;).addClass(&#39;input-checked&#39;);&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;value&nbsp;=&nbsp;$(this).children(&#39;input&#39;).val();&nbsp;&nbsp;&nbsp;&nbsp;$(this).parent(&#39;.toggle&#39;).siblings(&#39;.toggle&#39;).children(&#39;label&#39;).children(&#39;span&#39;).removeClass(&#39;input-checked&#39;);&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;//return&nbsp;false});event.target.type主要是这个会触发两个一个是undefined一个是radio。因为label关联的radio也被有一个关联操作。当label被点击时，默认radio也被点击了一次。解决方法你可以$(&#39;span&#39;).click(function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;=&nbsp;$(&#39;span&#39;).index($(this));&nbsp;&nbsp;&nbsp;&nbsp;$(this).addClass(&#39;input-checked&#39;);&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;value&nbsp;=&nbsp;$(&#39;input&#39;).eq(i).val();&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;span&#39;).not($(this)).removeClass(&#39;input-checked&#39;);&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);})另一友人：修改css.toggle&nbsp;label&nbsp;input&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;position:absolute;&nbsp;&nbsp;&nbsp;&nbsp;top:0px;&nbsp;&nbsp;&nbsp;&nbsp;left:&nbsp;0px;&nbsp;&nbsp;&nbsp;&nbsp;width:50px;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;20px;&nbsp;&nbsp;&nbsp;&nbsp;z-index:&nbsp;9999;&nbsp;&nbsp;&nbsp;&nbsp;opacity:&nbsp;0;}解决问题，但我不知道为什么，你能告诉我么？还有在js后加上return false太阳解决问题。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"background-image的url属性为空","slug":"background-image的url属性为空","date":"2016-10-11T01:16:34.000Z","updated":"2021-04-13T07:29:23.200Z","comments":true,"path":"2016/10/11/76/","link":"","permalink":"http://github.13sai.com/2016/10/11/76/","excerpt":"","text":"前天同事开发时，遇到一个诡异的问题，每次刷新页面，浏览量会加2，而不是想要的加1。检查了代码控制器，没有丝毫问题，上次出现浏览量会加2的情况是因为多写了一次display，只能去头去尾，一部分一部分排查，最后发现是头部用了个background，里面的url是空值，去掉，正常。刚查了下网上确实有出现background-image的url属性为空导致二次提交的情况，同事出现浏览量加2也是因此导致。说明：改变代码习惯。严禁代码中，url/href/src 值为空或 # . 这应该是目前最好的一种方式。避免空链接属性空的链接属性是指img、link、script、ifrrame元素的src或href属性被设置了，但是属性却为空。早些版本的Webkit内核浏览器 与Firefox 会把空地址解析为当前页面的地址。如果页面内有多个空链接属性元素，当前页面的服务器则会被请求多次，增加服务器的负载。相较桌面浏览器对内核的更新升级较积极，这个问题在移动浏览器上问题可能较严重。 &nbsp; &nbsp;幸运的是所有主流浏览器面对iframe的src属性为空时，会把空地址解析为about:blank地址，而不会向服务器发出额外的请求。因此链接避免不了出现空的情况，可以用about：blank来代替空的情况。贴上文章 空路径对页面性能的影响","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/tags/web/"}]},{"title":"又见BOM","slug":"又见BOM","date":"2016-09-27T05:35:53.000Z","updated":"2021-04-13T07:29:02.569Z","comments":true,"path":"2016/09/27/75/","link":"","permalink":"http://github.13sai.com/2016/09/27/75/","excerpt":"","text":"之前写过BOM的问题，今天又一次遇见。进入后台，验证码不显示，各种查找，找不到原因，纳闷，然后同事修改了入口文件编码格式为不加BOM，解决问题。BOM —— Byte Order Mark，中文名译作“字节顺序标记”。在这里找到一段关于 BOM 的说明：在UCS 编码中有一个叫做 &quot;Zero Width No-Break Space&quot; ，中文译名作“零宽无间断间隔”的字符，它的编码是 FEFF。而 FFFE 在 UCS 中是不存在的字符，所以不应该出现在实际传输中。UCS 规范建议我们在传输字节流前，先传输字符 &quot;Zero Width No-Break Space&quot;。这样如果接收者收到 FEFF，就表明这个字节流是 Big-Endian 的；如果收到FFFE，就表明这个字节流是 Little- Endian 的。因此字符 &quot;Zero Width No-Break Space&quot; （零宽无间断间隔）又被称作 BOM。UTF-8 不需要 BOM 来表明字节顺序，但可以用 BOM 来表明编码方式。字符 &quot;Zero Width No-Break Space&quot; 的 UTF-8 编码是 EF BB BF。所以如果接收者收到以 EF BB BF 开头的字节流，就知道这是 UTF-8编码了。Windows 就是使用 BOM 来标记文本文件的编码方式的。字符U+FEFF如果出现在字节流的开头，则用来标识该字节流的字节序，是高位在前还是低位在前。如果它出现在字节流的中间，则表达零宽度非换行空格的意义，用户看起来就是一个空格。从Unicode3.2开始，U+FEFF只能出现在字节流的开头，只能用于标识字节序，就如它的名称——字节序标记——所表示的一样；除此以外的用法已被舍弃。取而代之的是，使用U+2060来表达零宽度无断空白。类似WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于 PHP来说，BOM是个大麻烦。PHP并不会忽略BOM，所以在读取、包含或者引用这些文件时，会把BOM作为该文件开头正文的一部分。根据嵌入式语言的特点，这串字符将被直接执行（显示）出 来。由此造成即使页面的 top padding 设置为0，也无法让整个网页紧贴浏览器顶部，因为在html一开头有这3个字符呢！如果处理PHP文件出现以下问题，多半是因为这个原因： 1. 验证码图片不显示；2.页面显示一个“锘”字，其他一片空白；3.不能登录或退出；4.页顶出现一行空白；5.页顶出现错误警告。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"Thinkphp实现ajax分页","slug":"ThinkPHP实现ajax分页","date":"2016-09-24T03:28:28.000Z","updated":"2021-04-26T03:30:26.290Z","comments":true,"path":"2016/09/24/73/","link":"","permalink":"http://github.13sai.com/2016/09/24/73/","excerpt":"","text":"前两天销售那边说能不能做无刷新分页，我说可以，比正常分页麻烦一点，之前有见过。 然后想想，试试看，搜了代码，测试修改，成功了。 ajaxPage.class.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?phpclass AjaxPage &#123; // 分页栏每页显示的页数 public $rollPage = 5; // 页数跳转时要带的参数 public $parameter ; // 默认列表每页显示行数 public $listRows = 20; // 起始行数 public $firstRow ; public $ajax_func ; // 分页总页面数 protected $totalPages ; // 总行数 protected $totalRows ; // 当前页数 protected $nowPage ; // 分页的栏的总页数 protected $coolPages ; // 分页显示定制 protected $config = array(&#x27;header&#x27;=&gt;&#x27;条记录&#x27;,&#x27;prev&#x27;=&gt;&#x27;上一页&#x27;,&#x27;next&#x27;=&gt;&#x27;下一页&#x27;,&#x27;first&#x27;=&gt;&#x27;第一页&#x27;,&#x27;last&#x27;=&gt;&#x27;最后一页&#x27;,&#x27;theme&#x27;=&gt;&#x27;&lt;ul class=&quot;pagination&quot;&gt;&lt;li class=&quot;prev &quot;&gt;&lt;a&gt; %totalRow% %header% %nowPage%/%totalPage% 页 &lt;/a&gt;&lt;/li&gt; %first% %prePage% %upPage% %linkPage% %downPage% %nextPage% %end% &lt;/ul&gt;&#x27;); // 默认分页变量名 protected $varPage; public function __construct($totalRows,$listRows=&#x27;&#x27;,$ajax_func,$parameter=&#x27;&#x27;) &#123; $this-&gt;totalRows = $totalRows; $this-&gt;ajax_func = $ajax_func; $this-&gt;parameter = $parameter; $this-&gt;varPage = C(&#x27;VAR_PAGE&#x27;) ? C(&#x27;VAR_PAGE&#x27;) : &#x27;p&#x27; ; if(!empty($listRows)) &#123; $this-&gt;listRows = intval($listRows); &#125; $this-&gt;totalPages = ceil($this-&gt;totalRows/$this-&gt;listRows); //总页数 $this-&gt;coolPages = ceil($this-&gt;totalPages/$this-&gt;rollPage); $this-&gt;nowPage = !empty($_GET[$this-&gt;varPage])?intval($_GET[$this-&gt;varPage]):1; if(!empty($this-&gt;totalPages) &amp;&amp; $this-&gt;nowPage&gt;$this-&gt;totalPages) &#123; $this-&gt;nowPage = $this-&gt;totalPages; &#125; $this-&gt;firstRow = $this-&gt;listRows*($this-&gt;nowPage-1); &#125; public function setConfig($name,$value) &#123; if(isset($this-&gt;config[$name])) &#123; $this-&gt;config[$name] = $value; &#125; &#125; public function show() &#123; if(0 == $this-&gt;totalRows) return &#x27;&#x27;; $p = $this-&gt;varPage; $nowCoolPage = ceil($this-&gt;nowPage/$this-&gt;rollPage); $url = $_SERVER[&#x27;REQUEST_URI&#x27;].(strpos($_SERVER[&#x27;REQUEST_URI&#x27;],&#x27;?&#x27;)?&#x27;&#x27;:&quot;?&quot;).$this-&gt;parameter; $parse = parse_url($url); if(isset($parse[&#x27;query&#x27;])) &#123; parse_str($parse[&#x27;query&#x27;],$params); unset($params[$p]); $url = $parse[&#x27;path&#x27;].&#x27;?&#x27;.http_build_query($params); &#125; //上下翻页字符串 $upRow = $this-&gt;nowPage-1; $downRow = $this-&gt;nowPage+1; if ($upRow&gt;0)&#123; $upPage = &quot;&lt;li class=&#x27;prev&#x27;&gt;&lt;a href=&#x27;javascript:&quot;.$this-&gt;ajax_func.&quot;(&quot;.$upRow.&quot;)&#x27;&gt;&quot;.$this-&gt;config[&#x27;prev&#x27;].&quot;&lt;/a&gt;&lt;/li&gt;&quot;; &#125;else&#123; $upPage = &quot;&quot;; &#125; if ($downRow &lt;= $this-&gt;totalPages)&#123; $downPage = &quot;&lt;li class=&#x27;next&#x27;&gt;&lt;a href=&#x27;javascript:&quot;.$this-&gt;ajax_func.&quot;(&quot;.$downRow.&quot;)&#x27;&gt;&quot;.$this-&gt;config[&#x27;next&#x27;].&quot;&lt;/a&gt;&lt;/li&gt;&quot;; &#125;else&#123; $downPage = &quot;&quot;; &#125; // &lt;&lt; &lt; &gt; &gt;&gt; if($nowCoolPage == 1)&#123; $theFirst = &quot;&quot;; $prePage = &quot;&quot;; &#125;else&#123; $preRow = $this-&gt;nowPage-$this-&gt;rollPage; $prePage = &quot;&lt;li&gt;&lt;a href=&#x27;javascript:&quot;.$this-&gt;ajax_func.&quot;(&quot;.$preRow.&quot;)&#x27;&gt;上&quot;.$this-&gt;rollPage.&quot;页&lt;/a&gt;&lt;/li&gt;&quot;; $theFirst = &quot;&lt;li&gt;&lt;a href=&#x27;javascript:&quot;.$this-&gt;ajax_func.&quot;(1)&#x27; &gt;&quot;.$this-&gt;config[&#x27;first&#x27;].&quot;&lt;/a&gt;&lt;/li&gt;&quot;; &#125; if($nowCoolPage == $this-&gt;coolPages)&#123; $nextPage = &quot;&quot;; $theEnd=&quot;&quot;; &#125;else&#123; $nextRow = $this-&gt;nowPage+$this-&gt;rollPage; $theEndRow = $this-&gt;totalPages; $nextPage = &quot;&lt;li&gt;&lt;a href=&#x27;javascript:&quot;.$this-&gt;ajax_func.&quot;(&quot;.$nextRow.&quot;)&#x27; &gt;下&quot;.$this-&gt;rollPage.&quot;页&lt;/a&gt;&lt;/li&gt;&quot;; $theEnd = &quot;&lt;li&gt;&lt;a href=&#x27;javascript:&quot;.$this-&gt;ajax_func.&quot;(&quot;.$theEndRow.&quot;)&#x27; &gt;&quot;.$this-&gt;config[&#x27;last&#x27;].&quot;&lt;/a&gt;&lt;/li&gt;&quot;; &#125; // 1 2 3 4 5 $linkPage = &quot;&quot;; for($i=1;$i&lt;=$this-&gt;rollPage;$i++)&#123; $page=($nowCoolPage-1)*$this-&gt;rollPage+$i; if($page!=$this-&gt;nowPage)&#123; if($page&lt;=$this-&gt;totalPages)&#123; $linkPage .= &quot;&lt;li&gt;&lt;a href=&#x27;javascript:&quot;.$this-&gt;ajax_func.&quot;(&quot;.$page.&quot;)&#x27;&gt;&amp;nbsp;&quot;.$page.&quot;&amp;nbsp;&lt;/a&gt;&lt;/li&gt;&quot;; &#125;else&#123; break; &#125; &#125;else&#123; if($this-&gt;totalPages != 1)&#123; $linkPage .= &quot;&lt;li&gt;&lt;span class=&#x27;current&#x27;&gt;&quot;.$page.&quot;&lt;/span&gt;&lt;/li&gt;&quot;; &#125; &#125; &#125; $pageStr = str_replace( array(&#x27;%header%&#x27;,&#x27;%nowPage%&#x27;,&#x27;%totalRow%&#x27;,&#x27;%totalPage%&#x27;,&#x27;%upPage%&#x27;,&#x27;%downPage%&#x27;,&#x27;%first%&#x27;,&#x27;%prePage%&#x27;,&#x27;%linkPage%&#x27;,&#x27;%nextPage%&#x27;,&#x27;%end%&#x27;), array($this-&gt;config[&#x27;header&#x27;],$this-&gt;nowPage,$this-&gt;totalRows,$this-&gt;totalPages,$upPage,$downPage,$theFirst,$prePage,$linkPage,$nextPage,$theEnd),$this-&gt;config[&#x27;theme&#x27;]); return $pageStr; &#125;&#125; IndexAction1234567891011121314151617181920212223242526272829303132333435public function new()&#123; import(&quot;ORG.Util.ajaxPage&quot;);// 导入分页类 注意导入的是自己写的AjaxPage类 $m = M(&#x27;vw_article&#x27;); $count = $m-&gt;count(); //计算记录数 $limitRows = 5; // 设置每页记录数 //第三个参数是你需要调用换页的ajax函数名 $p = new AjaxPage($count, $limitRows,&quot;ajaxpage&quot;); $limit = $p-&gt;firstRow . &quot;,&quot; . $p-&gt;listRows; $p-&gt;setConfig(&#x27;theme&#x27;,&#x27;&lt;ul class=&quot;pagination&quot;&gt; %first% %prePage% %upPage% %linkPage% %downPage% %nextPage% %end% &lt;/ul&gt;&#x27;); $data = $m-&gt;limit($limit)-&gt;select(); // 查询数据 $page = $p-&gt;show(); // 产生分页信息，AJAX的连接在此处生成 $this-&gt;assign(&#x27;list&#x27;,$data); $this-&gt;assign(&#x27;page&#x27;,$page); $this-&gt;display();&#125;public function newslist()&#123; $p = I(&#x27;p&#x27;); import(&quot;ORG.Util.ajaxPage&quot;); $m = M(&#x27;vw_article&#x27;); $count = $m-&gt;count(); //计算记录数 $limitRows = 5; // 设置每页记录数 $p = new AjaxPage($count, $limitRows,&quot;ajaxpage&quot;); //第三个参数是你需要调用换页的ajax函数名 $limit = $p-&gt;firstRow . &quot;,&quot; . $p-&gt;listRows; $p-&gt;setConfig(&#x27;theme&#x27;,&#x27;&lt;ul class=&quot;pagination&quot;&gt; %first% %prePage% %upPage% %linkPage% %downPage% %nextPage% %end% &lt;/ul&gt;&#x27;); $data = $m-&gt;limit($limit)-&gt;select(); // 查询数据 $page = $p-&gt;show(); // 产生分页信息，AJAX的连接在此处生成 $this-&gt;assign(&#x27;list&#x27;,$data); $this-&gt;assign(&#x27;page&#x27;,$page); $this-&gt;display(); &#125; tpl123456789101112131415161718192021222324252627282930313233343536&lt;div class=&quot;page row&quot;&gt; &lt;include file=&quot;./sidebar&quot; /&gt; &lt;div class=&quot;page-right&quot; id=&quot;ajaxPage&quot;&gt; &lt;div class=&quot;page-position&quot;&gt; &lt;a href=&quot;&#123;:U(&#x27;Home/Index/index&#x27;)&#125;&quot;&gt;首页&lt;/a&gt;&gt;&gt;&#123;$navname&#125; &lt;/div&gt; &lt;div class=&quot;page-list&quot;&gt; &lt;ul&gt; &lt;volist name=&quot;list&quot; id=&quot;vo&quot;&gt; &lt;li&gt; &lt;div class=&quot;desc&quot; &gt; &lt;h3&gt;&lt;a href=&quot;&#123;:U(&#x27;Home/Index/news&#x27;,array(&#x27;art_id&#x27;=&gt;$vo[&#x27;art_id&#x27;],&#x27;art_column&#x27;=&gt;$vo[&#x27;art_column&#x27;]))&#125;&quot;&gt;&lt;span class=&quot;wd-fr&quot;&gt;&#123;$vo[&#x27;art_post_time&#x27;]&#125;&lt;/span&gt;&#123;:mb_substr($vo[&#x27;art_name&#x27;],0,40,&#x27;utf-8&#x27;)&#125;&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;/volist&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;wdphp-page&quot;&gt; &#123;$page&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function ajaxpage(id)&#123; var id = id; //post可不行 $.ajax(&#123; url: &quot;&#123;:U(&#x27;Home/Index/userlist&#x27;)&#125;&quot;, data: &#123;&#x27;p&#x27;:id&#125;, success: function (html) &#123; $(&quot;#ajaxPage&quot;).html(html); &#125; &#125;); &#125; &lt;/script&gt; 好了，是不是还蛮顺手。 但是如果时候那种下滑无刷新的呢，怎么做？加js?","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://github.13sai.com/tags/ThinkPHP/"}]},{"title":"微信扫码登录","slug":"微信扫码登录","date":"2016-09-21T05:49:16.000Z","updated":"2021-04-13T07:27:59.386Z","comments":true,"path":"2016/09/21/72/","link":"","permalink":"http://github.13sai.com/2016/09/21/72/","excerpt":"","text":"准备：申请微信开发者，申请认证，获取appid与appserect。&lt;?php class&nbsp;WechatAction&nbsp;extends&nbsp;AppbaseAction&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;$appid&nbsp;=&nbsp;&quot;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;$secret&nbsp;=&nbsp;&quot;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;//private&nbsp;$scope&nbsp;=&nbsp;&quot;snsapi_base&quot;;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;$scope&nbsp;=&nbsp;&quot;snsapi_login&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/继承父类/&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;function&nbsp;_initialize()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent::_initialize();&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//微信登录，同意授权，获取code&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;oauthLogin(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$appid&nbsp;=&nbsp;$this-&gt;appid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope&nbsp;=&nbsp;$this-&gt;scope;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//回调域&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$redirect_uri&nbsp;=&nbsp;urlencode(&#39;http://www.13sai.com&#39;.U(&#39;Member/Wechat/oauthCallback&#39;));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$url&nbsp;=&nbsp;&quot;https://open.weixin.qq.com/connect/qrconnect?appid=$appid&amp;redirect_uri=$redirect_uri&amp;response_type=code&amp;scope=$scope&amp;state=1#wechat_redirect&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;$url;die();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header(&quot;Location:&quot;.$url);&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//OAthu2.0&nbsp;回调函数&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;oauthCallback(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$appid&nbsp;=&nbsp;$this-&gt;appid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$secret&nbsp;=&nbsp;$this-&gt;secret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$code&nbsp;=&nbsp;$GET[&quot;code&quot;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//取得openid&nbsp;,access_token&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$oauth2Url&nbsp;=&nbsp;&quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=$appid&amp;secret=$secret&amp;code=$code&amp;grant_type=authorization_code&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$oauth2&nbsp;=&nbsp;z_get_json($oauth2Url);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//根据全局access_token和openid查询用户信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$access_token&nbsp;=&nbsp;$oauth2[&quot;access_token&quot;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$openid&nbsp;=&nbsp;$oauth2[&#39;openid&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;$openid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$get_user_info_url&nbsp;=&nbsp;&quot;https://api.weixin.qq.com/sns/userinfo?access_token=$access_token&amp;openid=$openid&amp;lang=zh_CN&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$userinfo&nbsp;=&nbsp;z_get_json($get_user_info_url);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//dump($userinfo);die();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//判断注册还是登录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($userinfo[&#39;openid&#39;]!=&#39;&#39;){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$row&nbsp;=&nbsp;M(&quot;member&quot;)-&gt;where(&quot;m_weixin_unionid=&#39;%s&#39;&quot;,$userinfo[&quot;unionid&quot;])-&gt;find();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($row){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session(&#39;m_id&#39;,$row[&#39;m_id&#39;]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session(&#39;m_nick_name&#39;,$row[&#39;m_nick_name&#39;]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session(&#39;m_login_name&#39;,$row[&#39;m_login_name&#39;]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//U(&#39;Home/Home/index&#39;,null,true,true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;/&quot;;&lt;/script&gt;&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建新用户&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count&nbsp;=&nbsp;M(&quot;member&quot;)-&gt;max(&#39;m_id&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$rand&nbsp;=&nbsp;mt_rand(1000,9999);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_sex&#39;]&nbsp;&nbsp;=&nbsp;$userinfo[&#39;sex&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_avatar&#39;]&nbsp;&nbsp;=&nbsp;$userinfo[&#39;headimgurl&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_nick_name&#39;]&nbsp;&nbsp;=&nbsp;mb_substr($userinfo[&#39;nickname&#39;],0,6,&quot;utf-8&quot;)&nbsp;.&nbsp;$count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_login_name&#39;]&nbsp;=&nbsp;&#39;wx&#39;.$rand.&#39;&#39;.$count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_password&#39;]&nbsp;=&nbsp;md5(md5(time()));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_weixin_unionid&#39;]&nbsp;&nbsp;=&nbsp;$userinfo[&quot;unionid&quot;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;from&#39;]&nbsp;=&nbsp;&#39;weixin&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;&#39;.U(&#39;Member/Index/oauthBind&#39;).&#39;&quot;;&lt;/script&gt;&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$str;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}}其中的z_get_json方法如下：function&nbsp;z_get_json($url){&nbsp;&nbsp;&nbsp;&nbsp;$ch&nbsp;=&nbsp;curl_init();&nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_URL,&nbsp;$url);&nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_SSL_VERIFYPEER,&nbsp;FALSE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_SSL_VERIFYHOST,&nbsp;FALSE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_RETURNTRANSFER,&nbsp;1);&nbsp;&nbsp;&nbsp;&nbsp;$output&nbsp;=&nbsp;curl_exec($ch);&nbsp;&nbsp;&nbsp;&nbsp;curl_close($ch);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;json_decode($output,&nbsp;true);}前台：&lt;a&nbsp;href=&quot;{:U(&#39;Member/Wechat/oauthLogin&#39;)}&quot;&gt;&lt;img&nbsp;src=&quot;/webui/home/images/weixin.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;效果：","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"php字符串中双引号及反斜杠替换问题","slug":"php字符串中双引号及反斜杠替换问题","date":"2016-09-06T07:20:09.000Z","updated":"2021-04-13T07:36:45.572Z","comments":true,"path":"2016/09/06/71/","link":"","permalink":"http://github.13sai.com/2016/09/06/71/","excerpt":"","text":"需要转义下 php字符串中双引号替换: 123$tmp_data = str_replace(&quot;&quot;&quot;,&quot;&quot;,$tmp_data);双引号替换为空字符串$tmp_data = str_replace(&quot;&quot;&quot;,&quot;&#x27;&quot;,$tmp_data);双引号替换为单引号 php字符串中替换反斜杠 1$tmp_data = str_replace(&quot;\\&quot;,&quot;&quot;,$tmp_data); 反斜杠替换为空字符串","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"微信登录","slug":"微信登录","date":"2016-09-04T07:50:11.000Z","updated":"2021-04-13T07:27:49.743Z","comments":true,"path":"2016/09/04/70/","link":"","permalink":"http://github.13sai.com/2016/09/04/70/","excerpt":"","text":"微信登录相比qq登录要简单，直接上代码。同样需要申请appid与secretWechatAction&lt;?php class&nbsp;WechatAction&nbsp;extends&nbsp;AppbaseAction&nbsp;{//申请的appid&nbsp;secret&nbsp;private&nbsp;$appid&nbsp;=&nbsp;&quot;&quot;;private&nbsp;$secret&nbsp;=&nbsp;&quot;&quot;;private&nbsp;$scope&nbsp;=&nbsp;&quot;snsapi_userinfo&quot;; /继承父类/&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;function&nbsp;_initialize()&nbsp;{parent::_initialize();&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;index(){&nbsp;&nbsp;&nbsp;echo&nbsp;111;&nbsp;&nbsp;&nbsp;//echo&nbsp;$this-&gt;appid;&nbsp;&nbsp;&nbsp;&nbsp;} //微信登录，同意授权，获取code&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;oauthLogin(){$appid&nbsp;=&nbsp;$this-&gt;appid;$scope&nbsp;=&nbsp;$this-&gt;scope;$redirect_uri&nbsp;=&nbsp;urlencode(&#39;http://www.13sai.com&#39;.U(&#39;Wap/Wechat/oauthCallback&#39;));$url&nbsp;=&nbsp;&quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=$appid&amp;redirect_uri=$redirect_uri&amp;response_type=code&amp;scope=$scope&amp;state=1#wechat_redirect&quot;;//echo&nbsp;$url;die();header(&quot;Location:&quot;.$url);&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//OAthu2.0&nbsp;回调函数&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;oauthCallback(){$appid&nbsp;=&nbsp;$this-&gt;appid;$secret&nbsp;=&nbsp;$this-&gt;secret;$code&nbsp;=&nbsp;$_GET[&quot;code&quot;];//echo&nbsp;$code.&#39;&lt;br&gt;&#39;;&nbsp;//第一步:取全局access_token$url&nbsp;=&nbsp;&quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$appid&amp;secret=$secret&quot;;$token&nbsp;=&nbsp;z_get_json($url);//dump($token).&#39;&lt;br&gt;&#39;; //第二步:取得openid$oauth2Url&nbsp;=&nbsp;&quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=$appid&amp;secret=$secret&amp;code=$code&amp;grant_type=authorization_code&quot;;$oauth2&nbsp;=&nbsp;z_get_json($oauth2Url);//dump($oauth2).&#39;&lt;br&gt;&#39;;&nbsp;//第三步:根据全局access_token和openid查询用户信息&nbsp;&nbsp;$access_token&nbsp;=&nbsp;$token[&quot;access_token&quot;];&nbsp;&nbsp;$openid&nbsp;=&nbsp;$oauth2[&#39;openid&#39;];&nbsp;&nbsp;$get_user_info_url&nbsp;=&nbsp;&quot;https://api.weixin.qq.com/cgi-bin/user/info?access_token=$access_token&amp;openid=$openid&amp;lang=zh_CN&quot;;//echo&nbsp;$get_user_info_url;$userinfo&nbsp;=&nbsp;z_get_json($get_user_info_url);//dump($userinfo);//die(); //if($userinfo[&#39;openid&#39;]!=&#39;&#39;){//&nbsp;echo&nbsp;&#39;&lt;br&gt;&lt;br&gt;&#39;.$userinfo[&#39;openid&#39;];//}//dump($userinfo);//die();//判断注册还是登录if($userinfo[&#39;openid&#39;]!=&#39;&#39;){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$row&nbsp;=&nbsp;M(&quot;member&quot;)-&gt;where(&quot;m_weixin_openid=&#39;%s&#39;&quot;,$userinfo[&quot;openid&quot;])-&gt;find();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($row){&nbsp;&nbsp;&nbsp;session(&#39;m_id&#39;,$row[&#39;m_id&#39;]);&nbsp;&nbsp;&nbsp;session(&#39;m_nick_name&#39;,$row[&#39;m_nick_name&#39;]);&nbsp;&nbsp;&nbsp;session(&#39;m_login_name&#39;,$row[&#39;m_login_name&#39;]);&nbsp;&nbsp;&nbsp;session(&#39;is_org&#39;,-1);&nbsp;&nbsp;&nbsp;//U(&#39;Home/Home/index&#39;,null,true,true);&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.location.href=&quot;http://www.13sai.com&#39;.U(&#39;Wap/Home/index&#39;).&#39;&quot;;&lt;/script&gt;&amp;#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建新用户&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count&nbsp;=&nbsp;M(&quot;member&quot;)-&gt;max(&#39;m_id&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$rand&nbsp;=&nbsp;mt_rand(1000,9999);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//$data[&#39;gender&#39;]&nbsp;&nbsp;=&nbsp;$gender;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_avatar&#39;]&nbsp;&nbsp;=&nbsp;$userinfo[&#39;headimgurl&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_nick_name&#39;]&nbsp;&nbsp;=&nbsp;mb_substr($userinfo[&#39;nickname&#39;],0,6,&quot;utf-8&quot;)&nbsp;.&nbsp;$count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_login_name&#39;]&nbsp;=&nbsp;&#39;wx_&#39;.$rand.&#39;&#39;.$count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_password&#39;]&nbsp;=&nbsp;md5(md5(time()));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_weixin_openid&#39;]&nbsp;&nbsp;=&nbsp;$userinfo[&quot;openid&quot;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_jingyan&#39;]&nbsp;=&nbsp;50; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session(&#39;kj_object&#39;,$data); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.location.href=&quot;http://www.13sai.com&#39;.U(&#39;Wap/Guide/binding&#39;).&#39;&quot;;&lt;/script&gt;&amp;#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}else{&nbsp;&nbsp;&nbsp;&nbsp;U(&#39;Wap/Index/login&#39;,&#39;&#39;,&#39;&#39;,true);}}}前台模板类似qq &nbsp;微博一键登录，就不赘述了。注意：这是微信里的一键登录，需要申请服务号，才能获取授权。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"一键登录（qq,weibo）","slug":"一键登录（qq,weibo）","date":"2016-09-04T07:44:48.000Z","updated":"2021-04-13T07:28:51.349Z","comments":true,"path":"2016/09/04/69/","link":"","permalink":"http://github.13sai.com/2016/09/04/69/","excerpt":"","text":"首先需要去qq，weibo申请密钥，然后会得到APPID和APPKEY，然后一步步操作，都有提示。成功后把配置写在common函数以便后期调用。&lt;?php //qq一键登录 function&nbsp;qqlogin_config(){&nbsp;&nbsp;&nbsp;&nbsp;define(&quot;QQDEBUG&quot;,&nbsp;false);&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(defined(&quot;QQDEBUG&quot;)&nbsp;&amp;&amp;&nbsp;QQDEBUG)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ini_set(&quot;error_reporting&quot;,&nbsp;E_ALL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ini_set(&quot;display_errors&quot;,&nbsp;TRUE);&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp; error_reporting(E_ALL^E_NOTICE);&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;session_start(); &nbsp;&nbsp;&nbsp;&nbsp;//申请到的appid&nbsp;&nbsp;&nbsp;&nbsp;$_SESSION[&quot;appid&quot;]&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&#39;&#39;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//申请到的appkey&nbsp;&nbsp;&nbsp;&nbsp;$_SESSION[&quot;appkey&quot;]&nbsp;&nbsp;&nbsp;=&nbsp;&quot;&quot;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//QQ登录成功后跳转的地址,请确保地址真实可用，否则会导致登录失败。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//一定要注意回调地址&nbsp;&nbsp;&nbsp;&nbsp;$_SESSION[&quot;callback&quot;]&nbsp;=&nbsp;&quot;http://&quot;&nbsp;.&nbsp;$_SERVER[&#39;SERVER_NAME&#39;]&nbsp;.&nbsp;&quot;/index.php/Home/OAuth/qqCallback&quot;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//QQ授权api接口.按需调用&nbsp;&nbsp;&nbsp;&nbsp;//$_SESSION[&quot;scope&quot;]&nbsp;=&nbsp;&quot;get_user_info,add_share,list_album,add_album,upload_pic,add_topic,add_one_blog,add_weibo&quot;;&nbsp;&nbsp;&nbsp;&nbsp;$_SESSION[&quot;scope&quot;]&nbsp;=&nbsp;&quot;get_user_info&quot;;} function&nbsp;qqlogin_do_post($url,&nbsp;$data){&nbsp;&nbsp;&nbsp;&nbsp;$ch&nbsp;=&nbsp;curl_init();&nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_RETURNTRANSFER,&nbsp;TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_POST,&nbsp;TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_POSTFIELDS,&nbsp;$data);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curl_setopt($ch,&nbsp;CURLOPT_URL,&nbsp;$url);&nbsp;&nbsp;&nbsp;&nbsp;$ret&nbsp;=&nbsp;curl_exec($ch); &nbsp;&nbsp;&nbsp;&nbsp;curl_close($ch);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$ret;}&nbsp;&nbsp;&nbsp;&nbsp;/———————————————-&nbsp;&nbsp;&nbsp;&nbsp;微博一键登录&nbsp;&nbsp;———————————————-/&nbsp;/**&nbsp;&nbsp;微博一键登录&nbsp;-&nbsp;配置&nbsp;/function&nbsp;weibo_config(){&nbsp;&nbsp;&nbsp;&nbsp;define(&nbsp;&quot;WB_AKEY&quot;&nbsp;,&nbsp;&#39;4002186908&#39;&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;define(&nbsp;&quot;WB_SKEY&quot;&nbsp;,&nbsp;&#39;dd81902ee3460eba972f46487aac41e2&#39;&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;define(&nbsp;&quot;WB_CALLBACK_URL&quot;&nbsp;,&nbsp;&#39;http://www.ayanglao.org.cn&#39;&nbsp;&nbsp;.&nbsp;U(&#39;Home/OAuth/weiboCallback&#39;));}然后就是OAuthAction&lt;?php class&nbsp;OAuthAction&nbsp;extends&nbsp;AppbaseAction&nbsp;{ public&amp;nbsp;function&amp;nbsp;qqLogin()&#123; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//….&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qqlogin_config(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_SESSION[&#39;state&#39;]&nbsp;=&nbsp;md5(uniqid(rand(),&nbsp;TRUE));&nbsp;//CSRF&nbsp;protection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$login_url&nbsp;=&nbsp;&quot;https://graph.qq.com/oauth2.0/authorize?response_type=code&amp;client_id=&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;$_SESSION[&quot;appid&quot;]&nbsp;.&nbsp;&quot;&amp;redirect_uri=&quot;&nbsp;.&nbsp;urlencode($_SESSION[&quot;callback&quot;])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&quot;&amp;state=&quot;&nbsp;.&nbsp;$_SESSION[&#39;state&#39;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&quot;&amp;scope=&quot;.$_SESSION[&quot;scope&quot;];&nbsp;&nbsp;&nbsp;&nbsp; //echo&nbsp;$login_url;&nbsp;&nbsp;&nbsp;&nbsp; //print_r($_SESSION);&nbsp;&nbsp;&nbsp;&nbsp; //die();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header(&quot;Location:$login_url&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;qqCallback(){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qqlogin_config(); //var_dump($_SESSION); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取token&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($_REQUEST[&#39;state&#39;]&nbsp;==&nbsp;$_SESSION[&#39;state&#39;])&nbsp;//csrf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$token_url&nbsp;=&nbsp;&quot;https://graph.qq.com/oauth2.0/token?grant_type=authorization_code&amp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&quot;client_id=&quot;&nbsp;.&nbsp;$_SESSION[&quot;appid&quot;].&nbsp;&quot;&amp;redirect_uri=&quot;&nbsp;.&nbsp;urlencode($_SESSION[&quot;callback&quot;])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&quot;&amp;client_secret=&quot;&nbsp;.&nbsp;$_SESSION[&quot;appkey&quot;].&nbsp;&quot;&amp;code=&quot;&nbsp;.&nbsp;$_REQUEST[&quot;code&quot;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$response&nbsp;=&nbsp;file_get_contents($token_url);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strpos($response,&nbsp;&quot;callback&quot;)&nbsp;!==&nbsp;false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$lpos&nbsp;=&nbsp;strpos($response,&nbsp;&quot;(&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$rpos&nbsp;=&nbsp;strrpos($response,&nbsp;&quot;)&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$response&nbsp;&nbsp;=&nbsp;substr($response,&nbsp;$lpos&nbsp;+&nbsp;1,&nbsp;$rpos&nbsp;-&nbsp;$lpos&nbsp;-1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$msg&nbsp;=&nbsp;json_decode($response);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isset($msg-&gt;error))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;&lt;h3&gt;error-token:&lt;/h3&gt;&quot;&nbsp;.&nbsp;$msg-&gt;error;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;&lt;h3&gt;msg&nbsp;&nbsp;:&lt;/h3&gt;&quot;&nbsp;.&nbsp;$msg-&gt;error_description;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$params&nbsp;=&nbsp;array();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parse_str($response,&nbsp;$params); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//print_r($params);die(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set&nbsp;access&nbsp;token&nbsp;to&nbsp;session&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_SESSION[&quot;access_token&quot;]&nbsp;=&nbsp;$params[&quot;access_token&quot;]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo(&quot;The&nbsp;state&nbsp;does&nbsp;not&nbsp;match.&nbsp;You&nbsp;may&nbsp;be&nbsp;a&nbsp;victim&nbsp;of&nbsp;CSRF.&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取open_id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$graph_url&nbsp;=&nbsp;&quot;https://graph.qq.com/oauth2.0/me?access_token=&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;$_SESSION[&#39;access_token&#39;]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$str&nbsp;&nbsp;=&nbsp;file_get_contents($graph_url);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strpos($str,&nbsp;&quot;callback&quot;)&nbsp;!==&nbsp;false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$lpos&nbsp;=&nbsp;strpos($str,&nbsp;&quot;(&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$rpos&nbsp;=&nbsp;strrpos($str,&nbsp;&quot;)&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$str&nbsp;&nbsp;=&nbsp;substr($str,&nbsp;$lpos&nbsp;+&nbsp;1,&nbsp;$rpos&nbsp;-&nbsp;$lpos&nbsp;-1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$user&nbsp;=&nbsp;json_decode($str);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isset($user-&gt;error))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;&lt;h3&gt;error-openid:&lt;/h3&gt;&quot;&nbsp;.&nbsp;$user-&gt;error;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;&lt;h3&gt;msg&nbsp;&nbsp;:&lt;/h3&gt;&quot;&nbsp;.&nbsp;$user-&gt;error_description;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo(&quot;Hello&nbsp;&quot;&nbsp;.&nbsp;$user-&gt;openid); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set&nbsp;openid&nbsp;to&nbsp;session&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_SESSION[&quot;openid&quot;]&nbsp;=&nbsp;$user-&gt;openid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;todo:&nbsp;进行登录与注册的判断 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取用户信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$graph_url&nbsp;=&nbsp;&quot;https://graph.qq.com/user/get_user_info&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&#39;?access_token=&#39;&nbsp;.&nbsp;$_SESSION[&#39;access_token&#39;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&#39;&amp;oauth_consumer_key=&#39;&nbsp;.&nbsp;$_SESSION[&#39;appid&#39;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&#39;&amp;openid=&#39;&nbsp;.&nbsp;$_SESSION[&quot;openid&quot;]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$str&nbsp;&nbsp;=&nbsp;file_get_contents($graph_url); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$json_result&nbsp;=&nbsp;json_decode($str);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($json_result-&gt;ret&nbsp;==&nbsp;&#39;0&#39;){&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$nickname&nbsp;=&nbsp;$json_result-&gt;nickname;&nbsp;//昵称&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$avatar&nbsp;=&nbsp;$json_result-&gt;figureurl_qq_2;&nbsp;//40*40的qq头像&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$gender&nbsp;=&nbsp;$json_result-&gt;gender;&nbsp;//性别&nbsp;&nbsp;&nbsp;&nbsp; //echo&nbsp;&#39;&lt;meta&nbsp;charset=&quot;utf-8&quot;&nbsp;/&gt;&#39;;&nbsp;&nbsp;&nbsp;&nbsp; //echo&nbsp;&quot;昵称：$nickname&lt;br&gt;性别：$gender&lt;br&gt;QQ头像：&lt;img&nbsp;src=$figureurl_qq_1&nbsp;/&gt;&quot;;die(); &nbsp;&nbsp;&nbsp;&nbsp; $row&nbsp;=&nbsp;M(&quot;member&quot;)-&gt;where(&quot;m_qq_openid=&#39;%s&#39;&quot;,$SESSION[&quot;openid&quot;])-&gt;find();&nbsp;&nbsp;&nbsp;&nbsp; if($row){ &nbsp;&nbsp;&nbsp;&nbsp;session(&#39;m_id&#39;,$row[&#39;m_id&#39;]); &nbsp;&nbsp;&nbsp;&nbsp;session(&#39;m_nick_name&#39;,$row[&#39;m_nick_name&#39;]); &nbsp;&nbsp;&nbsp;&nbsp;session(&#39;m_login_name&#39;,$row[&#39;m_login_name&#39;]); &nbsp;&nbsp;&nbsp;&nbsp;session(&#39;is_org&#39;,-1); &nbsp;&nbsp;&nbsp;&nbsp;//U(&#39;Home/Home/index&#39;,null,true,true); &nbsp;&nbsp;&nbsp;&nbsp;if(session(&#39;shebei&#39;)&nbsp;==&nbsp;1){&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;http://www.13sai.com&#39;.U(&#39;Wap/Home/index&#39;).&#39;&quot;;&lt;/script&gt;&amp;#39;;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.location.href=&quot;http://www.13sai.com&#39;.U(&#39;Wap/Home/index&#39;).&#39;&quot;;&lt;/script&gt;&amp;#39;; &nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;http://www.13sai.com&quot;;&lt;/script&gt;&amp;#39;; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;创建新用户&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count&nbsp;=&nbsp;M(&quot;member&quot;)-&gt;max(&#39;m_id&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$rand&nbsp;=&nbsp;mt_rand(1000,9999);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //$data[&#39;gender&#39;]&nbsp;&nbsp;=&nbsp;$gender;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; $data[&#39;m_avatar&#39;]&nbsp;&nbsp;=&nbsp;$avatar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; $data[&#39;m_nick_name&#39;]&nbsp;&nbsp;=&nbsp;mb_substr($nickname,0,6,&quot;utf-8&quot;)&nbsp;.&nbsp;$count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_login_name&#39;]&nbsp;=&nbsp;&#39;qq&#39;.$rand.&#39;&#39;.$count;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_password&#39;]&nbsp;=&nbsp;md5(md5(time()));&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; $data[&#39;m_qq_openid&#39;]&nbsp;&nbsp;=&nbsp;$_SESSION[&quot;openid&quot;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;from&#39;]&nbsp;=&nbsp;&#39;qq&#39;; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;session(&#39;kj_object&#39;,$data); &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if(session(&#39;shebei&#39;)&nbsp;==&nbsp;1){&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;http://www.13sai.com&#39;.U(&#39;Wap/Guide/binding&#39;).&#39;&quot;;&lt;/script&gt;&amp;#39;;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.location.href=&quot;http://www.13sai.com&#39;.U(&#39;Wap/Guide/binding&#39;).&#39;&quot;;&lt;/script&gt;&amp;#39;; &nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;http://www.13sai.com&#39;.U(&#39;Home/Guide/binding&#39;).&#39;&quot;;&lt;/script&gt;&amp;#39;; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;http://www.13sai.com&quot;;&lt;/script&gt;&amp;#39;;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;111&#39;.$str;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//微博一键登录（登录）&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;weiboLogin(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session_start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weibo_config();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vendor(&#39;Weibo.saetv2ex&#39;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$o&nbsp;=&nbsp;new&nbsp;SaeTOAuthV2(&nbsp;WB_AKEY&nbsp;,&nbsp;WB_SKEY&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$code_url&nbsp;=&nbsp;$o-&gt;getAuthorizeURL(&nbsp;WB_CALLBACK_URL&nbsp;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header(&quot;Location:&nbsp;&quot;&nbsp;.&nbsp;$code_url);&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//微博一键登录（回调）&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;weiboCallback(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session_start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_reporting(E_ERROR);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weibo_config();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vendor(&#39;Weibo.saetv2ex&#39;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$o&nbsp;=&nbsp;new&nbsp;SaeTOAuthV2(&nbsp;WB_AKEY&nbsp;,&nbsp;WB_SKEY&nbsp;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isset($_REQUEST[&#39;code&#39;]))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $keys&nbsp;=&nbsp;array();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $keys[&#39;code&#39;]&nbsp;=&nbsp;$_REQUEST[&#39;code&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $keys[&#39;redirect_uri&#39;]&nbsp;=&nbsp;WB_CALLBACK_URL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $token&nbsp;=&nbsp;$o-&gt;getAccessToken(&nbsp;&#39;code&#39;,&nbsp;$keys&nbsp;)&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;catch&nbsp;(OAuthException&nbsp;$e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($token)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $SESSION[&#39;token&#39;]&nbsp;=&nbsp;$token;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setcookie(&nbsp;&#39;weibojs&#39;.$o-&gt;client_id,&nbsp;http_build_query($token)&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $c&nbsp;=&nbsp;new&nbsp;SaeTClientV2(&nbsp;WB_AKEY&nbsp;,&nbsp;WB_SKEY&nbsp;,&nbsp;$_SESSION[&#39;token&#39;][&#39;access_token&#39;]&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ms&nbsp;&nbsp;=&nbsp;$c-&gt;home_timeline();&nbsp;//&nbsp;done&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $uid_get&nbsp;=&nbsp;$c-&gt;get_uid();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $uid&nbsp;=&nbsp;$uid_get[&#39;uid&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $user_message&nbsp;=&nbsp;$c-&gt;show_user_by_id(&nbsp;$uid);//根据ID获取用户等基本信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //保存几个基本信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $openid&nbsp;=&nbsp;$user_message[&#39;id&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $nickname&nbsp;=&nbsp;$user_message[&#39;screen_name&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $avatar&nbsp;=&nbsp;$user_message[&#39;profile_image_url&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $gender&nbsp;=&nbsp;$user_message[&#39;gender&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $gender&nbsp;=&nbsp;($gender==&#39;m&#39;)?&#39;男&#39;:&#39;女&#39;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /以下为写本地数据库/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //通过&nbsp;$openid&nbsp;检查用户是否存在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if(存在){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;创建新用户&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;设置登录状态&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //dump($user_message); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $row&nbsp;=&nbsp;M(&quot;member&quot;)-&gt;where(&quot;m_weibo_openid=&#39;%s&#39;&quot;,$openid)-&gt;find();&nbsp;&nbsp;&nbsp;&nbsp; if($row){ &nbsp;&nbsp;&nbsp;&nbsp;session(&#39;m_id&#39;,$row[&#39;m_id&#39;]); &nbsp;&nbsp;&nbsp;&nbsp;session(&#39;m_nick_name&#39;,$row[&#39;m_nick_name&#39;]); &nbsp;&nbsp;&nbsp;&nbsp;session(&#39;m_login_name&#39;,$row[&#39;m_login_name&#39;]); &nbsp;&nbsp;&nbsp;&nbsp;session(&#39;is_org&#39;,-1); &nbsp;&nbsp;&nbsp;&nbsp;//U(&#39;Home/Home/index&#39;,null,true,true); &nbsp;&nbsp;&nbsp;&nbsp;if(session(&#39;shebei&#39;)&nbsp;==&nbsp;1){&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;http://www.13sai.com&#39;.U(&#39;Wap/Home/index&#39;).&#39;&quot;;&lt;/script&gt;&amp;#39;; &nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;http://www.13sai.com&quot;;&lt;/script&gt;&amp;#39;; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;http://www.13sai.com&quot;;&lt;/script&gt;&amp;#39;;&nbsp;&nbsp;&nbsp;&nbsp; }else{&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;创建新用户&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count&nbsp;=&nbsp;M(&quot;member&quot;)-&gt;max(&#39;m_id&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$rand&nbsp;=&nbsp;mt_rand(1000,9999);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //$data[&#39;gender&#39;]&nbsp;&nbsp;=&nbsp;$gender;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; $data[&#39;m_avatar&#39;]&nbsp;&nbsp;=&nbsp;$avatar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; $data[&#39;m_nick_name&#39;]&nbsp;&nbsp;=&nbsp;mb_substr($nickname,0,6,&quot;utf-8&quot;)&nbsp;.&nbsp;$count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_login_name&#39;]&nbsp;=&nbsp;&#39;wb_&#39;.$rand.&#39;&#39;.$count;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;m_password&#39;]&nbsp;=&nbsp;md5(md5(time()));&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; $data[&#39;m_weibo_openid&#39;]&nbsp;&nbsp;=&nbsp;$openid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$data[&#39;from&#39;]&nbsp;=&nbsp;&#39;weibo&#39;; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;session(&#39;kj_object&#39;,$data); &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if(session(&#39;shebei&#39;)&nbsp;==&nbsp;1){&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;http://www.13sai.com&#39;.U(&#39;Wap/Guide/binding&#39;).&#39;&quot;;&lt;/script&gt;&amp;#39;; &nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#39;&lt;script&gt;window.close();window.opener.location.href=&quot;http://www.13sai.com&#39;.U(&#39;Home/Guide/binding&#39;).&#39;&quot;;&lt;/script&gt;&amp;#39;; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //跳转到会员中心 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo&nbsp;&#39;授权失败&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;} }前台调用比较简单&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;yijian&nbsp;wd-center&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&nbsp;class=&quot;wd-left&quot;&gt;使用其他账号登录&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;onclick=&quot;toQzoneLogin()&quot;&nbsp;class=&quot;other_login&nbsp;other_login_qq&quot;&gt;&lt;img&nbsp;src=&quot;/webui/home/images/Q.png&quot;&gt;&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;onclick=&quot;toWeiboLogin()&quot;&gt;&lt;img&nbsp;src=&quot;/webui/home/images/weibo.png&quot;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/div&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;script&gt;function&nbsp;toQzoneLogin(){ var&nbsp;A=window.open(&quot;http://www.ayanglao.org.cn{:U(&#39;Home/OAuth/qqLogin&#39;,&#39;&#39;,false)}/&quot;+Math.random(),&quot;TencentLogin&quot;,&quot;width=600,height=480,menubar=0,scrollbars=1,&nbsp;resizable=1,status=1,titlebar=0,toolbar=0,location=1&quot;);} function&nbsp;toWeiboLogin(){ var&nbsp;A=window.open(&quot;http://www.ayanglao.org.cn{:U(&#39;Home/OAuth/weiboLogin&#39;,&#39;&#39;,false)}/&quot;+Math.random(),&quot;WeiboLogin&quot;,&quot;width=450,height=320,menubar=0,scrollbars=1,&nbsp;resizable=1,status=1,titlebar=0,toolbar=0,location=1&quot;);}&lt;/script&gt;这样就ok了。下次说说微信登录。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"解决ThinkPHP多文件上传重名的问题","slug":"解决ThinkPHP多文件上传重名的问题","date":"2016-09-04T07:29:32.000Z","updated":"2021-04-13T07:21:57.910Z","comments":true,"path":"2016/09/04/68/","link":"","permalink":"http://github.13sai.com/2016/09/04/68/","excerpt":"","text":"前几天开发时，需要同时上传两张图，但总出现问题，打开提示，显示的事文件名已存在。各种搜索，没找到解决方法，然后就改成了uploadify上传，但治标不治本，同事说可以修改uploadFile的类，获取savename时增加随机数。修改savenameprivate&nbsp;function&nbsp;getSaveName($filename)&nbsp;{ $rand&nbsp;=&nbsp;mt_rand(1000,9999);&nbsp;&nbsp;//生成五位随机数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$rule&nbsp;=&nbsp;$this-&gt;saveRule; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(empty($rule))&nbsp;{//没有定义命名规则，则保持文件名不变 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$saveName&nbsp;=&nbsp;$filename[&#39;name&#39;]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(function_exists($rule))&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用函数生成一个唯一文件标识号&nbsp;&nbsp;加入随机数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$saveName&nbsp;=&nbsp;$rule().$rand.&quot;.&quot;.$filename[&#39;extension&#39;]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用给定的文件名作为标识号 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$saveName&nbsp;=&nbsp;$rule.$rand.&quot;.&quot;.$filename[&#39;extension&#39;]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($this-&gt;autoSub)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;使用子目录保存文件 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$filename[&#39;savename&#39;]&nbsp;=&nbsp;$saveName; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$saveName&nbsp;=&nbsp;$this-&gt;getSubName($filename).$saveName; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$saveName; &nbsp;&nbsp;&nbsp;&nbsp;}这样就几乎不会出现同名的情况了。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://github.13sai.com/tags/ThinkPHP/"}]},{"title":"uploadify的使用","slug":"uploadify的使用","date":"2016-09-02T12:22:17.000Z","updated":"2021-04-13T07:34:58.280Z","comments":true,"path":"2016/09/02/67/","link":"","permalink":"http://github.13sai.com/2016/09/02/67/","excerpt":"","text":"Uploadify是JQuery的一个上传插件，实现的效果非常不错，带进度显示。我用的版本是2.2.&lt;!DOCTYPE&nbsp;html&gt; &lt;html&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;include&nbsp;file=&quot;./Tpl/head&quot;&nbsp;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;body&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--引用css--&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;link&nbsp;href=&quot;/Skin/public/uploadify/uploadify.css&quot;&nbsp;type=&quot;text/css&quot;&nbsp;rel=&quot;stylesheet&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;include&nbsp;file=&quot;./Tpl/top&quot;&nbsp;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;main-container&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;id=&quot;menu-toggler&quot;&nbsp;href=&quot;#&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&gt;&lt;/span&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/a&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;include&nbsp;file=&quot;./Tpl/left&quot;&nbsp;/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;breadcrumbs&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{ace.settings.check(&#39;breadcrumbs&#39;&nbsp;,&nbsp;&#39;fixed&#39;)}catch(e){}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;i&nbsp;class=&quot;icon-home&nbsp;home-icon&quot;&gt;&lt;/i&gt;&lt;a&nbsp;href=&quot;{:U(&#39;/Admin/Index/index&#39;)}&quot;&gt;管理后台&lt;/a&gt;&lt;/li&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;{$column_name}管理&lt;/li&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;修改&lt;/li&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;&lt;!–&nbsp;.breadcrumb&nbsp;–&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;widget-header&nbsp;widget-header-small&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h5&gt;修改内容&lt;/h5&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;id=&quot;updateForm&quot;&nbsp;action=&quot;{:U(&#39;Admin/Home/caseUpdate&#39;)}&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method=&quot;POST&quot;&nbsp;enctype=&quot;multipart/form-data&quot;&nbsp;onsubmit=&quot;return&nbsp;jQuery(this).validationEngine(&#39;validate&#39;);&quot;&nbsp;role=&quot;form&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;hidden&quot;&nbsp;name=&quot;c_id&quot;&nbsp;value=&quot;{$data.c_id}&quot;&nbsp;/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;hidden&quot;&nbsp;name=&quot;httpref&quot;&nbsp;value=&quot;{$httpref}&quot;&nbsp;/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;col-sm-1&nbsp;control-label&nbsp;no-padding-right&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for=&quot;form-field-1&quot;&gt;&nbsp;标题&nbsp;&lt;/label&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;c_name&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value=&quot;{$data[&#39;c_name&#39;]}&quot;&nbsp;placeholder=&quot;如李潇潇&quot;&nbsp;class=&quot;col-xs-10&nbsp;col-sm-5&nbsp;validate[required,maxSize[40]]&quot;&nbsp;/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;col-sm-1&nbsp;control-label&nbsp;no-padding-right&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for=&quot;form-field-1&quot;&gt;&nbsp;头像&nbsp;&lt;/label&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;file&quot;&nbsp;name=&quot;file_upload&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id=&quot;file_upload&quot;/&gt;&amp;nbsp;&amp;nbsp;大小223px431px;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;hidden&quot;&nbsp;name=&quot;c_avatar&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id=&quot;c_avatar&quot;&nbsp;value=&quot;{$data[&#39;c_avatar&#39;]}&quot;/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;&lt;img&nbsp;src=&quot;{$data[&#39;c_avatar&#39;]}&quot;&nbsp;style=&quot;width:&nbsp;80px;&nbsp;height:&nbsp;100px;&quot;&nbsp;id=&quot;newsimg&quot;&nbsp;class=&quot;newsimgpre&nbsp;uploadimg&quot;&gt;&lt;/p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;clearfix&nbsp;form-actions&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;col-md-offset-1&nbsp;col-md-11&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;class=&quot;btn&nbsp;btn-info&quot;&nbsp;onclick=&quot;$(&#39;#updateForm&#39;).submit();&quot;&nbsp;type=&quot;button&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i&nbsp;class=&quot;icon-ok&nbsp;bigger-110&quot;&gt;&lt;/i&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提交&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp;&nbsp;&amp;nbsp;&nbsp;&amp;nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;id=&quot;backid&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i&nbsp;class=&quot;icon-undo&nbsp;bigger-110&quot;&gt;&lt;/i&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回列表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/a&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;include&nbsp;file=&quot;./Tpl/bottom&quot;&nbsp;/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;href=&quot;#&quot;&nbsp;id=&quot;btn-scroll-up&quot;&nbsp;class=&quot;btn-scroll-up&nbsp;btn&nbsp;btn-sm&nbsp;btn-inverse&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i&nbsp;class=&quot;icon-double-angle-up&nbsp;icon-only&nbsp;bigger-110&quot;&gt;&lt;/i&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/a&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&lt;!–&nbsp;/.main-container&nbsp;–&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;include&nbsp;file=&quot;./Tpl/foot&quot;&nbsp;/&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!–引用js–&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=&quot;/Skin/public/uploadify/jquery.uploadify.min.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&gt;&nbsp;&nbsp;&nbsp;&nbsp;$(function(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#file_upload&#39;).uploadify({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//注意这里&nbsp;&nbsp;uploadify无法传递session&nbsp;&nbsp;只能通过formData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;formData&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;?php&nbsp;echo&nbsp;session_name();?&gt;&#39;&nbsp;:&nbsp;&#39;&lt;?php&nbsp;echo&nbsp;session_id();?&gt;&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;timestamp&#39;&nbsp;:&nbsp;&#39;&lt;?php&nbsp;echo&nbsp;$timestamp;?&gt;&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;token&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&#39;&lt;?php&nbsp;echo&nbsp;md5(&#39;unique_salt&#39;&nbsp;.&nbsp;$timestamp);?&gt;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;swf&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&#39;/Skin/public/uploadify/uploadify.swf&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;uploader&#39;&nbsp;:&nbsp;&quot;{:U(&#39;Admin/Home/uploadify&#39;)}&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;buttonText&#39;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&#39;选择图片&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;buttonClass&#39;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&#39;upload_button&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;fileTypeDesc&#39;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&#39;图片文件&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;width&#39;:&#39;100px&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;height&#39;:&#39;50px&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&#39;fileTypeExts&#39;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&#39;.gif;.jpg;.png;*.jpeg&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&#39;fileSizeLimit&#39;&nbsp;:&nbsp;&#39;50000&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;progressData&#39;:&nbsp;&#39;percentage&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;onUploadSuccess&#39;&nbsp;:&nbsp;function(file,&nbsp;data,&nbsp;response)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//var&nbsp;path=data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//alert(data)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;data&nbsp;=&nbsp;JSON.parse(data);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(data.status&nbsp;==&nbsp;0){alert(&#39;上传失败&#39;);return&nbsp;false;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#newsimg&#39;).attr(&quot;src&quot;,data.data);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#c_avatar&#39;).val(data.data);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Your&nbsp;options&nbsp;here&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;actionpublic&nbsp;function&nbsp;uploadify()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import(&#39;ORG.Net.UploadFile&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$upload&nbsp;=&nbsp;new&nbsp;UploadFile();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$upload-&gt;maxSize&nbsp;&nbsp;=&nbsp;20480000&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$upload-&gt;allowExts&nbsp;&nbsp;=&nbsp;array(&#39;jpg&#39;,&nbsp;&#39;jpeg&#39;,&nbsp;&#39;png&#39;,&nbsp;&#39;gif&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$upload-&gt;savePath&nbsp;=&nbsp;&nbsp;&#39;./Upload/case/&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$upload-&gt;saveRule&nbsp;=&nbsp;&#39;uniqid&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return&nbsp;&nbsp;=&nbsp;array(&#39;status&#39;&nbsp;=&gt;&nbsp;1,&nbsp;&#39;info&#39;&nbsp;=&gt;&nbsp;&#39;上传成功&#39;,&nbsp;&#39;data&#39;&nbsp;=&gt;&nbsp;&#39;&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//$upload-&gt;saveRule&nbsp;=&nbsp;&#39;getrand&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!$upload-&gt;upload()){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return[&#39;status&#39;]&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return[&#39;info&#39;]&nbsp;&nbsp;&nbsp;=&nbsp;$upload-&gt;getErrorMsg();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return[&#39;status&#39;]&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$info&nbsp;=&nbsp;&nbsp;$upload-&gt;getUploadFileInfo();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$return[&#39;data&#39;]&nbsp;&nbsp;&nbsp;=&nbsp;&#39;/Upload/case/&#39;.$info[0][savename];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;json_encode($return);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}因为这是后台上传图片的地方，需要限制权限/处理权限/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$session_name&nbsp;=&nbsp;session_name();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//dump($session_name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;$_POST[$session_name];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!isset($_POST[$session_name])){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($_SESSION[&#39;u_name&#39;]&nbsp;==&nbsp;&#39;&#39;){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;error(&#39;登录已超时&#39;,&nbsp;U(&quot;Admin/Index/login&quot;),&nbsp;3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}来看看效果，还不错哟！","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"php的break","slug":"php的break","date":"2016-08-23T12:51:30.000Z","updated":"2021-04-13T07:37:24.514Z","comments":true,"path":"2016/08/23/65/","link":"","permalink":"http://github.13sai.com/2016/08/23/65/","excerpt":"","text":"PHP中的break非常常见，相信大家都用过。 但break后面带参数你见过吗？ 前两天遇到个3层循环的问题，因为需要限制数量，使用break，但break出来，发现页面不是我想要的，然后有记得有跳出多层循环的函数，最后发现只需要在break后面加上2就可以跳出两层循环了。 1234567891011121314151617181920212223&lt;ul class=&quot;friendlink-ul&quot;&gt; &lt;li class=&quot;friendlink-li&quot;&gt;友情链接&lt;/li&gt; &lt;volist name=&quot;cateList&quot; id=&quot;vo&quot;&gt; &lt;li class=&quot;friendlink-li&quot;&gt; &lt;ul&gt; &lt;?php $k = 0; ?&gt; &lt;volist name=&quot;friendlylinkList&quot; id=&quot;vof&quot;&gt; &lt;if condition=&quot;$vof[&#x27;link_cate_id&#x27;] eq $vo[&#x27;cate_id&#x27;]&quot;&gt; &lt;?php $k++; if($k&gt;5) break 2; ?&gt; &lt;li&gt;&lt;a href=&quot;&#123;$vof[&#x27;linkUrl&#x27;]&#125;&quot; target=&quot;_blank&quot; title=&quot;&#123;$vof[&#x27;linkName&#x27;]&#125;&quot;&gt;&#123;:msubstr($vof[&#x27;linkName&#x27;], 0, 20, &#x27;utf-8&#x27;, false)&#125;&lt;/a&gt;&lt;/li&gt; &lt;/if&gt; &lt;/volist&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/volist&gt;&lt;/ul&gt; 是不是很好用？","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"MySQL数据类型和常用字段属性","slug":"MySQL数据类型和常用字段属性","date":"2016-08-10T08:14:07.000Z","updated":"2021-04-13T07:33:22.371Z","comments":true,"path":"2016/08/10/64/","link":"","permalink":"http://github.13sai.com/2016/08/10/64/","excerpt":"","text":"一直以为int(11)就可以存储11位的数字，原来这是不正确的。网上搜搜，总结如下：MySQL中的数据类型大的方面来分，可以分为：日期和时间、数值，以及字符串。日期和时间数据类型MySQL数据类型含义date3字节，日期，格式：2014-09-18time3字节，时间，格式：08:42:30datetime8字节，日期时间，格式：2014-09-18 08:42:30timestamp4字节，时间戳，格式：2014-09-18 08:42:30year1字节，年份数值数据类型整型MySQL数据类型含义（有符号）tinyint1字节，范围（-128~127）一直误会了smallint2字节，范围（-32768~32767）mediumint3字节，范围（-8388608~8388607）int4字节，范围（-2147483648~2147483647）bigint8字节，范围（+-9.22*10的18次方）上面定义的都是有符号的，当然了，也可以加上unsigned关键字，定义成无符号的类型，那么对应的取值范围就要翻翻了，比如：tinyint unsigned的取值范围为0~255。浮点型MySQL数据类型含义float(m, d)4字节，单精度浮点型，m总个数，d小数位double(m, d)8字节，双精度浮点型，m总个数，d小数位decimal(m, d)decimal是存储为字符串的浮点数我在MySQL中建立了一个表，有一列为float(5, 3)；做了以下试验：1.插入123.45678，最后查询得到的结果为99.999；2.插入123.456，最后查询结果为99.999；3.插入12.34567，最后查询结果为12.346；所以，在使用浮点型的时候，还是要注意陷阱的，要以插入数据库中的实际结果为准。字符串数据类型MySQL数据类型含义char(n)固定长度，最多255个字符varchar(n)可变长度，最多65535个字符tinytext可变长度，最多255个字符text可变长度，最多65535个字符mediumtext可变长度，最多2的24次方-1个字符longtext可变长度，最多2的32次方-1个字符1.char（n）和varchar（n）中括号中n代表字符的个数，并不代表字节个数，所以当使用了中文的时候(UTF8)意味着可以插入m个中文，但是实际会占用m*3个字节。2.同时char和varchar最大的区别就在于char不管实际value都会占用n个字符的空间，而varchar只会占用实际字符应该占用的空间+1，并且实际空间+1&lt;=n。3.超过char和varchar的n设置后，字符串会被截断。4.char的上限为255字节，varchar的上限65535字节，text的上限为65535。5.char在存储的时候会截断尾部的空格，varchar和text不会。6.varchar会使用1-3个字节来存储长度，text不会。选择原则：1、通常最小的是最好的&nbsp; &nbsp; &nbsp;因为这样可以用更少的磁盘、内容、CPU缓存，大大减少IO开销，当然前提是满足业务需要。2、简单就好&nbsp; &nbsp; &nbsp;简单的数据类型操作通常需要更少的CPU周期。例如，整型比字符操作代价更小，因为字符集和校对规则（排序规则）使它比整型更复杂。比如应该使用MySQL内建的类型而不是使用字符型来存储日期和时间。3、尽量避免使用NULL&nbsp; &nbsp; &nbsp;NULL是列默认的属性，通常我们要指定为NOT NULL。有NULL的列值会使得索引、索引统计和值比较更加复杂。可为NULL的列会使用更多的存储空间，在MySQL中也需要对它进行特殊处理，当可 为NULL列做索引时，每个索引需要一个额外的字节，在MyISAM更有可能导致固定大小的索引变成可变大小索引，在InnoDB中使用单独的位 (bit)存储NULL值。就这些了，大部分网上贴过来的。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/tags/sql/"}]},{"title":"js获取select的值","slug":"js获取select的值","date":"2016-08-09T12:14:18.000Z","updated":"2021-04-13T07:31:31.488Z","comments":true,"path":"2016/08/09/63/","link":"","permalink":"http://github.13sai.com/2016/08/09/63/","excerpt":"","text":"最近做一个手机项目时，遇到一个问题。选分类时需要根据不同类型，改变字段。之前加的是点击事件控制显隐，火狐反应正常，但手机上没有效果。不得不抛弃这种写法，改为获取select选中option值判断，来控制字段显隐。点击控制的代码就不写了，比较简单，贴上获取select方法代码：&lt;!--&nbsp;主体&nbsp;--&gt; &lt;div&nbsp;class=&quot;am-container&nbsp;am-margin-top&nbsp;reg&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-tabs-bd&nbsp;sai-noborder&nbsp;am-margin-top&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-tab-panel&nbsp;sai-nopadding&nbsp;am-active&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;method=&quot;post&quot;&nbsp;action=&quot;{:U(&#39;Wap/Index/reg2&#39;)}&quot;&nbsp;enctype=&quot;multipart/form-data&quot;&nbsp;&nbsp;id=&quot;form2&quot;&nbsp;class=&quot;am-form&nbsp;am-form-horizontal&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;reg-tab-li&nbsp;am-g&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;am-u-md-3&quot;&gt;团体名称：&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-u-md-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;o_name&quot;&nbsp;class=&quot;login-text&nbsp;yan-tt&nbsp;nick&quot;&nbsp;placeholder=&quot;请输入团体名称&quot;&gt;&lt;span&gt;&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;reg-tab-li&nbsp;am-g&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;am-u-md-3&quot;&gt;类型：&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-u-md-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;select&nbsp;name=&quot;o_type&quot;&nbsp;id=&quot;select&quot;&nbsp;onchange=&quot;getValue()&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;volist&nbsp;name=&quot;list_jigou&quot;&nbsp;id=&quot;vo&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option&nbsp;value=&quot;{$vo[&#39;d_value&#39;]}&quot;&nbsp;&lt;if&nbsp;condition=&quot;$i&nbsp;neq&nbsp;4&quot;&gt;class=&quot;dd&quot;&nbsp;&lt;else/&gt;&nbsp;class=&quot;dd2&quot;&lt;/if&gt;&gt;{$vo[&#39;d_title&#39;]}&lt;/option&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/volist&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/select&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;daima2&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;reg-tab-li&nbsp;am-g&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;am-u-md-3&quot;&gt;证件号码：&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-u-md-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;o_yingyezhizhao_no&quot;&nbsp;class=&quot;login-text&nbsp;yan-zhzh&quot;&nbsp;placeholder=&quot;请输入等级证书/营业执照等相关证件号码&quot;&gt;&lt;span&gt;&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;reg-tab-li&nbsp;am-g&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;am-u-md-3&quot;&gt;上传扫描件：&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-u-md-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;file&quot;&nbsp;name=&quot;o_yingyezhizhao_img&nbsp;yan-required&quot;&nbsp;value=&quot;&quot;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;daima&nbsp;sai-hide&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;reg-tab-li&nbsp;am-g&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;am-u-md-3&quot;&gt;团体简介：&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-u-md-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;textarea&nbsp;name=&quot;o_desc&quot;&nbsp;rows=&quot;5&quot;&nbsp;class=&quot;yan-desc&quot;&nbsp;placeholder=&quot;请简单介绍下您所在的团体，不超过200字！&quot;&gt;&lt;/textarea&gt;&lt;span&gt;&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;reg-tab-li&nbsp;am-g&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;am-u-md-3&quot;&gt;创建密码：&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-u-md-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;password&quot;&nbsp;name=&quot;o_password&quot;&nbsp;class=&quot;login-text&nbsp;yan-pw&quot;&nbsp;placeholder=&quot;请输入密码&quot;&gt;&lt;span&gt;&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;reg-tab-li&nbsp;am-g&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;class=&quot;am-u-md-3&quot;&gt;确认密码：&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-u-md-9&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;password&quot;&nbsp;name=&quot;o_password2&quot;&nbsp;class=&quot;login-text&nbsp;yan-pw2&quot;&nbsp;placeholder=&quot;请再次输入密码&quot;&gt;&lt;span&gt;&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;wd-h15&nbsp;wd-clear&quot;&gt;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;reg-tab-li&nbsp;am-g&nbsp;reg-tab-li&nbsp;am-g2&nbsp;am-margin-top&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;type=&quot;button&quot;&nbsp;class=&quot;l-btn&nbsp;btn2&nbsp;am-btn&nbsp;am-btn-block&nbsp;sai-bred&quot;&nbsp;onclick=&quot;sub2();&quot;&gt;注册&lt;/button&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;reg-tab-li&nbsp;am-g&nbsp;reg-tab-li&nbsp;am-g2&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;class=&quot;wd-fs12&nbsp;xieyi&quot;&nbsp;target=&quot;_blank&quot;&nbsp;href=&quot;{:U(&#39;Wap/Index/page&#39;,array(&#39;column_id&#39;=&gt;8))}&quot;&gt;注册代表你同意&lt;em&gt;《爱德国际仁谷注册协议》&lt;/em&gt;&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &lt;/div&gt; &lt;script&gt;&nbsp;&nbsp;&nbsp;&nbsp;;function&nbsp;getValue(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/第一种方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;val=&nbsp;$(&quot;#select&nbsp;option:selected&quot;).val();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;val=&nbsp;$(&#39;#select&#39;).find(&quot;option:selected&quot;).val();/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/第二种方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj=&nbsp;document.getElementById(&#39;select&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;val&nbsp;=&nbsp;obj.selectedIndex;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj=&nbsp;document.getElementById(&#39;select&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;val&nbsp;=&nbsp;obj.options[obj.options.selectedIndex].value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(val&nbsp;==&nbsp;3){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;.daima2&#39;).hide();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;.daima&#39;).show();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;.daima&#39;).hide();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;.daima2&#39;).show();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}};&lt;/script&gt;当然注释的两种方法也是可行的，粗粗测试下，火狐也兼容。是不是很好用？","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"判断是否为微信内置浏览器","slug":"判断是否为微信内置浏览器","date":"2016-08-05T08:07:20.000Z","updated":"2021-04-26T03:42:34.751Z","comments":true,"path":"2016/08/05/62/","link":"","permalink":"http://github.13sai.com/2016/08/05/62/","excerpt":"","text":"原理：获取微信内置浏览器的User Agent，并加以判断。直接上代码：js：function&nbsp;isWeiXin(){ &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;ua&nbsp;=&nbsp;window.navigator.userAgent.toLowerCase(); &nbsp;&nbsp;&nbsp;&nbsp;//var&nbsp;ua&nbsp;=&nbsp;navigator.userAgent.toLowerCase();&nbsp;二选一 &nbsp;&nbsp;&nbsp;&nbsp;if(ua.match(/MicroMessenger/i)&nbsp;==&nbsp;&#39;micromessenger&#39;){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(1); &nbsp;&nbsp;&nbsp;&nbsp;}else{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(0); }phpfunction&nbsp;isWeixin(){&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;strpos($_SERVER[&#39;HTTP_USER_AGENT&#39;],&nbsp;&#39;MicroMessenger&#39;)&nbsp;!==&nbsp;false&nbsp;)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true; &nbsp;&nbsp;&nbsp;&nbsp;}else{ return&nbsp;false; &nbsp;&nbsp;&nbsp;&nbsp;} }","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"jQuery判断checkbox是否选中的方法","slug":"jQuery判断checkbox是否选中的方法","date":"2016-08-03T06:59:35.000Z","updated":"2021-04-13T07:31:22.075Z","comments":true,"path":"2016/08/03/61/","link":"","permalink":"http://github.13sai.com/2016/08/03/61/","excerpt":"","text":"需要做一个必须勾选协议才能购买的表单，往往要判断是否勾选checkbox，之前遇到过，但没有好好解决，这次又遇到，边彻底解决这个问题。其实这个问题的核心是获取checked属性的问题并加以判断，网上文章很多，大致方法有三：&lt;form&nbsp;role=&quot;form&quot;&nbsp;action=&quot;&quot;&nbsp;method=&quot;post&quot;&nbsp;onsubmit=&quot;return&nbsp;jQuery(this).validationEngine(&#39;validate&#39;);&quot;&nbsp;id=&quot;form&quot;&gt; &nbsp;&nbsp;&lt;div&nbsp;class=&quot;box-body&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;for=&quot;m_login_name&quot;&gt;购买数量&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;d_number&quot;&nbsp;class=&quot;validate[required,maxSize[10],custom[number]]&nbsp;form-control&quot;&nbsp;placeholder=&quot;请填写数字,单位：个&quot;&nbsp;data-prompt-position=&quot;topLeft&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&nbsp;style=&quot;height:&nbsp;100px;&nbsp;overflow-x:&nbsp;hidden;&nbsp;overflow-y:&nbsp;scroll;&nbsp;border:&nbsp;1px&nbsp;solid&nbsp;#d2d6de;;&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协议内容 &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;checkbox&quot;&nbsp;id=&quot;check&quot;&nbsp;checked/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;for=&quot;m_login_name&quot;&gt;我同意《协议》&lt;/label&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;box-footer&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;type=&quot;button&quot;&nbsp;class=&quot;btn&nbsp;btn-primary&quot;&nbsp;id=&quot;buy&quot;&gt;立即购买&lt;/button&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&lt;/div&gt; &lt;/form&gt;第一种is(&#39;:checked&#39;) &lt;script&nbsp;type=&quot;text/javascript&quot;&gt; ;$(function(){ &nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#buy&#39;).on(&#39;click&#39;,function(){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;isCheck&nbsp;=&nbsp;$(&#39;#check&#39;).is(&#39;:checked&#39;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert（isCheck&nbsp;） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}); }) &lt;/script&gt;第二种attr(&#39;checked&#39;) &lt;script&nbsp;type=&quot;text/javascript&quot;&gt; ;$(function(){ &nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#buy&#39;).on(&#39;click&#39;,function(){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;isCheck&nbsp;=&nbsp;$(&#39;#check&#39;).attr(&#39;checked&#39;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert（isCheck&nbsp;） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}); }) &lt;/script&gt;第三种checked &lt;script&nbsp;type=&quot;text/javascript&quot;&gt; ;$(function(){ &nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#buy&#39;).on(&#39;click&#39;,function(){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;isCheck&nbsp;=&nbsp;$(&#39;#check&#39;).checked; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert（isCheck&nbsp;） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}); }) &lt;/script&gt;亲测（firefox，chrome），仅有is(&#39;:checked&#39;)成功获取，选中则true，未选中则为false。attr会根据初始值，若初始值选中就是checked，否则undefined，点击选择时不会变化值。checked则一直都是undefined。然后想到上次用到的prop，替换掉attr，成功获取，选中则true，未选中则为false。结语：获取checkbox请使用prop(&#39;checked&#39;)或is(&#39;:checked&#39;)，那什么都是骗人的。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"表单中submit提交失败的问题","slug":"表单中submit提交失败的问题","date":"2016-08-02T12:05:41.000Z","updated":"2020-12-09T10:46:14.789Z","comments":true,"path":"2016/08/02/60/","link":"","permalink":"http://github.13sai.com/2016/08/02/60/","excerpt":"","text":"昨天开发时遇到个表单不能提交的问题，反复检查代码似乎都毫无问题，不得不寻找答案，发现了jquery的这个问题。 主要代码如下： 1234567891011121314151617181920212223242526&lt;form role=&quot;form&quot; action=&quot;&quot; method=&quot;post&quot; onsubmit=&quot;return jQuery(this).validationEngine(&#x27;validate&#x27;);&quot; id=&quot;form&quot;&gt; &lt;div class=&quot;box-body&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;m_login_name&quot;&gt;购买备注&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;q_remark&quot; class=&quot;validate[required,maxSize[200]] form-control&quot; placeholder=&quot;请填写购买备注&quot; data-prompt-position=&quot;topLeft&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;submit&quot; &gt;立即购买&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;&lt;script src=&quot;/webui/adminlte/plugins/jQuery/jQuery-2.2.0.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/Skin/public/layer/layer.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(&quot;#submit&quot;).on(&#x27;click&#x27;,function()&#123; var obj = $(this); var conload = layer.confirm(&#x27;确定购买吗？&#x27;, function()&#123; layer.close(conload); $(&#x27;#form&#x27;).submit(); &#125;); &#125;) &#125;)&lt;/script&gt; 然后搜到同样的问题，贴上jquery api上的说明： Additional Notes:Forms and their child elements should not use input names or ids that conflict with properties of a form, such as submit, length, or method. Name conflicts can cause confusing failures. For a complete list of rules and to check your markup for these problems, see DOMLint. 表单及其子元素不应使用与表单作为name或id的名称，如submit, length, or method,名称冲突可能会导致令人困惑的失败。对于一个完整的规则列表，检查你的标签对于这些问题，查看DOMLint。 因而吧button的id改成tijiao， 1234567891011121314151617181920212223242526&lt;form role=&quot;form&quot; action=&quot;&quot; method=&quot;post&quot; onsubmit=&quot;return jQuery(this).validationEngine(&#x27;validate&#x27;);&quot; id=&quot;form&quot;&gt; &lt;div class=&quot;box-body&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;m_login_name&quot;&gt;购买备注&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;q_remark&quot; class=&quot;validate[required,maxSize[200]] form-control&quot; placeholder=&quot;请填写购买备注&quot; data-prompt-position=&quot;topLeft&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;tijiao&quot; &gt;立即购买&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script src=&quot;/webui/adminlte/plugins/jQuery/jQuery-2.2.0.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/Skin/public/layer/layer.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(&quot;#tijiao&quot;).on(&#x27;click&#x27;,function()&#123; var obj = $(this); var conload = layer.confirm(&#x27;确定购买吗？&#x27;, function()&#123; layer.close(conload); $(&#x27;#form&#x27;).submit(); &#125;); &#125;) &#125;)&lt;/script&gt; 成功提交表单，so amazing！ 以后务必要注意class和id的命名不要和保留名冲突啦！","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"ThinkPHP分页样式","slug":"ThinkPHP分页样式","date":"2016-08-01T02:55:10.000Z","updated":"2021-04-13T07:35:21.679Z","comments":true,"path":"2016/08/01/59/","link":"","permalink":"http://github.13sai.com/2016/08/01/59/","excerpt":"","text":"分页模块代码位置：/ThinkPHP/Extend/Library/ORG/Util/page.class.php。 如有需要，可自行修改，一般来说，不用修改，可以在Action中设置样式。setConfig可以修改主题样式，rollPage可以限制页码显示数量。 上实例：（会员列表分页） 12345678910111213141516171819202122232425public function memberList()&#123; $m = M(&quot;member&quot;); import(&#x27;ORG.Util.Page&#x27;); $count = $m-&gt;where(&#x27;status = 1&#x27;)-&gt;count(); //查询出总条数 $page=new Page($count,10); $show = $Page-&gt;show(); $Page-&gt;rollPage = 4; //页码显示数量 $page-&gt;setConfig(&#x27;header&#x27;,&#x27;个会员&#x27;); $page-&gt;setConfig(&#x27;prev&#x27;,&#x27;上一页&#x27;); $page-&gt;setConfig(&#x27;next&#x27;,&#x27;下一页&#x27;); $page-&gt;setConfig(&#x27;first&#x27;,&#x27;首页&#x27;); $page-&gt;setConfig(&#x27;last&#x27;,&#x27;尾页&#x27;); $page-&gt;setConfig(&#x27;theme&#x27;,&quot;&lt;span&gt;共%totalRow%%header% %nowPage%/%totalPage% 页 %first% %prePage% %upPage% %linkPage% %downPage% %nextPage% %end%&lt;/span&gt;&quot;); //主题样式 $list = $m-&gt;where(&#x27;status = 1&#x27;) -&gt;order(&#x27;insert_time DESC&#x27;) -&gt;limit($Page-&gt;firstRow.&#x27;,&#x27;.$Page-&gt;listRows)-&gt;select(); $this-&gt;assign(&#x27;list&#x27;,$list); $this-&gt;assign(&#x27;page&#x27;,$show); $this-&gt;display(); &#125; 样式啥的就不说了，都是CSS修改。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://github.13sai.com/tags/ThinkPHP/"}]},{"title":"WebUploader的使用（结合ThinkPHP）","slug":"WebUploader的使用（结合ThinkPHP）","date":"2016-07-18T03:07:54.000Z","updated":"2021-04-13T07:34:39.848Z","comments":true,"path":"2016/07/18/58/","link":"","permalink":"http://github.13sai.com/2016/07/18/58/","excerpt":"","text":"做一个类似社交网站的项目，用到多图上传，然后了解了WebUploader，但第一次使用没有成功，弃之用了swfupload，然后做手机站时，发现如果手机没装flash，这插件用不了，不得不回头，研究用其他的html5+js组件上传，可效果都不如意，自己能力有限，造轮子失败，回头又拾起百度的WebUploader。说实话，蛮喜欢百度的团队，之前用过ueditor，baidumap，echarts等，效果都不错，功能也绰绰有余，但WebUploader着实花了我不少时间，但终究还是成功运用了，才发现自己知识有限，走了一圈弯路。我用的是ThinkPHP框架，先去github下载最新的WebUploader，主要用到的是dist与examples。api文档什么的，直接点击webuploader，讲的还蛮详细。前台代码：&lt;div&nbsp;id=&quot;wrapper&quot;&nbsp;style=&quot;display:&nbsp;none;&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;type=&quot;hidden&quot;&nbsp;name=&quot;s&quot;&nbsp;id=&quot;photos&quot;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;container&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--头部，相册选择和格式选择--&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;uploader&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;queueList&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;dndArea&quot;&nbsp;class=&quot;placeholder&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;filePicker&quot;&gt;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;或将照片拖到这里，单次最多可选9张&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;statusBar&quot;&nbsp;style=&quot;display:none;&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;progress&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&nbsp;class=&quot;text&quot;&gt;0%&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&nbsp;class=&quot;percentage&quot;&gt;&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&lt;div&nbsp;class=&quot;info&quot;&gt;&lt;/div&gt;--&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;btns&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;filePicker2&quot;&gt;&lt;/div&gt;&lt;div&nbsp;class=&quot;uploadBtn&quot;&gt;开始上传&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &lt;/div&gt; &lt;script&nbsp;src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp; src=&quot;/Skin/public/webuploader/dist/webuploader.js&quot;&gt;&lt;/script&gt; //webuploader整个放在/Skin/public/目录 &lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp; src=&quot;/Skin/public/webuploader/examples/image-upload/uploader.js&quot;&gt;&lt;/script&gt;uploader.js改动：//后台处理地址 server:&nbsp;&#39;{:U(&#39;Wap/Weibo/addImages&#39;)}&#39;, //限制图片最多上传9张 fileNumLimit:&nbsp;9, //将图片地址返回前台，以便后期写入数据库uploader.on(&nbsp;&#39;uploadSuccess&#39;,&nbsp;function(&nbsp;file&nbsp;,response&nbsp;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&nbsp;&#39;#&#39;+file.id&nbsp;).addClass(&#39;upload-state-done&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//response&nbsp;=&nbsp;JSON.parse(response)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initVal&nbsp;=&nbsp;$(&#39;#photos&#39;).val();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(initVal&nbsp;==&nbsp;&#39;&#39;){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#photos&#39;).val(response.info);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;#photos&#39;).val(initVal+&#39;|&#39;+response.info);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});后台public&nbsp;function&nbsp;addImages(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import(&quot;ORG.Net.UploadFile&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//导入上传类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$upload&nbsp;=&nbsp;new&nbsp;UploadFile();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$upload-&gt;maxSize&nbsp;&nbsp;=&nbsp;51200000;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$upload-&gt;allowExts&nbsp;&nbsp;=&nbsp;array(&#39;jpg&#39;,&nbsp;&#39;jpeg&#39;,&nbsp;&#39;png&#39;,&nbsp;&#39;gif&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$upload-&gt;savePath&nbsp;=&nbsp;&nbsp;&#39;./Upload/weibo/&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$upload-&gt;saveRule&nbsp;=&nbsp;&nbsp;&#39;uniqid&#39;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!$upload-&gt;upload())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//捕获上传异常&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;error($upload-&gt;getErrorMsg(),&#39;&#39;,3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//取得成功上传的文件信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$uploadList&nbsp;=&nbsp;$upload-&gt;getUploadFileInfo();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$s&nbsp;=&nbsp;&#39;&#39;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for($i=0;$i&lt;count($uploadList);$i++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//限制图片数量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($i&nbsp;&gt;&nbsp;8){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$s&nbsp;.=&nbsp;&#39;/Upload/weibo/&#39;.$uploadList[$i][&#39;savename&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$arr[&#39;info&#39;]&nbsp;=&nbsp;$s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//也可用ajaxReturn，我个人习惯这样写echo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;json_encode($arr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}然后就ok了，样式我就不说了，自己调成需要的样子。是不是很好用呢？","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"ECharts使用","slug":"ECharts使用","date":"2016-07-08T12:22:57.000Z","updated":"2021-04-13T07:30:03.210Z","comments":true,"path":"2016/07/08/56/","link":"","permalink":"http://github.13sai.com/2016/07/08/56/","excerpt":"","text":"最近做项目时，要动态读取数据做成图表，然后听同事提到百度的ECharts，很好用。ECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的 Canvas 类库 ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。ECharts 提供了常规的折线图，柱状图，散点图，饼图，K线图，用于统计的盒形图，用于地理数据可视化的地图，热力图，线图，用于关系数据可视化的关系图，treemap，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。来看看使用，直接上例子：&lt;!DOCTYPE&nbsp;html&gt; &lt;html&gt; &lt;head&gt; &lt;meta&nbsp;charset=&quot;utf-8&quot;&nbsp;/&gt; &lt;meta&nbsp;http-equiv=&quot;X-UA-Compatible&quot;&nbsp;content=&quot;IE=EmulateIE7&quot;&nbsp;/&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;/style&gt; &lt;script&nbsp;src=&quot;echarts.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&nbsp;id=&quot;main&quot;&nbsp;style=&quot;width:&nbsp;600px;height:400px;&quot;&gt;&lt;/div&gt; &lt;script&nbsp;type=&quot;text/javascript&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;基于准备好的dom，初始化echarts实例 &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;myChart&nbsp;=&nbsp;echarts.init(document.getElementById(&#39;main&#39;)); &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指定图表的配置项和数据&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;option&nbsp;=&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltip:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trigger:&nbsp;&#39;axis&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toolbox:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;feature:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataView:&nbsp;{show:&nbsp;true,&nbsp;readOnly:&nbsp;false},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;magicType:&nbsp;{show:&nbsp;true,&nbsp;type:&nbsp;[&#39;line&#39;,&nbsp;&#39;bar&#39;]},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;restore:&nbsp;{show:&nbsp;true},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saveAsImage:&nbsp;{show:&nbsp;true}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;legend:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:[&#39;蒸发量&#39;,&#39;降水量&#39;,&#39;平均温度&#39;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xAxis:&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&#39;category&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;[&#39;1月&#39;,&#39;2月&#39;,&#39;3月&#39;,&#39;4月&#39;,&#39;5月&#39;,&#39;6月&#39;,&#39;7月&#39;,&#39;8月&#39;,&#39;9月&#39;,&#39;10月&#39;,&#39;11月&#39;,&#39;12月&#39;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yAxis:&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&#39;value&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;&#39;水量&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min:&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max:&nbsp;250,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interval:&nbsp;50,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axisLabel:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatter:&nbsp;&#39;{value}&nbsp;ml&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&#39;value&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;&#39;温度&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min:&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max:&nbsp;25,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interval:&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axisLabel:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatter:&nbsp;&#39;{value}&nbsp;°C&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;series:&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&#39;蒸发量&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&#39;bar&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:[2.0,&nbsp;4.9,&nbsp;7.0,&nbsp;23.2,&nbsp;25.6,&nbsp;76.7,&nbsp;135.6,&nbsp;162.2,&nbsp;32.6,&nbsp;20.0,&nbsp;6.4,&nbsp;3.3]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&#39;降水量&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&#39;bar&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:[2.6,&nbsp;5.9,&nbsp;9.0,&nbsp;26.4,&nbsp;28.7,&nbsp;70.7,&nbsp;175.6,&nbsp;182.2,&nbsp;48.7,&nbsp;18.8,&nbsp;6.0,&nbsp;2.3]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&#39;平均温度&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&#39;line&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yAxisIndex:&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:[2.0,&nbsp;2.2,&nbsp;3.3,&nbsp;4.5,&nbsp;6.3,&nbsp;10.2,&nbsp;20.3,&nbsp;23.4,&nbsp;23.0,&nbsp;16.5,&nbsp;12.0,&nbsp;6.2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;&nbsp;&nbsp;}; &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;使用刚指定的配置项和数据显示图表。&nbsp;&nbsp;&nbsp;&nbsp;myChart.setOption(option);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;1.引入echarts.js2.加数据3.调用简单吧！下面看看动态添加数据(php):先看效果：三种数据，年份，家数，方量。输出数据（tp）：public&nbsp;function&nbsp;szsn(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$where[&#39;c_type&#39;]&nbsp;=&nbsp;4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$c&nbsp;=&nbsp;M(&quot;charts&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//取最近7条数据&nbsp;&nbsp;按升序排列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;data111&nbsp;=&nbsp;array_reverse($c-&gt;where($where)-&gt;order(&#39;c_year&nbsp;desc&#39;)-&gt;limit(7)-&gt;getField(&#39;c_year&#39;,true));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;data222&nbsp;=&nbsp;array_reverse($c-&gt;where($where)-&gt;order(&#39;c_year&nbsp;desc&#39;)-&gt;limit(7)-&gt;getField(&#39;c_quota1&#39;,true));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;data333&nbsp;=&nbsp;array_reverse($c-&gt;where($where)-&gt;order(&#39;c_year&nbsp;desc&#39;)-&gt;limit(7)-&gt;getField(&#39;c_quota2&#39;,true));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;display();&nbsp;&nbsp;&nbsp;&nbsp;}前台tpl：&lt;div&nbsp;id=&quot;chart3&quot;&nbsp;data-111=&quot;{:implode(&#39;,&#39;,$data111)}&quot;&nbsp;data-222=&quot;{:implode(&#39;,&#39;,$data222)}&quot;&nbsp;data-333=&quot;{:implode(&#39;,&#39;,$data333)}&quot;&nbsp;//合并数组为字符串style=&quot;width:&nbsp;530px;height:290px;&quot;&nbsp;class=&quot;wd-fl&quot;&gt;&lt;/div&gt;&lt;script&nbsp;src=&quot;/Skin/public/echarts/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;script&nbsp;src=&quot;/Skin/public/echarts/macarons.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;//引用主题&nbsp;&nbsp;官网有多种主题&lt;script&nbsp;type=&quot;text/javascript&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;Chart3&nbsp;=&nbsp;echarts.init(document.getElementById(&#39;chart3&#39;),&#39;macarons&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;data111&nbsp;=&nbsp;$(&#39;#chart3&#39;).attr(&#39;data-111&#39;),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data222&nbsp;=&nbsp;$(&#39;#chart3&#39;).attr(&#39;data-222&#39;),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data333&nbsp;=&nbsp;$(&#39;#chart3&#39;).attr(&#39;data-333&#39;),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr_data111&nbsp;=&nbsp;data111.split(&quot;,&quot;);//拆分字符串为数组&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr_data222&nbsp;=&nbsp;data222.split(&quot;,&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr_data333&nbsp;=&nbsp;data333.split(&quot;,&quot;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;option3&nbsp;=&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tooltip:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trigger:&nbsp;&#39;axis&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;legend:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:[&#39;方量&#39;,&#39;家数&#39;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xAxis:&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&#39;category&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;arr_data111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yAxis:&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&#39;value&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;&#39;万方&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min:&nbsp;1000,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max:&nbsp;3000,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interval:&nbsp;400,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axisLabel:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatter:&nbsp;&#39;{value}&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&#39;value&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;&#39;&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min:&nbsp;40,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max:&nbsp;80,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interval:&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axisLabel:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatter:&nbsp;&#39;{value}家&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;series:&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&#39;方量&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&#39;bar&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:arr_data222&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&#39;家数&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&#39;line&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yAxisIndex:&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:arr_data333&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;使用刚指定的配置项和数据显示图表。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Chart3.setOption(option3);&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;看懂了吗？是不是很方便，你是不是有更好的idea！更多详情，请看echarts","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"css实现文字竖排","slug":"css实现文字竖排","date":"2016-06-21T09:15:50.000Z","updated":"2021-04-13T07:29:32.398Z","comments":true,"path":"2016/06/21/52/","link":"","permalink":"http://github.13sai.com/2016/06/21/52/","excerpt":"","text":"文字竖排会用到writing-mode属性，我们先来看看例子。.shupai{ writing-mode:&nbsp;tb-rl; writing-mode:&nbsp;vertical-rl; -webkit-writing-mode:&nbsp;vertical-rl; color:&nbsp;#3B3533; font-size:&nbsp;20px; } &lt;div&nbsp;class=&quot;shupai&quot;&gt;&lt;p&gt;女王用冰冷的外表保护自己，&lt;/p&gt;&lt;p&gt;&nbsp;&nbsp;&nbsp;&nbsp;其实内心如水，&lt;/p&gt;&lt;p&gt;&nbsp;&nbsp;&nbsp;&nbsp;内在好似绵密的奶油，&lt;/p&gt;&lt;p&gt;&nbsp;&nbsp;&nbsp;&nbsp;极易被热情融化……&lt;/p&gt;&lt;/div&gt;效果如图：语法：writing-mode：horizontal-tb | vertical-rl | vertical-lr |lr-tb|tb-rl默认值：horizontal-tb适用于：除&nbsp; display&nbsp; 属性定义为table-row-group | table-column-group | table-row | table-column之外的所有元素取值：horizontal-tb：水平方向自上而下的书写方式。即 left-right-top-bottom（类似IE私有值lr-tb）vertical-rl：垂直方向自右而左的书写方式。即 top-bottom-right-left（类似IE私有值tb-rl）vertical-lr：垂直方向自左而右的书写方式。即 top-bottom-left-rightlr-tb：左-右，上-下。对象中的内容在水平方向上从左向右流入，后一行在前一行的下面。 所有的字形都是竖直向上的。这种布局是罗马语系使用的（IE）tb-rl：上-下，右-左。对象中的内容在垂直方向上从上向下流入，自右向左。后一竖行在前一竖行的左面。全角字符是竖直向上的，半角字符如拉丁字母或片假名顺时针旋转90度。这种布局是东亚语系通常使用的（IE）用法简单，兼容性不错。只是今天，用writing-mode遇到了奇怪的问题，混凝吐三个字，凝字被土字覆盖了，查了一会没查出原因，把混凝土中凝换成其他字又会正常，奇怪，你知道吗？","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"CSS外边距合并","slug":"CSS外边距合并","date":"2016-06-14T05:28:45.000Z","updated":"2021-04-13T07:29:36.045Z","comments":true,"path":"2016/06/14/51/","link":"","permalink":"http://github.13sai.com/2016/06/14/51/","excerpt":"","text":"外边距合并以前确实遇到过，但从没有深究过，没有在意，前几天同事说到这个问题，便查了查。外边距合并（叠加）是一个相当简单的概念。但是，在实践中对网页进行布局时，它会造成许多混淆。简单地说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。请看下图：当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并。请看下图：尽管看上去有些奇怪，但是外边距甚至可以与自身发生合并。假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并：如果这个外边距遇到另一个元素的外边距，它还会发生合并：这就是一系列的段落元素占用空间非常小的原因，因为它们的所有外边距都合并到一起，形成了一个小的外边距。外边距合并初看上去可能有点奇怪，但是实际上，它是有意义的。以由几个段落组成的典型文本页面为例。第一个段落上面的空间等于段落的上外边距。如果 没有外边距合并，后续所有段落之间的外边距都将是相邻上外边距和下外边距的和。这意味着段落之间的空间是页面顶部的两倍。如果发生外边距合并，段落之间的 上外边距和下外边距就合并在一起，这样各处的距离就一致了。注意：只有普通文档流中块状元素的垂直外边距才会发生外边距合并。行内元素、浮动元素或绝对定位元素之间的外边距不会合并。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"js判断手机访问并跳转到相应页面","slug":"js判断手机访问并跳转到相应页面","date":"2016-06-13T05:56:35.000Z","updated":"2021-04-13T07:31:34.164Z","comments":true,"path":"2016/06/13/50/","link":"","permalink":"http://github.13sai.com/2016/06/13/50/","excerpt":"","text":"方法有很多，列出自己遇到并能成功实现的三种方法。1、利用正则判断客户端function&nbsp;browserRedirect()&nbsp;{&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;sUserAgent=&nbsp;navigator.userAgent.toLowerCase();&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;bIsIpad=&nbsp;sUserAgent.match(/ipad/i)&nbsp;==&nbsp;&quot;ipad&quot;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;bIsIphoneOs=&nbsp;sUserAgent.match(/iphone&nbsp;os/i)&nbsp;==&nbsp;&quot;iphone&nbsp;os&quot;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;bIsMidp=&nbsp;sUserAgent.match(/midp/i)&nbsp;==&nbsp;&quot;midp&quot;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;bIsUc7=&nbsp;sUserAgent.match(/rv:1.2.3.4/i)&nbsp;==&nbsp;&quot;rv:1.2.3.4&quot;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;bIsUc=&nbsp;sUserAgent.match(/ucweb/i)&nbsp;==&nbsp;&quot;ucweb&quot;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;bIsAndroid=&nbsp;sUserAgent.match(/android/i)&nbsp;==&nbsp;&quot;android&quot;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;bIsCE=&nbsp;sUserAgent.match(/windows&nbsp;ce/i)&nbsp;==&nbsp;&quot;windows&nbsp;ce&quot;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;bIsWM=&nbsp;sUserAgent.match(/windows&nbsp;mobile/i)&nbsp;==&nbsp;&quot;windows&nbsp;mobile&quot;; &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bIsIpad&nbsp;||&nbsp;bIsIphoneOs&nbsp;||&nbsp;bIsMidp&nbsp;||&nbsp;bIsUc7&nbsp;||&nbsp;bIsUc&nbsp;||&nbsp;bIsAndroid&nbsp;||&nbsp;bIsCE&nbsp;||&nbsp;bIsWM)&nbsp;{&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;window.location.href=&nbsp;&#39;http://www.dou520.wang&#39;;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;}&nbsp; browserRedirect();2、引用百度siteapp&lt;script&nbsp;src=&quot;http://siteapp.baidu.com/static/webappservice/uaredirect.js&quot;&nbsp;type=&quot;text/javascript&quot;&gt; &lt;/script&gt; &lt;script&nbsp;type=&quot;text/javascript&quot;&gt;uaredirect(&quot;http://www.dou520.wang&quot;);&lt;/script&gt;3.判断，本质同一(function&nbsp;()&nbsp;{var&nbsp;sUserAgent&nbsp;=&nbsp;navigator.userAgent;&nbsp; if&nbsp;(sUserAgent.indexOf(&#39;Android&#39;)&nbsp;&gt;&nbsp;-1&nbsp;||&nbsp;sUserAgent.indexOf(&#39;iPhone&#39;)&nbsp;&gt;&nbsp;-1&nbsp; ||&nbsp;sUserAgent.indexOf(&#39;iPad&#39;)&nbsp;&gt;&nbsp;-1&nbsp;||&nbsp;sUserAgent.indexOf(&#39;iPod&#39;)&nbsp;&gt;&nbsp;-1&nbsp; ||&nbsp;sUserAgent.indexOf(&#39;Symbian&#39;)&nbsp;&gt;&nbsp;-1)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location.href&nbsp;=&nbsp;&#39;http://www.dou520.wang&#39;;&nbsp;&nbsp;&nbsp;&nbsp;//手机端地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;else&nbsp;{} })();方法其实很多，大部分原理都是通过判断客户端是否为移动端浏览器，然后跳转。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"HTML的快速写法：Emmet","slug":"HTML的快速写法：Emmet","date":"2016-06-07T11:34:32.000Z","updated":"2021-04-13T07:31:07.869Z","comments":true,"path":"2016/06/07/49/","link":"","permalink":"http://github.13sai.com/2016/06/07/49/","excerpt":"","text":"今天同事跟我讲了一个写html标签的快捷方法，真的很好用。其实就是是一款很多编辑器都支持的插件Emmet。Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具:基本上，大多数的文本编辑器都会允许你存储和重用一些代码块，我们称之为“片段”。虽然片段能很好地推动你得生产力，但大多数的实现都有这样一个缺点：你必须先定义你得代码片段，并且不能再运行时进行拓展。Emmet把片段这个概念提高到了一个新的层次：你可以设置CSS形式的能够动态被解析的表达式，然后根据你所输入的缩写来得到相应的内容。Emmet语法很简单，如下：&nbsp;E&nbsp;代表HTML标签。 &nbsp;E#id&nbsp;代表id属性。 &nbsp;E.class&nbsp;代表class属性。 &nbsp;E[attr=foo]&nbsp;代表某一个特定属性。&nbsp;E{foo}&nbsp;代表标签包含的内容是foo。 &nbsp;E&gt;N&nbsp;代表N是E的子元素。 &nbsp;E+N&nbsp;代表N是E的同级元素。 &nbsp;E^N&nbsp;代表N是E的上级元素。参考网址，这里很详细：http://www.w3cplus.com/tools/emmet-cheat-sheet.html","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/tags/web/"}]},{"title":"jQuery插件开发","slug":"jQuery插件开发","date":"2016-06-04T13:33:01.000Z","updated":"2021-04-13T07:31:19.038Z","comments":true,"path":"2016/06/04/48/","link":"","permalink":"http://github.13sai.com/2016/06/04/48/","excerpt":"","text":"jQuery自定义了jQuery.extend()和jQuery.fn.extend()方法.其中jQuery.extend()方法能够创建全局函数或者选择器,而jQuery.fn.extend()方法能够创建jQuery对象方法.jQuery插件开发就分为这两种： 一、类级别 类级别你可以理解为扩展jquery类，最明显的例子是$.ajax(...),相当于静态方法。 开发扩展其方法时使用$.extend方法，即jQuery.extend(object);&nbsp;$.extend({ &nbsp;&nbsp;&nbsp;al:function(msg){alert(msg);} });调用很简单，$.al(11);效果如下：二、对象级别 对象级别则可以理解为基于对象的拓展，如$(&quot;#scroll&quot;).slide(...); 这里这个slide呢，就是基于对象的扩展了。 开发扩展其方法时使用$.fn.extend方法，即jQuery.fn.extend(object);&nbsp;$.fn.extend({&nbsp; shtml:&nbsp;function&nbsp;(showhtml)&nbsp;{&nbsp; jQuery(this).html(showhtml);&nbsp; }&nbsp; })调用也很简单，&lt;div&nbsp;class=&quot;msg&quot;&gt;&lt;/div&gt; &lt;script&gt; &nbsp;&nbsp;&nbsp;&nbsp;$(&#39;.msg&#39;).shtml(&#39;111&#39;); &lt;/script&gt;效果如下：这里只是最简单的示例，你可以尝试开发一些复杂美观的插件。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"ThinkPHP的组合查询","slug":"ThinkPHP的组合查询","date":"2016-06-02T04:12:16.000Z","updated":"2021-04-26T03:30:07.876Z","comments":true,"path":"2016/06/02/47/","link":"","permalink":"http://github.13sai.com/2016/06/02/47/","excerpt":"","text":"如果你需要在查询的时候同时偶尔使用字符串却又不希望丢失数组方式的灵活的话，可以考虑使用组合查询。组合查询的主体还是采用数组方式查询，只是加入了一些特殊的查询支持，包括字符串模式查询（_string）、复合查询（_complex）、请求字符串 查询（_query），混合查询中的特殊查询每次查询只能定义一个，由于采用数组的索引方式，索引相同的特殊查询会被覆盖。 一. 字符串模式查询（采用_string 作为查询条件）数组条件还可以和字符串条件混合使用，例如： 12345$User = M(&quot;member&quot;); $map[&#x27;id&#x27;] = array(&#x27;neq&#x27;,5);$map[&#x27;name&#x27;] = &#x27;wzt&#x27;;$map[&#x27;_string&#x27;] = &#x27;status=1 AND score&gt;10&#x27;;$User-&gt;where($map)-&gt;select(); 最后得到的查询条件： 1( `id` != 5 ) AND ( `name` = &#x27;wzt&#x27; ) AND ( status=1 AND score&gt;10 ) 二. 请求字符串查询方式请求字符串查询是一种类似于URL传参的方式，可以支持简单的条件判断 12$map[&#x27;m_id&#x27;] = array(&#x27;gt&#x27;,&#x27;10&#x27;);$map[&#x27;_query&#x27;] = &#x27;status=1&amp;score&gt;60&amp;_logic=or&#x27;; 得到的查询条件是： 1`m_id`&gt;10 AND (`status` = &#x27;1&#x27; OR `score` &gt; &#x27;60&#x27;) 三. 复合查询复合查询相当于封装了一个新的查询条件，然后并入原来的查询条件之中，所以可以完成比较复杂的查询条件组装。 例如:``$where[‘name’] = array(‘like’, ‘%kw%’);$where[‘title’] = array(‘like’,’%kw%’);$where[‘_logic’] = ‘or’;$con[‘_complex’] = $where;$con[‘id’] = array(‘gt’,5); 12查询条件是 ( id &gt; 5) AND ( ( name like ‘%kw%’) OR ( title like ‘%kw%’) ) 123复合查询使用了_complex作为子查询条件来定义，配合之前的查询方式，可以非常灵活的制定更加复杂的查询条件。很多查询方式可以相互转换，例如上面的可以改成 $where[‘id’] = array(‘gt’,5);$where[‘_string’] = ‘ (name like “%kw%”) OR ( title like “%kw%”) ‘; 最后生成的SQL语句是一致的。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://github.13sai.com/tags/ThinkPHP/"}]},{"title":"ThinkPHP的复合查询","slug":"ThinkPHP的复合查询","date":"2016-06-01T07:13:39.000Z","updated":"2021-04-13T07:35:42.931Z","comments":true,"path":"2016/06/01/46/","link":"","permalink":"http://github.13sai.com/2016/06/01/46/","excerpt":"","text":"复合查询相当于封装了一个新的查询条件，然后并入原来的查询条件之中，所以可以完成比较复杂的查询条件组装。 例如查询name和title中有kw且id大于10的数据： 12345$where[&#x27;name&#x27;] = array(&#x27;like&#x27;, &#x27;%kw%&#x27;);$where[&#x27;title&#x27;] = array(&#x27;like&#x27;,&#x27;%kw%&#x27;);$where[&#x27;_logic&#x27;] = &#x27;or&#x27;;$map[&#x27;_complex&#x27;] = $where;$map[&#x27;id&#x27;] = array(&#x27;gt&#x27;,10); 相当于sql语句 1( id &gt; 10) AND ( ( name like &#x27;%kw%&#x27;) OR ( title like &#x27;%kw%&#x27;) ) 其实，很多查询方式可以相互转换，例如上面的查询条件可以改成： 12$where[&#x27;id&#x27;] = array(&#x27;gt&#x27;,10);$where[&#x27;_string&#x27;] = &#x27; (name like &quot;%kw%&quot;) OR ( title like &quot;%kw&quot;) &#x27;; 复合查询相当于封装了一个新的查询条件，然后并入原来的查询条件之中，所以可以完成比较复杂的查询条件组装。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://github.13sai.com/tags/ThinkPHP/"}]},{"title":"js获取当前地理位置与ip","slug":"js获取当前地理位置与ip","date":"2016-05-27T09:12:02.000Z","updated":"2021-04-13T07:31:28.011Z","comments":true,"path":"2016/05/27/45/","link":"","permalink":"http://github.13sai.com/2016/05/27/45/","excerpt":"","text":"pc获取当前地理位置&lt;script&nbsp;type=&quot;text/javascript&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$.getScript(&#39;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js&#39;,&nbsp;function(_result)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(remote_ip_info.ret&nbsp;==&nbsp;&#39;1&#39;)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;alert里面换行用 &nbsp;&nbsp;而非&lt;br&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39; 国家：&#39;&nbsp;+&nbsp;remote_ip_info.country&nbsp;+&nbsp;&#39; 省：&#39;&nbsp;+&nbsp;remote_ip_info.province&nbsp;+&nbsp;&#39; 市：&#39;&nbsp;+&nbsp;remote_ip_info.city&nbsp;+&nbsp;&#39;区：&#39;&nbsp;+&nbsp;remote_ip_info.district&nbsp;+&nbsp;&#39; ISP：&#39;&nbsp;+&nbsp;remote_ip_info.isp&nbsp;+&nbsp;&#39;类型：&#39;&nbsp;+&nbsp;remote_ip_info.type&nbsp;+&nbsp;&#39;其他：&#39;&nbsp;+&nbsp;remote_ip_info.desc);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;没有找到匹配的IP地址信息！&#39;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&lt;/script&gt;获取当前ip&lt;script&gt;var&nbsp;url&nbsp;=&nbsp;&#39;http://chaxun.1616.net/s.php?type=ip&amp;output=json&amp;callback=?&amp;_=&#39;&nbsp;+&nbsp;Math.random();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$.getJSON(url,&nbsp;function(data)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(data.Ip);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&lt;/script&gt;","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"去除a链接的虚线框","slug":"去除a链接的虚线框","date":"2016-05-18T04:00:27.000Z","updated":"2020-12-09T10:35:46.028Z","comments":true,"path":"2016/05/18/43/","link":"","permalink":"http://github.13sai.com/2016/05/18/43/","excerpt":"","text":"a链接上的虚线框非常常见，而且真的非常难看。如图，如何去除呢？只需要加一行代码，完美解决。a{ blr:expression(this.onFocus=this.blur());&nbsp;/*for&nbsp;IE&nbsp;*/&nbsp; outline:none;&nbsp;/*for&nbsp;FF&nbsp;*/&nbsp; }谷歌系还有一个输入框高亮显示的智能模式，其实也不怎么好看，去除加入：input,textarea{outline:&nbsp;none;}","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"鲜为人知的z-index","slug":"鲜为人知的z-index","date":"2016-05-07T06:33:41.000Z","updated":"2021-04-13T07:28:31.144Z","comments":true,"path":"2016/05/07/42/","link":"","permalink":"http://github.13sai.com/2016/05/07/42/","excerpt":"","text":"z-index一般理解就是设置标签在z轴先后顺序，z-index值大的显示在最前面，小的则会被遮挡，真的是这样吗？我们来一探究竟！z-index可以设置成三个值：默认值auto。数值。指示层叠级数，可以是负值。inherit。继承父元素。层叠顺序&nbsp;stacking orderHTML文档中的每个元素都能在文档中其它元素的之前或者之后。这就是所谓的层叠顺序。层叠顺序不是z-index独有的，每个元素都有层叠顺序，元素渲染的先后顺序跟它有很大关系。当元素发生层叠时，元素的层级高的会优先显示在上面，层级一样的则会根据dom的先后顺序进行渲染，后面的会覆盖前面的。试试看不用z-index来改变元素层叠顺序，&lt;style&gt; &nbsp;&nbsp;&nbsp;&nbsp;#box1{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background:&nbsp;red; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;200px; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;200px; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;display:inline-block; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;#box2{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background:&nbsp;yellow; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;200px; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;300px; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;margin-top:-200px; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/style&gt; &lt;div&nbsp;id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div&nbsp;id=&quot;box2&quot;&gt;&lt;/div&gt;这里只做了细微的修改，就是给box1加了一个display:inline-block;的样式，从七阶图中看出，display：block的元素的层叠水平低于display：inline-block的元素，所以浏览器就将box2渲染到box1上面。层叠上下文&nbsp;stacking context一组拥有公共父级的元素在层叠顺序中一起上移或者下移被称为层叠上下文。透彻的理解层叠上下文是真正掌握z-index和层叠顺序如何工作的关键所在。每个层叠上下文有一个单独的HTML元素作为它的根元 素。当一个新的层叠上下文在一个元素上形成的时候，层叠上下文将其所有的子元素都限制在层叠顺序的一个特定位置。这意味着如果一个元素被层叠 顺序底部的一个层叠上下文所包含，将没有办法将其置于另一个不同的具有更高层叠顺序的层叠上下文中包含的元素之前，即便这个元素有无限大的z-index值。在一个元素上形成层叠上下文有如下方式：当一个元素是文档的根元素（&lt;html&gt;元 素）当一个元素有除static之外的position属性值且z-index值不为auto当一个元素有小于1的opacity值当一个元素的transform不等于none前两种形成层叠上下文的方式很有意义，且一般Web开发者都能够理解（即使他们不知道它们的叫法）。结合七阶图，最下层background便是建立在层叠上下文的基础上的，也就是说在层叠上下文中，所有的元素都会渲染在该元素的层叠上下文背景和边框上面；因而在block、float元素等不存在层级上下文的元素中，当子元素设置z-index为负时，子元素会被父元素遮挡。&lt;style&gt; &nbsp;&nbsp;&nbsp;&nbsp;#box1{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position:&nbsp;relative; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;200px; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;200px; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background:&nbsp;red; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;#box2{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position:&nbsp;relative; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z-index:-1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;100px; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;300px; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background:&nbsp;yellow; &nbsp;&nbsp;&nbsp;&nbsp;} &lt;/style&gt; &nbsp; &lt;div&nbsp;id=&quot;box1&quot;&gt; &nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt;这里，box并没有创建层叠上下文，当子元素box2设置z-index:-1时，box2所在的层叠上下文是根元素，即html根标签，根据七阶图可以看出，box2会渲染在html标签上面，box1(z-index:auto)下面，所以box2被遮挡了。那么怎么解决这个问题呢？简单吧，为box1建立一个层叠上下文（比如设置z-index:1;）即可，box1中的元素无论z-index是负的多少，都会显示在box1的背景之上，如图：这里我用了前面说的的第一种方式去创建层叠上下文，即定位元素中z-index不为auto的元素会建立层叠上下文。为什么box1的z-index小于box2的z-index，box2却显示在box1上面呢？层叠水平仅在同一父级层叠上下文中进行比较，即层叠上下文box1中的子元素的层叠水平不会和另一个层叠上下文中的元素进行比较，当然也不会和box1自己比较。所以文章开头的问题，答案是否定的。总结：理解七阶图z-index仅在设置position不等于static的元素中有效z-index层叠水平的比较仅限于同一级别的层叠上下文中","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"js与PHP跳出循环","slug":"js与PHP跳出循环","date":"2016-04-25T07:02:38.000Z","updated":"2021-04-13T07:31:44.817Z","comments":true,"path":"2016/04/25/41/","link":"","permalink":"http://github.13sai.com/2016/04/25/41/","excerpt":"","text":"javascript先看break：&lt;script&gt;for(var i=0;i&lt;=10;i++){ &nbsp; document.write(i); &nbsp; if(i==5){break;}}&lt;/script&gt;输出的结果为：12345，当i的值等于5的时候直接通过break跳出了循环，不再继续往下运行。再来看continue:&lt;script&gt;for(var i=0;i&lt;=10;i++){ &nbsp; if(i==5){continue;} &nbsp; document.write(i);}&lt;/script&gt;输出的结果为：1234678910，当i的值等于5的时候跳了过去继续向下执行循环。最后来看return，return只能出现在函数里面，如果出现在上面的实例里的for循环里会报错，而return出现在函数里的作用就是即使函数下面还有内容也不会再执行了。&lt;script&gt;if (username==&quot;&quot;){ &nbsp; alert(&quot;请输入用户名&quot;); &nbsp; return false;}if(qq==&quot;&quot;){ &nbsp; alert(&quot;请输入QQ&quot;); &nbsp; return false;}&lt;/script&gt;当username为空时，就不会再向下执行。此外，break 语句和 continue 语句都可以与有标签的语句联合使用，返回代码中的特定位置。通常，当循环内部还有循环时，会这样做，例如：var&nbsp;iNum&nbsp;=&nbsp;0; outermost:for&nbsp;(var&nbsp;i=0;&nbsp;i&lt;10;&nbsp;i++)&nbsp;{&nbsp;&nbsp;for&nbsp;(var&nbsp;j=0;&nbsp;j&lt;10;&nbsp;j++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;==&nbsp;5&nbsp;&amp;&amp;&nbsp;j&nbsp;==&nbsp;5)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;outermost;&nbsp;&nbsp;}&nbsp;&nbsp;iNum++;&nbsp;&nbsp;}} alert(iNum); //输出&nbsp;&quot;55&quot;在上面的例子中，标签 outermost 表示的是第一个 for 语句。正常情况下，每个 for 语句执行 10 次代码块，这意味着iNum++ 正常情况下将被执行 100 次，在执行完成时，iNum 应该等于 100。这里的 break语句有一个参数，即停止循环后要跳转到的语句的标签。这样 break 语句不止能跳出内部 for 语句（即使用变量 j 的语句），还能跳出外部for 语句（即使用变量 i 的语句）。因此，iNum 最后的值是 55，因为当 i 和 j 的值都等于 5 时，循环将终止。PHPcontinuecontinue是用来用在循环结构中，控制程序放弃本次循环continue语句之后的代码并转而进行下一次循环。如果在非循环结构中(例如if语句中，switch语句中)使用continue，程序将会出错。例如在下面的这段PHP代码片段中：&lt;?phpfor($i&nbsp;=&nbsp;1;$i&nbsp;&lt;=&nbsp;100;&nbsp;$i++&nbsp;){if($i&nbsp;%&nbsp;3&nbsp;==&nbsp;0&nbsp;||&nbsp;$i&nbsp;%&nbsp;7&nbsp;==&nbsp;0){continue;}&amp;&nbsp;#160;&nbsp;&nbsp;else{echo”$i&nbsp;&lt;br/&gt;”;}}?&gt;输出100以内，既不能被7整除又不能被3整除的那些自然数，循环中先用if条件语句判断那些能被整除的数，然后执行 continue，就直接进入了下个循环。不会执行下面的输出语句了。breakbreak是被用在上面所提的各种循环和switch语句中的。作用是跳出当前的语法结构，执行下面的语句。break语句可以带一个参数n，表示跳出循环的层数，如果要跳出多重循环的话，可以用n来表示跳出的层数，如果不带参数默认是跳出本重循环。看下面这个多重循环嵌套的例子：for($i&nbsp;=&nbsp;1;$i&nbsp;&lt;=&nbsp;10;&nbsp;$i++&nbsp;){&nbsp;&nbsp;for($j&nbsp;=&nbsp;1;$j&nbsp;&lt;=&nbsp;10;$j++){&nbsp;&nbsp;&nbsp;&nbsp;$m&nbsp;=&nbsp;$i&nbsp;&nbsp;$i&nbsp;+&nbsp;$j&nbsp;&nbsp;$j;&nbsp;&nbsp;&nbsp;&nbsp;echo”$m&nbsp;&lt;br/&gt;”;&nbsp;&nbsp;&nbsp;&nbsp;if($m&nbsp;&lt;&nbsp;90&nbsp;||&nbsp;$m&nbsp;&gt;&nbsp;190)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;2;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}}这里使用了break 2跳出了两重循环，将2去掉，得到的结果是完全不一样的。如果不使用参数，跳出的只是本次循环，第一层循环会继续执行下去。exitexit是用来结束程序执行的。可以用在任何地方，本身没有跳出循环的含义。exit可以带一个参数，如果参数是字符串，PHP将会直接把字符串输出，如果参数是integer整形（范围是0-254），那个参数将会被作为结束状态使用。&lt;?phpfor($i&nbsp;=&nbsp;1000;$i&nbsp;&gt;=&nbsp;1&nbsp;;&nbsp;$i–&nbsp;){&nbsp;&nbsp;if(&nbsp;sqrt($i)&nbsp;&gt;=&nbsp;29){&nbsp;&nbsp;&nbsp;&nbsp;echo”$i&nbsp;&lt;br/&gt;”;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;exit;&nbsp;&nbsp;}}echo”本行将不会被输出”;?&gt;例子中直接在从循环里结束了代码的运行，这样会导致后面的代码都不会被执行，如果是在一个php web 页面里面，甚至连exit后面的html代码都不会被输出。returnreturn 语句是用来结束一段代码，并返回一个参数的。可以从一个函数里调用，也可以从一个include()或者require()语句包含的文件里来调用，也可以是在主程序里调用，如果是在函数里调用程序将会马上结束运行并返回参数，如果是include()或者require()语句包含的文件中被调用，程序执行将会马上返回到调用该文件的程序，而返回值将作为include()或者require()的返回值。而如果是在主程序中调用，那么主程序将会马上停止执行&lt;?phpfor($i&nbsp;=&nbsp;1000;$i&nbsp;&gt;=&nbsp;1&nbsp;;&nbsp;$i–&nbsp;){&nbsp;&nbsp;if(&nbsp;sqrt($i)&nbsp;&gt;=&nbsp;29){&nbsp;&nbsp;&nbsp;&nbsp;echo”$i&nbsp;&lt;br/&gt;”;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;}}echo”本行将不会被输出”;?&gt;和上面使用exit的效果是一样的。在循环结束条件，自然跳出。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"wamp设置本地虚机及域名重定向","slug":"wamp设置本地虚机及域名重定向","date":"2016-04-15T01:17:12.000Z","updated":"2021-04-26T03:31:47.824Z","comments":true,"path":"2016/04/15/40/","link":"","permalink":"http://github.13sai.com/2016/04/15/40/","excerpt":"","text":"1.打开 wamp里打开httpd.conf文件（wamp/bin/apache/apache2.4.9/conf）搜索&nbsp;“Include conf/extra/httpd-vhosts.conf”，确保前面没有 # 注释符，也就是确保引入了 vhosts 虚拟主机配置文件,访问此IP的域名将全部指向 vhosts.conf 中的第一个虚拟主机。这一步千万不能丢。 2.打开C:/WINDOWS/system32/drivers/etc目录下的 hosts ，加入 127.0.0.1 www.a.com（或者www.b.com,s1,你想设成什么就设成什么） hosts文件是用来解析的，你在浏览器里输入一个域名www.a.com，第一个就是找hosts文件里有没有www.a.com对应的解析记录，找不到再找DNS。 3.在虚拟主机设置文件D:/wamp/wamp/bin/apache/apache2.4.9/conf/extra的httpd-vhosts.conf里设置： 删除 NameVirtualHost *:80 前面的 ##，这样就启用了 vhosts.conf ，默认的httpd.conf默认配置失效。（其实这部分可忽略，现在的版本都有wamp3了，这些新版本中，下面的操作就默认打开了NameVirtualHost 。）虚拟主机配置将只设置在 httpd-vhosts.conf 里。 &lt;VirtualHost *:80&gt;（如果你用的是其他端口修改80即可，我用的是8080端口） &nbsp; &nbsp; DocumentRoot &quot;D:/wamp/wamp/wwwroot&quot; （不可接受中文文件夹） &nbsp; &nbsp; ServerName www.a.com（与第二步中域名保持一致） &nbsp;&nbsp;&nbsp; &nbsp;&lt;Directory /&gt;（设置DocumentRoot可以接受其他盘文件夹）&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Options Indexes FollowSymLinks&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Order allow,deny&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Allow from all&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Require all granted&nbsp; &lt;/Directory&gt; &lt;/VirtualHost&gt; 这样就完成了，浏览器输入www.a.com,如果你用的是8080，那就输入www.a.com:8080。当然也可以设置很多，重复第二步第三步即可。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"wamp","slug":"wamp","permalink":"http://github.13sai.com/tags/wamp/"}]},{"title":"评论实时刷新效果","slug":"评论实时刷新效果","date":"2016-04-12T13:21:17.000Z","updated":"2021-04-26T03:42:38.009Z","comments":true,"path":"2016/04/12/39/","link":"","permalink":"http://github.13sai.com/2016/04/12/39/","excerpt":"","text":"话不多说，直接上示例。准备：前台jquery1.8 &nbsp;后台thinkphp3.1 数据库mysql 表comment（字段c_id, m_nick_name, weibo_id, w_content, insert_time, member_id等）html:&lt;ul&nbsp;class=&quot;weibo-menu&quot;&gt; &nbsp;&nbsp;&lt;li&gt;转发&lt;/li&gt; &nbsp;&nbsp;&lt;li&gt;&lt;a&nbsp;class=&quot;pinglun&quot;&nbsp;data-rel=&quot;24&quot;&nbsp;onclick=&quot;getComment(24)&quot;&gt;评论&lt;/a&gt;&lt;/li&gt; &nbsp;&nbsp;&lt;li&gt;赞&amp;nbsp;/li&gt; &lt;/ul&gt; &lt;div&nbsp;class=&quot;comment-module-24&quot;&nbsp;style=&quot;display:none;&quot;&gt; &nbsp;&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;class=&quot;comment-24&quot;&nbsp;placeholder=&quot;想说点什么&quot;/&gt; &nbsp;&nbsp;&lt;div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;class=&quot;am-btn&quot;&nbsp;type=&quot;button&quot;&nbsp;onclick=&quot;getComment(24)&quot;&gt;评论&lt;/button&gt; &nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&lt;div&nbsp;class=&quot;am-padding&nbsp;comment-list-24&quot;&gt;&lt;/div&gt; &lt;/div&gt;js:$(function()&nbsp;{ &nbsp;&nbsp;$(&#39;.pinglun&#39;).on(&#39;click&#39;,&nbsp;function()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//评论列表的显示隐藏 &nbsp;&nbsp;id2&nbsp;=&nbsp;$(this).attr(&#39;data-rel&#39;); &nbsp;&nbsp;$(&#39;.comment-module-&#39;+id2).toggle(); &nbsp;&nbsp;}); &nbsp;&nbsp; }); function&nbsp;getComment(id){&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取对应id&nbsp;&nbsp;&nbsp;&nbsp;comment&nbsp;=&nbsp;$(&#39;.comment-&#39;&nbsp;+&nbsp;id).val();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ajax刷新&nbsp;&nbsp;&nbsp;&nbsp;$.post(&quot;{:U(&#39;getComment&#39;)}&quot;,&nbsp;{&nbsp;w_id:&nbsp;id&nbsp;,&nbsp;w_comment:&nbsp;comment},&nbsp;function(data){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//json格式 &nbsp;&nbsp;data&nbsp;=&nbsp;JSON.parse(data); &nbsp;&nbsp;//初始化变量 &nbsp;&nbsp;html&nbsp;=&nbsp;&#39;&#39;;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;//循环输出评论列表并存入html变量 &nbsp;&nbsp;$.each(data,&nbsp;function(i,&nbsp;item)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;html&nbsp;+=&nbsp;&#39;&lt;div&gt;&nbsp;&#39;+&nbsp;item.m_nick_name&nbsp;+&nbsp;&#39;：&#39;+item.w_content&nbsp;+&nbsp;&#39;&lt;br/&gt;&#39;&nbsp;+&nbsp;item.insert_time&nbsp;+&nbsp;&#39;&lt;/div&gt;&lt;hr/&gt;&#39;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&quot;.comment-list-&quot;+id).html(html);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&#39;.comment-&#39;&nbsp;+&nbsp;id).val(&#39;&#39;);&nbsp;&nbsp;&nbsp;&nbsp;});};后台：public&nbsp;function&nbsp;getComment(){ $c&nbsp;=&nbsp;M(&quot;comment&quot;); $weibo_id&nbsp;=&nbsp;I(&#39;w_id&#39;); $w_content&nbsp;=&nbsp;I(&#39;w_comment&#39;);&nbsp;&nbsp;&nbsp;&nbsp;//判断是否有评论传入 if($w_content&nbsp;==&nbsp;&#39;&#39;){ $list&nbsp;=&nbsp;$c-&gt;where(&quot;weibo_id=%d&quot;,$weibo_id)-&gt;order(&#39;c_id&nbsp;desc&#39;)-&gt;limit(5)-&gt;select(); echo&nbsp;json_encode($list); }else{ $data[&#39;weibo_id&#39;]&nbsp;=&nbsp;$weibo_id; $data[&#39;w_content&#39;]&nbsp;=&nbsp;$w_content; $data[&#39;member_id&#39;]&nbsp;=&nbsp;session(&#39;m_id&#39;); $r&nbsp;=&nbsp;$c-&gt;add($data); $list&nbsp;=&nbsp;$c-&gt;where(&quot;weibo_id=%d&quot;,$weibo_id)-&gt;order(&#39;c_id&nbsp;desc&#39;)-&gt;limit(6)-&gt;select(); echo&nbsp;json_encode($list); } &nbsp;&nbsp;&nbsp;&nbsp;}PS:定义和用法post() 方法通过 HTTP POST 请求从服务器载入数据。语法jQuery.post(url,data,success(data,&nbsp;textStatus,&nbsp;jqXHR),dataType)参数描述url必需。规定把请求发送到哪个 URL。data可选。映射或字符串值。规定连同请求发送到服务器的数据。success(data, textStatus, jqXHR)可选。请求成功时执行的回调函数。dataType可选。规定预期的服务器响应的数据类型。默认执行智能判断（xml、json、script 或 html）。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"多种font-family","slug":"多种font-family","date":"2016-04-06T11:39:04.000Z","updated":"2021-04-26T03:41:13.302Z","comments":true,"path":"2016/04/06/38/","link":"","permalink":"http://github.13sai.com/2016/04/06/38/","excerpt":"","text":"修改一个中英文混合css需求时，看到了以下样式。 1font: 12px/25px &quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;, &quot;宋体&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; 居然设置了这么多字体。然后就查了查，贴上来。 font-family的调用方法: 代码如下: 1234div &#123; font-family:Arial,&#x27;Times New Roman&#x27;,&#x27;Microsoft YaHei&#x27;,SimHei; font:bold 12px/0.75em Arial,&#x27;Times New Roman&#x27;,&#x27;Microsoft YaHei&#x27;,SimHei; &#125; font-family 可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。也就是说，font-family 属性的值是用于某个元素的字体族名称或/及类族名称的一个优先表。浏览器会使用它可识别的第一个值。 根据font-family的字体调用原则我们可以为英文,中文,等两种字体调用不同的字体来渲染。 如:Arial,’Times New Roman’这两种字体不认识中文,只认识英文,所以,这两种字体只能渲染英文数字和一些特殊符号,而页面中的中文就会自动调用第三种字体Microsoft YaHei(PS:假如存在这种字体的话)。 所以,在定义字体的时候把英文的字体写在前面把中文的写在后面。这样，系统就会自动按顺序依次给字用字体，如果当前字体不支持文本，自动换用列表中的下一个字体。 经过测试，IE9、IE9兼容模式（兼容IE8）、Chrome浏览器最新版本（34.0）、 Firefox浏览器最新版本（29.0）支持该font-family属性；但是某些版本的IE浏览器（IE7、IE8）无法实现该font-family属性的要求，还会暴露出一些奇怪的 bug。如在这些版本的浏览器下使用中文字体（比如微软雅黑），需要把该中文字体放到font-family属性的首位，但是会导致英文字体也会使用该中 文字体渲染。即在这些浏览器（IE7、IE8）下不支持在font-family属性中为英文和中文字体分别使用不同的字体。 我改成这样， 1font: 12px/25px &quot;Times New Roman&quot;, &quot;Microsoft Yahei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; 用360兼容模式测了下，IE7，8都没发现文章中说的问题。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"几个常见的jQuery插件","slug":"几个常见的jQuery插件","date":"2016-04-05T05:57:59.000Z","updated":"2020-12-09T10:34:09.537Z","comments":true,"path":"2016/04/05/35/","link":"","permalink":"http://github.13sai.com/2016/04/05/35/","excerpt":"","text":"jQuery插件实在太多，介绍几个自己经常用到的。1.superslide十分强大，也有丰富的官方文档，兼容性不错。选项卡，轮播，下拉菜单，滚动等效果一句js就能搞定。官方网址http://www.superslide2.com2.layer官方文档也很齐全，弹出层效果极佳，各种效果几乎都能找到，iframe层，页面层，tips层，应用自如。官方网址http://layer.layui.com3.fullpage全屏滚动，这个效果很炫，兼容性不是特别好，IE8+。文档http://www.uedsc.com/fullpage.html这里还有更多jQuery效果。http://www.htmleaf.com/ &nbsp;","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"utf-8的BOM头","slug":"utf-8的BOM头","date":"2016-03-29T00:57:43.000Z","updated":"2021-01-26T02:55:12.079Z","comments":true,"path":"2016/03/29/34/","link":"","permalink":"http://github.13sai.com/2016/03/29/34/","excerpt":"","text":"昨天去客户那里，这边有需求便都交由同时处理，可有个需求他仅仅帮我改了几个汉字，便出现了层上多了段空白，两个人调试了下都没发现问题，最后用谷歌开发者工具发现这个div上面多了&amp;#65279，删除它即正常。百度下，发现还真有人遇到，是BOM的原因。确实，这个层多处涉及，我就把它作为一个单独文件引入的，同事直接在记事本里修改，以致保存时自动保存为有BOM的utf-8格式。UTF-8签名（UTF-8 signature）也叫做BOM（Byte Order Mark），是UTF编码方案里用于标识编码的标准标记。BOM，是UTF编码方案里用于标识编码的标准标记，在UTF-16里本来是FF FE，变成UTF-8就成了EF BB BF。这个标记是可选的，因为UTF8字节没有顺序，所以它可以被用来检测一个字节流是否是UTF-8编码的。微软做这种检测，但有些软件不做这种检测， 而把它当作正常字符处理。微软在自己的UTF-8格式的文本文件之前加上了EF BB BF三个字节, windows上面的notepad等程序就是根据这三个字节来确定一个文本文件是ASCII的还是UTF-8的, 然而这个只是微软暗自作的标记, 其它平台上并没有对UTF-8文本文件做个这样的标记。也就是说一个UTF-8文件可能有BOM，也可能没有BOM。修改模版的时候，由于输出页面使用UTF-8编码，那么修改模版的时候如果有加入中文字符的话，必须把文件转成UTF-8编码才能正常显示，这个时候如果所使用的编辑器自动加上了BOM的话，将会造成在页面上输出这三个字符，显示效果就要看浏览器了，一般是一个空行或是一个乱码。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/tags/web/"}]},{"title":"CSS编写二三事","slug":"CSS编写二三事","date":"2016-03-26T11:44:31.000Z","updated":"2020-12-09T10:41:11.418Z","comments":true,"path":"2016/03/26/33/","link":"","permalink":"http://github.13sai.com/2016/03/26/33/","excerpt":"","text":"大约工作两个月后，感觉编写CSS样式有点混乱，便搜集了文章，结合自己的经验，整理如下。 一、CSS书写顺序（推荐） 位置属性(position, top, right, z-index, display, float等) 大小(width, height, padding, margin) 文字系列(font, line-height, letter-spacing, color- text-align等) 背景(background, border等) 其他(animation, transition等) 其实也很好理解，先定位，接着控制大小，然后编写，再是美化背景，最后其他属性。 个人习惯把背景写在文字前。 二、CSS书写规范 缩写属性 CSS中部分属性是可以缩写的，比如padding,border,font等，缩写精简代码同时又能提高用户的阅读体验。 简写命名 简写类名，前提是要让人看懂你的命名。 另外颜色代码是可以缩写的，我们就尽量缩写吧，提高用户体验为主。 连字符CSS选择器命名规范 长名称或词组可以使用中横线来为选择器命名。 不建议使用“_”下划线来命名CSS选择器，为什么呢？ 输入的时候少按一个shift键； 浏览器兼容问题 （比如使用_tips的选择器命名，在IE6是无效的） 能良好区分JavaScript变量命名（JS变量命名是用“_”） 不要滥用id id一般在一个页面是唯一的，不能多次使用，而class可以重复使用，另外id的优先级优先于class，所以id应该按需使用，不能滥用。 为选择器添加状态前缀 有时候可以给选择器添加一个表示状态的前缀，让语义更明了，比如添加了“.is-”前缀。 三、CSS命名规范（常见）```头：header内容：content/container尾：footer导航：nav侧栏：sidebar登录条：loginbar标志：logo广告：banner页面主体：main热点：hot下载：download子导航：subnav菜单：menu子菜单：submenu搜索：search友情链接：friendlink页脚：footer版权：copyright滚动：scroll内容：content标签：tags文章列表：list提示信息：msg小技巧：tips栏目标题：title加入：joinus指南：guide服务：service注册：regsiter状态：status投票：vote合作伙伴：partner 注释的写法:/* Header /内容/ End Header */ 四、注意事项: 定义CSS字符编码@charset “utf-8” 一律小写 不加下划线 命名尽量用英文，尽量不缩写，除非一看就明白的单词 添加必要的注释","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"js实现倒计时","slug":"js实现倒计时","date":"2016-03-21T15:10:52.000Z","updated":"2021-04-13T07:31:37.786Z","comments":true,"path":"2016/03/21/31/","link":"","permalink":"http://github.13sai.com/2016/03/21/31/","excerpt":"","text":"setTimeout，setInterval的区别在于setTimeout会在设定的时间后执行一次事件，而setInterval每隔一段设定的时间执行一次事件。原理很简单，就是每秒执行一次事件，并在div中显示。首先来看看setInterval，&lt;div&nbsp;id=&quot;daojishi&quot;&nbsp;data-rel=&quot;80&quot;&gt;&lt;/div&gt; &lt;script&nbsp;src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function&nbsp;daojishi(limit,&nbsp;id){ &nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(id).innerText&nbsp;=&nbsp;getTimerString(limit); } //把时间换算为时分秒并返回function&nbsp;getTimerString(time)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;=&nbsp;Math.floor(time&nbsp;/&nbsp;3600),&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;Math.floor((time&nbsp;%&nbsp;3600)&nbsp;/&nbsp;60),&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;Math.floor((time&nbsp;%&nbsp;3600)&nbsp;%&nbsp;60);&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(time&gt;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;h&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;m&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;s;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;时间到&quot;;}$(function(){&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;hour&nbsp;=&nbsp;60&nbsp;*&nbsp;$(&#39;#daojishi&#39;).attr(&#39;data-rel&#39;);//时间换算为秒&nbsp;&nbsp;&nbsp;&nbsp;setInterval(function(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hour–;//每次时间减一秒&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;daojishi(hour,&nbsp;&#39;daojishi&#39;);&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;1000);}); &lt;/script&gt;接下来是setTimeout，关键的一步，通过自身调用，实现事件的不断执行。&lt;div&nbsp;id=&quot;daojishi&quot;&nbsp;data-rel=&quot;120&quot;&gt;&lt;/div&gt;&lt;script&nbsp;src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt;function&nbsp;daojishi(limit,&nbsp;id){&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(id).innerText&nbsp;=&nbsp;getTimerString(limit);&nbsp;&nbsp;&nbsp;&nbsp;limit--;&nbsp;&nbsp;//每次减去一秒&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(function(){daojishi(limit,&nbsp;id);},&nbsp;1000);//这是关键的一步，通过自身再次调用，实现事件的多次发生} function&nbsp;getTimerString(time)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;=&nbsp;Math.floor(time&nbsp;/&nbsp;3600),&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;Math.floor((time&nbsp;%&nbsp;3600)&nbsp;/&nbsp;60),&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;Math.floor((time&nbsp;%&nbsp;3600)&nbsp;%&nbsp;60);&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(time&gt;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;h&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;m&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;s;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;时间到&quot;;}&lt;/script&gt;&lt;script&gt;var&nbsp;hour&nbsp;=&nbsp;60&nbsp;*&nbsp;$(&#39;#daojishi&#39;).attr(&#39;data-rel&#39;);daojishi(&nbsp;hour,&nbsp;&#39;daojishi&#39;);&lt;/script&gt;需要注意的是时间的换算。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"}]},{"title":"php上传图片并显示","slug":"php上传图片并显示","date":"2016-03-21T13:57:33.000Z","updated":"2021-04-13T07:37:08.150Z","comments":true,"path":"2016/03/21/30/","link":"","permalink":"http://github.13sai.com/2016/03/21/30/","excerpt":"","text":"表单代码&lt;html&gt; &lt;body&gt; &lt;form&nbsp;action=&quot;&quot;&nbsp;method=&quot;post&quot;&nbsp;enctype=&quot;multipart/form-data&quot;&gt; &lt;label&nbsp;for=&quot;file&quot;&gt;Filename:&lt;/label&gt; &lt;input&nbsp;type=&quot;file&quot;&nbsp;name=&quot;file&quot;&nbsp;id=&quot;file&quot;&nbsp;/&gt; &lt;br&nbsp;/&gt; &lt;input&nbsp;type=&quot;submit&quot;&nbsp;name=&quot;submit&quot;&nbsp;value=&quot;提交&quot;&nbsp;/&gt; &lt;/form&gt; &lt;img&nbsp;src=&quot;&lt;?php&nbsp;echo&nbsp;&quot;upload/&quot;&nbsp;.&nbsp;$_FILES[&quot;file&quot;][&quot;name&quot;];?&gt;&quot;&gt; &lt;/body&gt; &lt;/html&gt;注意此处enctype=&quot;multipart/form-data&quot;必不可少。本页上传代码&lt;?php //限制格式、大小 if&nbsp;((($_FILES[&quot;file&quot;][&quot;type&quot;]&nbsp;==&nbsp;&quot;image/gif&quot;)&nbsp;||&nbsp;($_FILES[&quot;file&quot;][&quot;type&quot;]&nbsp;==&nbsp;&quot;image/jpeg&quot;)&nbsp;||&nbsp;($_FILES[&quot;file&quot;][&quot;type&quot;]&nbsp;==&nbsp;&quot;image/pjpeg&quot;))&nbsp;&amp;&amp;&nbsp;($_FILES[&quot;file&quot;][&quot;size&quot;]&nbsp;&lt;&nbsp;20000)){ if&nbsp;($_FILES[&quot;file&quot;][&quot;error&quot;]&nbsp;&gt;&nbsp;0){ echo&nbsp;&quot;Return&nbsp;Code:&nbsp;&quot;&nbsp;.&nbsp;$_FILES[&quot;file&quot;][&quot;error&quot;]&nbsp;.&nbsp;&quot;&lt;br&nbsp;/&gt;&quot;; }else{ echo&nbsp;&quot;图片名称:&nbsp;&quot;&nbsp;.&nbsp;$_FILES[&quot;file&quot;][&quot;name&quot;]&nbsp;.&nbsp;&quot;&lt;br&nbsp;/&gt;&quot;; echo&nbsp;&quot;类型:&nbsp;&quot;&nbsp;.&nbsp;$_FILES[&quot;file&quot;][&quot;type&quot;]&nbsp;.&nbsp;&quot;&lt;br&nbsp;/&gt;&quot;; echo&nbsp;&quot;大小:&nbsp;&quot;&nbsp;.&nbsp;($_FILES[&quot;file&quot;][&quot;size&quot;]&nbsp;/&nbsp;1024)&nbsp;.&nbsp;&quot;&nbsp;Kb&lt;br&nbsp;/&gt;&quot;; echo&nbsp;&quot;临时文件名:&nbsp;&quot;&nbsp;.&nbsp;$_FILES[&quot;file&quot;][&quot;tmp_name&quot;]&nbsp;.&nbsp;&quot;&lt;br&nbsp;/&gt;&quot;; if&nbsp;(file_exists(&quot;upload/&quot;&nbsp;.&nbsp;$_FILES[&quot;file&quot;][&quot;name&quot;])){&nbsp;//判断是否重名 echo&nbsp;$_FILES[&quot;file&quot;][&quot;name&quot;]&nbsp;.&nbsp;&quot;&nbsp;已经存在.&nbsp;&quot;; }else{ move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot;&nbsp;.&nbsp;$_FILES[&quot;file&quot;][&quot;name&quot;]); echo&nbsp;存储位置:&nbsp;&quot;&nbsp;.&nbsp;&quot;upload/&quot;&nbsp;.&nbsp;$_FILES[&quot;file&quot;][&quot;name&quot;]; } } }else{ echo&nbsp;&quot;文件格式不对或超过限制大小&quot;; } ?&gt;这样，我们便能实现简单的图片上传了。当然，文件类比，修改即可。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"css限制字数（单行）","slug":"css限制字数（单行）","date":"2016-03-17T15:25:58.000Z","updated":"2021-04-13T07:29:40.554Z","comments":true,"path":"2016/03/17/29/","link":"","permalink":"http://github.13sai.com/2016/03/17/29/","excerpt":"","text":"经常会遇到字数超出导致布局被破坏的情况，这种情况我们就要限制字数了。而通过动态语言输出限制略显麻烦，倒不如用css属性限制，这个属性叫做text-overflow，使用方便，兼容性不错（IE7+）。&lt;style&nbsp;type=&quot;&quot;text/css&quot;&quot;&gt; .div1{ border:&nbsp;solid&nbsp;1px&nbsp;#000; width:180px; /*以下需要同时使用，否则无效*/ overflow:&nbsp;hidden; text-overflow:&nbsp;ellipsis; white-space:&nbsp;nowrap; } &lt;/style&gt; &lt;div&gt;信用CSS控制文章标题字数用CSS控制文章标题字数&lt;div&gt;&lt;div&nbsp;class=&quot;div1&quot;&gt;用CSS控制文章标题字数用CSS控制文章标题字数用CSS控制文章标题字数用CSS控制文章标题字数&lt;/div&gt;text-overflow:clip修剪文本。ellipsis显示省略符号来代表被修剪的文本。string使用给定的字符串来代表被修剪的文本。white-space:normal默认。空白会被浏览器忽略。pre空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。nowrap文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。pre-wrap保留空白符序列，但是正常地进行换行。pre-line合并空白符序列，但是保留换行符。inherit规定应该从父元素继承 white-space 属性的值。注意，text-overflow只适用于单行且宽度固定时的字数限制。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"常见的HTTP状态码报错及解决方法","slug":"常见的HTTP状态码报错及解决方法","date":"2016-03-14T15:16:06.000Z","updated":"2019-11-26T12:27:16.729Z","comments":true,"path":"2016/03/14/27/","link":"","permalink":"http://github.13sai.com/2016/03/14/27/","excerpt":"","text":"昨天，修改了网站程序，导致网站无法加载，提示错误500，但其子目录可以打开，以前从未遇到这种情况，提交工单给阿里云，回复主机无异常。晚上回来查看，果然是有程序问题，修改后便能正常打开了。 想到平常可能会遇到HTTP报错，便来整理整理常见报错信息。 1、400错误解释： 语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 或者请求参数有误。 问题原因：您所要打开的网页不存在或你填写的身份验证信息不正确。 解决方法：重新尝试，依然错误后提交工单。 2、401错误最常见的出错提示：401 UNAUTHORIZED问题原因：您试图访问受限页面但未经授权时，网站返回HTTP 401错误。错误登录尝试是导致这一错误的主因。解决方法：联系网站管理员获得正确的账户。提交工单联系技术人员处理。 3、403错误最常见的出错提示：403 FORBIDDEN 解释：服务器已经理解请求，但是拒绝执行它。 问题原因：一般是网站没有绑定默认首页或者绑定默认首页错误。解决方法：检查自己程序的默认首页。 4、404错误最常见的出错提示：404 NOT FOUND 解释：请求失败，请求所希望得到的资源未被在服务器上发现。 问题原因：打开网站时找不到你所要求的文件(即网页)，该文件不存在。解决方案：1）请您登陆ftp检查文件或网页是否不存在，把缺少的网页文件恢复。2）提交工单恢复数据。 5、500错误最常见的出错提示：500 SERVER ERROR 解释：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。 问题原因：服务器端的网站程序设计有问题并且服务器没有打开详细错误提示。解决方法：1）下载程序到本地，然后检查程序，上传正确网站程序。2）提交工单联系技术人员处理。 6、503错误解释： 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 问题原因：由于程序网站程序配置不兼容等原因造成应用程序池关闭或者是流量用完了。 解决方法：1）Linux虚拟主机通过后台重启站点即可恢复正常。如果不行请提交工单。2）widows虚拟主机请提交工单联系技术人员处理。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/tags/web/"}]},{"title":"说说html编辑器与调试工具","slug":"说说html编辑器与调试工具","date":"2016-03-04T09:22:41.000Z","updated":"2021-04-13T07:27:38.768Z","comments":true,"path":"2016/03/04/26/","link":"","permalink":"http://github.13sai.com/2016/03/04/26/","excerpt":"","text":"编辑器和调试工具是建站的两大利器，必然会用到，今天来介绍下自己用过的、常见的编辑器。一、编辑器&nbsp;Dreamweaver 编辑Adobe Dreamweaver，简称“DW”，中文名称 &quot;梦想编织者&quot;，是美国MACROMEDIA公司开发的集网页制作和管理网站于一身的所见即所得网页编辑器，DW是第一套针对专业网页设计师特别发展的视觉化网页开发工具，利用它可以轻而易举地制作出跨越平台限制和跨越浏览器限制的充满动感的网页。这是自己用的第一种编辑器，功能强大，编辑、预览、边编辑边预览，自由强大，缺点也很明显，过于荣誉，界面也low。notepad++Notepad++是一款免费但优秀的代码编辑器，运行在Windows环境下，可以支持多种编程语言。它在50多种程序、脚本和标记语言上都有着语法高亮、代码折叠等功能。界面清新简约，很不错，功能对于日常开发绰绰有余。不过不知道为何老是中文乱码，然后体验也就一般般，就用回了DW。notepad++下载evereditEverEdit是一个快速、轻量级和易于扩展的集文本、源代码编辑于一身的高性能纯文本编辑器。它可以运行于Windows XP、Windows Vista、Windows 7、Windows Server 2003+等绝大多数Windows操作系统上，小巧精致的EverEdit是Windows上默认的Notepad很好的替代品。这是自己工作后才遇到的，但确实很好用，体积也很小，不用安装就能用。everedit下载sublime textSublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。还可自定义键绑定，菜单和工具栏。Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。这个没用过，但看界面还蛮好看的，拥趸也不少，应该还不错。二、调试工具1.firebug火狐经典的调试工具，无需多言。2.firefox开发者工具ctrl+shift+I打开，现在用的最多的，很好用，功能也很强大。3.chrome开发者工具ctrl+shift+I打开，也很好用，跟火狐开发者工具大同小异，国内众多浏览器带的就是chrome开发者工具。结语：编辑器很多，调试工具也很多，不需要花太多时间去选择，用习惯就行，用着用着就很顺手了，也会发现越来越多的技巧。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/tags/web/"}]},{"title":"php生成条形码","slug":"php生成条形码","date":"2016-03-02T12:12:38.000Z","updated":"2021-04-13T07:37:03.930Z","comments":true,"path":"2016/03/02/24/","link":"","permalink":"http://github.13sai.com/2016/03/02/24/","excerpt":"","text":"今天同事做网站要用到生成条形码，这是我俩以前都没遇到过的，便百度了下，尝试了下。 百度百科定义：条形码(barcode)是将宽度不等的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符。常见的条形码是由反射率相差很大的黑条（简称条）和白条（简称空）排成平行线的图案。在日常生活中，条形码可以标出物品的生产国、制造厂家、商品名称、生产日期、图书分类号、邮件地点起止、类别、日期等许多信息。 首先去barcodebakery官网下载，注意版本，是否与你用php版本的匹配。 接下来就简单了，解压放到你的目录，输入地址就能看到展示页。 这页很专业有木有，而且也太繁杂了，so，如果只是生成条形码图片展示出来，选择test.php吧。 test.php是另一个简单示例，注意两处，BCGcode39指的是条形码类型，是可换的，比如换成BCGcode128，结合你的需要修改即可。 $code-&gt;parse(‘HELLO’); 这就表明是生成HELLO的条形码，HELLO可换，常量、变量都可以。 就这些了，其实很简单，其实并不难。","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"}]},{"title":"ThinkPHP之where方法","slug":"ThinkPHP之where方法","date":"2016-03-02T05:25:58.000Z","updated":"2021-04-26T03:30:51.362Z","comments":true,"path":"2016/03/02/25/","link":"","permalink":"http://github.13sai.com/2016/03/02/25/","excerpt":"","text":"ThinkPHP where()方法是 Model 类内置方法，用于设置数据库查询或者更新、删除等操作条件，是ThinkPHP精髓部分，也是必须掌握的点。下面以查询为例，了解下强大的where方法。 ThinkPHP支持直接使用字符串作为查询条件，但安全性不高，也可以用对象来作为条件查询，效率不高，所以大多数情况推荐使用数组来作为查询条件，因为会更加安全，更高效。一、使用字符串作为查询条件例如：$User&nbsp;=&nbsp;M(&quot;User&quot;);&nbsp;//&nbsp;实例化User对象,user为表名$User-&gt;where(&#39;id&lt;10&nbsp;AND&nbsp;status=1&#39;)-&gt;select();最后生成的SQL语句是（表前缀为think_）SELECT&nbsp;*&nbsp;FROM&nbsp;think_user&nbsp;WHERE&nbsp;id&lt;1&nbsp;AND&nbsp;status=1二、使用数组作为查询条件（推荐）这种方式是最常用的查询方式，例如：$User&nbsp;=&nbsp;M(&quot;User&quot;);&nbsp;//&nbsp;实例化User对象$condition[&#39;id&#39;]&nbsp;=&nbsp;array(&#39;lt&#39;,1);//lt可换成附表中其他TP运算符$condition[&#39;status&#39;]&nbsp;=&nbsp;1;//&nbsp;把查询条件传入查询方法$User-&gt;where($condition)-&gt;select();最后生成的SQL语句同上。如果进行多字段查询，那么字段之间的默认逻辑关系是AND，如果逻辑关系是OR，通过使用 _logic 定义查询逻辑：$User&nbsp;=&nbsp;M(&quot;User&quot;);&nbsp;$condition[&#39;id&#39;]&nbsp;=&nbsp;array(&#39;lt&#39;,1);$condition[&#39;status&#39;]&nbsp;=&nbsp;1;$condition[&#39;_logic&#39;]&nbsp;=&nbsp;&#39;OR&#39;;//&nbsp;把查询条件传入查询方法$User-&gt;where($condition)-&gt;select();最后生成的SQL语句是SELECT&nbsp;*&nbsp;FROM&nbsp;think_user&nbsp;WHERE&nbsp;`id&lt;1&nbsp;OR&nbsp;`status`=1三、使用对象方式来查询（不推荐）这里以stdClass内置对象为例：$User&nbsp;=&nbsp;M(&quot;User&quot;);&nbsp;//&nbsp;定义查询条件$condition&nbsp;=&nbsp;new&nbsp;stdClass();&nbsp;$condition-&gt;id=&nbsp;array(&#39;lt&#39;,1);&nbsp;$condition-&gt;status=&nbsp;1;&nbsp;$User-&gt;where($condition)-&gt;select();最后生成的SQL语句和上面一样。附：ThinkPHP运算符 与 SQL运算符 对照表TP运算符SQL运算符例子实际查询条件eq=$map[&#39;id&#39;] = array(&#39;eq&#39;,100);$map[&#39;id&#39;] = 100;neq!=$map[&#39;id&#39;] = array(&#39;neq&#39;,100);id != 100gt&gt;$map[&#39;id&#39;] = array(&#39;gt&#39;,100);id &gt; 100elt&lt;=$map[&#39;id&#39;] = array(&#39;elt&#39;,100);id &lt;= 100likelike$map[&#39;username&#39;] = array(&#39;like&#39;,&#39;Admin%&#39;);username like &#39;Admin%&#39;betweenbetween and$map[&#39;id&#39;] = array(&#39;between&#39;,&#39;1,8&#39;);id BETWEEN 1 AND 8not innot in$map[&#39;id&#39;] = array(&#39;not in&#39;,&#39;1,5,8&#39;);id not in(1,5,8)and（默认）and$map[&#39;id&#39;] = array(array(&#39;gt&#39;,1),array(&#39;lt&#39;,10));(id &gt; 1) AND (id &lt; 10)oror$map[&#39;id&#39;] = array(array(&#39;gt&#39;,3),array(&#39;lt&#39;,10), &#39;or&#39;);(id &gt; 3) OR (id &lt; 10)xor（异或）xor两个输入中只有一个是true时，结果为true，否则为false，例子略。1 xor 1 = 0exp综合表达式$map[&#39;id&#39;] = array(&#39;exp&#39;,&#39;in(1,3,8)&#39;);$map[&#39;id&#39;] = array(&#39;in&#39;,&#39;1,3,8&#39;);","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://github.13sai.com/tags/ThinkPHP/"}]},{"title":"让ie7兼容css圆角、阴影","slug":"让ie7兼容css圆角、阴影","date":"2016-02-16T11:44:31.000Z","updated":"2021-04-13T07:23:14.594Z","comments":true,"path":"2016/02/16/19/","link":"","permalink":"http://github.13sai.com/2016/02/16/19/","excerpt":"","text":"首先下载ie-css3.htc脚本，然后在css中加入代码: 例如 .div { border-radius: 15px; box-shadow: 10px 10px 20px #000; behavior: url(ie-css3.htc); } 注意：behavior: url(ie-css3.htc) 中的ie-css3.htc地址必须用绝对路径或者直接传到网站的根目录下面。 IE-CSS3.HTC下载地址： 前往官网 附： •当你使用了这个htc文件后，你的CSS里面，只要写有box-shadow, -moz-box-shadow或-webkit-box-shadow的任何一种，IE就会渲染。 •当使用了这个htc文件后，你不能这样写box-shadow: 0 0 10px red; 而应该是box-shadow: 0px 0px 10px red; 否则IE中会失效。 •不支持RGBA值中的alpha透明度，不支持inset内阴影。 •阴影在IE中只会显示为黑色，不管你设置成其它什么颜色。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"thinkphp安装配置","slug":"thinkphp安装配置","date":"2016-02-02T12:26:01.000Z","updated":"2021-04-13T07:35:46.703Z","comments":true,"path":"2016/02/02/18/","link":"","permalink":"http://github.13sai.com/2016/02/02/18/","excerpt":"","text":"ThinkPHP是一个快速、简单的基于MVC和面向对象的轻量级PHP开发框架，遵循Apache2开源协议发布，从诞生以来一直秉承简洁实用的设计原则，在保持出色的性能和至简的代码的同时，尤其注重开发体验和易用性，并且拥有众多的原创功能和特性，为WEB应用开发提供了强有力的支持。 下载安装： ThinkPHP最新版本可以在官方网站或者Github下载。 然后把下载的压缩包解压到web目录下，运行浏览器输入对应网址，看到tp的笑脸就表示安装成功了。 安装基本无压力。 配置：（我用的是3.2版本） 修改根目录下入口文件index.php，定义应用目录，都有注释，简单明了，然后浏览器刷新，就自动生成了你的app目录。 当然你也可以不改，直接用自动生成的Application开发。 然后开始配置，去app目录下Application\\Common\\Conf","categories":[{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://github.13sai.com/tags/ThinkPHP/"}]},{"title":"数据库设计范式","slug":"数据库设计范式","date":"2016-02-01T14:16:06.000Z","updated":"2021-04-13T07:27:29.721Z","comments":true,"path":"2016/02/01/17/","link":"","permalink":"http://github.13sai.com/2016/02/01/17/","excerpt":"","text":"为了建立冗余较小、结构合理的数据库，设计数据库时常常遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，常常需要满足一定的范式。 在实际开发中最为常见的设计范式有三个： 1．第一范式(确保每列保持原子性) 第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。 第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便，同时也提高了数据库的性能。 2．第二范式(确保表中的每列都和主键相关) 第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。 比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。 这样就产生一个问题：表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。 而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。 这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。 3．第三范式(确保每列都和主键列直接相关,而不是间接相关) 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。 这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。 当然，在实际应用中，不必苛刻地去满足这些范式，具体情况具体对待，未必就强迫数据遵循范式，我们可以参考范式，结合需求来设计数据库，学会“推陈出新”！","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/tags/sql/"}]},{"title":"说说csshack","slug":"说说csshack","date":"2016-01-20T14:31:22.000Z","updated":"2021-04-13T07:27:34.341Z","comments":true,"path":"2016/01/20/16/","link":"","permalink":"http://github.13sai.com/2016/01/20/16/","excerpt":"","text":"一、什么是CSS Hack 不同的浏览器对CSS的解析结果是不同的，因此会导致相同的CSS输出的页面效果不同，这就需要CSS Hack来解决浏览器局部的兼容性问题。而这个针对不同的浏览器写不同的CSS 代码的过程，就叫CSS Hack。 CSS Hack常见的有三种形式：CSS属性Hack、CSS选择符Hack以及IE条件注释Hack， Hack主要针对IE浏览器。 1、属性级Hack：比如IE6能识别下划线”_”和星号” * “，IE7能识别星号” * “，但不能识别下划线”_”，而firefox两个都不能认识。 2、选择符级Hack：比如IE6能识别*html .class{}，IE7能识别*+html .class{}或者*:first-child+html .class{}。 3、IE条件注释Hack：IE条件注释是微软从IE5开始就提供的一种非标准逻辑语句。比如针对所有IE：&lt;!–[if IE]&gt;&lt;!–您的代码–&gt;&lt;![endif]–&gt;，针对IE6及以下版本：&lt;!–[if lt IE 7]&gt;&lt;!–您的代码–&gt;&lt;![endif]–&gt;，这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都 会生效。 PS：条件注释只有在IE浏览器下才能执行，这个代码在非IE浏览下被当做注释视而不见。可以通过IE条件注释载入不同的CSS、JS、HTML和服务器代码等。 二、常用的CSS Hack 代码如下: /* CSS属性级Hack */ color:red; /* 所有浏览器可识别*/ _color:red; /* 仅IE6 识别 */ *color:red; +color:red;&nbsp;*+color:red;[color:red;&nbsp;&nbsp;/* IE6、IE7 识别 */ color:red9; /* IE6、IE7、IE8、IE9 识别 */ color:red9; /* 仅IE9识别 */ color:red!important; /* IE6 不识别!important*/ ------------------------------------------------------------- /* CSS选择符级Hack */ *html #demo { color:red;} /* 仅IE6 识别 */ *+html #demo { color:red;} /* 仅IE7 识别 */ body:nth-of-type(1) #demo { color:red;} /* IE9+、FF3.5+、Chrome、Safari、Opera 可以识别 */ head:first-child+body #demo { color:red; } /* IE7+、FF、Chrome、Safari、Opera 可以识别 */ :root #demo { color:red9; } : /* 仅IE9识别 */ -------------------------------------------------------------- /* IE条件注释Hack */ &lt;!--[if IE]&gt;此处内容只有IE可见&lt;![endif]--&gt;&nbsp; &lt;!--[if IE 6]&gt;此处内容只有IE6.0可见&lt;![endif]--&gt;&nbsp; &lt;!--[if IE 7]&gt;此处内容只有IE7.0可见&lt;![endif]--&gt;&nbsp; &lt;!--[if !IE 7]&gt;此处内容只有IE7不能识别，其他版本都能识别，当然要在IE5以上。&lt;![endif]--&gt; &lt;!--[if gt IE 6]&gt; IE6以上版本可识别,IE6无法识别 &lt;![endif]--&gt; &lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt; &lt;!--[if lt IE 7]&gt; 低于IE7的版本才能识别，IE7无法识别。 &lt;![endif]--&gt; &lt;!--[if lte IE 7]&gt; IE7以及IE7以下版本可识别&lt;![endif]--&gt; &lt;!--[if !IE]&gt;此处内容只有非IE可见&lt;![endif]--&gt; CSS hack利弊 一般情况下，我们尽量避免使用CSS hack，但是有些情况为了顾及用户体验实现向下兼容，不得已才使用hack。比如由于IE8及以下版本不支持CSS3,而我们的项目页面使用了大量CSS3新属性在IE9/Firefox/Chrome下正常渲染，这种情况下如果不使用css3pie或htc或条件注释等方法时,可能就得让IE8-的专属hack出马了。使用hack虽然对页面表现的一致性有好处，但过多的滥用会造成html文档混乱不堪，增加管理和维护的负担。 PS: 说到hack就想到两个词，渐进增强与优雅降级。 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，更关注于内容，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"主流浏览器内核介绍","slug":"主流浏览器内核介绍","date":"2016-01-17T06:09:22.000Z","updated":"2021-04-13T07:29:05.695Z","comments":true,"path":"2016/01/17/15/","link":"","permalink":"http://github.13sai.com/2016/01/17/15/","excerpt":"","text":"作为一名前端开发人员，我觉得很有必要了解主流浏览器的内核。如下是从来自伯乐在线的介绍，有删减。 浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。内核的种类很多，但是常见的浏览器内核可以分这四种：Trident、Gecko、Webkit、Blink。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。 Trident Trident(IE内核)：该内核程序在 1997 年的 IE4 中首次被采用，是微软在 Mosaic（”马赛克”，这是人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览） 代码的基础之上修改而来的，并沿用到 IE11，也被普遍称作 “IE内核”。 Trident实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用 IE 内核而非 IE 的浏览器(壳浏览器)涌现。由于 IE 本身的 “垄断性而使得 Trident 内核的长期一家独大，微软很长时间都并没有更新 Trident 内核，这导致了两个后果——一是 Trident 内核曾经几乎与 W3C 标准脱节（2005年），二是 Trident 内核的大量 Bug 等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为 IE 浏览器不安全的观点，也有很多用户转向了其他浏览器，Firefox 和 Opera 就是这个时候兴起的。非 Trident 内核浏览器的市场占有率大幅提高也致使许多网页开发人员开始注意网页标准和非 IE浏览器的浏览效果问题。 补充：IE 从版本 11 开始，初步支持 WebGL 技术。IE8 的 JavaScript 引擎是 Jscript，IE9 开始用 Chakra，这两个版本区别很大，Chakra 无论是速度和标准化方面都很出色。而Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 Gecko Gecko(Firefox 内核)：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因。 Webkit 一提到 webkit，首先想到的便是 chrome，可以说，chrome 将 Webkit内核 深入人心，殊不知，Webkit 的鼻祖其实是 Safari。 Safari 是苹果公司开发的浏览器，使用了KDE（Linux桌面系统）的 KHTML 作为浏览器的内核，Safari 所用浏览器内核的名称是大名鼎鼎的 WebKit。 Safari 在 2003 年 1 月 7 日首度发行测试版，并成为 Mac OS X v10.3 与之后版本的默认浏览器，也成为苹果其它系列产品的指定浏览器。 如上述可知，WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。当年苹果在比较了 Gecko 和 KHTML 后，选择了后者来做引擎开发，是因为 KHTML 拥有清晰的源码结构和极快的渲染速度。 Chromium/Bink 2008 年，谷歌公司发布了 chrome 浏览器，浏览器使用的内核被命名为 chromium。 chromium fork 自开源引擎 webkit，却把 WebKit 的代码梳理得可读性提高很多，所以以前可能需要一天进行编译的代码，现在只要两个小时就能搞定。因此 Chromium 引擎和其它基于 WebKit 的引擎所渲染页面的效果也是有出入的。谷歌公司还研发了自己的 Javascript 引擎V8，极大地提高了 Javascript 的运算速度。 chromium 问世后，带动了国产浏览器行业的发展。一些基于 chromium 的单核，双核浏览器如雨后春笋般拔地而起，例如 搜狗、360、QQ浏览器等等，无一不是套着不同的外壳用着相同的内核。 然而 2013 年 4 月 3 日，谷歌称将与 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。 webkit 用的好好的，为何要投入到一个新的内核中去呢？ Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支。Google 的 Chromium 项目此前一直使用 WebKit(WebCore) 作为渲染引擎，但出于某种原因，并没有将其多进程架构移植入Webkit。 后来，由于苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Chromium 一直停留在 WebKit，并使用移植的方式来实现和主线 WebKit2 的对接。这增加了 Chromium 的复杂性，且在一定程度上影响了 Chromium 的架构移植工作。 基于以上原因，Google 决定从 WebKit 衍生出自己的 Blink 引擎，将在 WebKit 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 WebKit 的影响，创造一个完全独立的 Blink 引擎。 Presto Presto 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌大本营。 Opera 的一个里程碑作品是 Opera7.0，因为它使用了 Opera Software&nbsp;自主开发的 Presto 渲染引擎，取代了旧版 Opera 4 至 6 版本使用的 Elektra 排版引擎。该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。 Presto 加入了动态功能，例如网页或其部分可随着 DOM 及 Script 语法的事件而重新排版。Presto 在推出后不断有更新版本推出，使不少错误得以修正，以及阅读 Javascript 效能得以最佳化，并成为当时速度最快的引擎。 然而为了减少研发成本，Opera 在 2013 年 2 月宣布放弃 Presto，转而跟随 Chrome 使用 WebKit 分支的 Chromium 引擎作为自家浏览器核心引擎，Presto 内核的 Opera 浏览器版本永远的停留在了 12.17。 移动端 移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。 总结 浏览器内核主要指的是浏览器的渲染引擎，2013 年以前，代表有 Trident（IE），Gecko（firefox），Webkit（Safari chrome 等）以及 Presto（opera)。2013 年，谷歌开始研发 blink 引擎，chrome 28 以后开始使用，而 opera 则放弃了自主研发的 Presto 引擎，投入谷歌怀抱，和谷歌一起研发 blink 引擎，国内各种 chrome系的浏览器（360、UC、QQ、2345 等等）也纷纷放弃 webkit，投入 blink 的怀抱。","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/tags/web/"}]},{"title":"别忘了DOCTYPE声明","slug":"别忘了DOCTYPE声明","date":"2016-01-12T08:40:40.000Z","updated":"2019-11-26T13:16:21.617Z","comments":true,"path":"2016/01/12/13/","link":"","permalink":"http://github.13sai.com/2016/01/12/13/","excerpt":"","text":"&lt;!DOCTYPE&gt; 声明是很容易被忽略的问题，有几次遇到bug，花了很多时间去研究，却没有成功解决，最后的最后，发现是&lt;!DOCTYPE&gt;声明有误。所以切记，遇到浏览器诡异bug时请先检查&lt;!DOCTYPE&gt;` 声明。 下面具体看看w3school上的说明：&lt;!DOCTYPE&gt;声明必须是 HTML 文档的第一行，位于 html 标签之前。 &lt;!DOCTYPE&gt;声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。 在 HTML 4.01 中，&lt;!DOCTYPE&gt;` 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。 HTML5 不基于 SGML，所以不需要引用 DTD。 注释：向 HTML 文档添加 &lt;!DOCTYPE&gt; 声明，这样浏览器才能获知文档类型。&lt;!DOCTYPE&gt; 声明没有结束标签,&lt;!DOCTYPE&gt; 声明对大小写不敏感。 常用的 DOCTYPE 声明HTML 51&lt;!DOCTYPE html&gt; HTML 4.01 Strict该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; HTML 4.01 Transitional该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML 4.01 Frameset该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; XHTML 1.0 Strict该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; XHTML 1.0 Transitional该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; XHTML 1.0 Frameset该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt; XHTML 1.1该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt; 好了，注意 DOCTYPE 声明哟！","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/tags/web/"}]},{"title":"去掉块状元素与img之间间隙","slug":"去掉块状元素与img之间间隙","date":"2015-12-22T09:25:58.000Z","updated":"2021-04-13T07:23:11.313Z","comments":true,"path":"2015/12/22/7/","link":"","permalink":"http://github.13sai.com/2015/12/22/7/","excerpt":"","text":"造成图片与容器下边界有空隙的原因在网上搜了一下，&nbsp;图片文字等inline元素默认是和父级元素的baseline对齐的，而baseline又和父级底边有一定距离（这个距离和&nbsp;font-size，font-family&nbsp;相关，不一定是 3px），所以设置&nbsp;vertical-align:top/bottom/text-top/text-bottom&nbsp;都可以避免这种情况出现。而且不光li，其他的block元素中包含img也会有这个现象。&nbsp;只要vertical-align不取baseline，这个空隙就消失了。请看如下实例(注意::测试工具：ff，chrome，360--支持IE7+)&lt;style&gt;#l1&nbsp;{float:left;background:#000;}#l1&nbsp;ul&nbsp;li&nbsp;{list-style:none;padding:0;margin:0}img&nbsp;{height:100px;}&lt;/style&gt;&lt;div&nbsp;id=&quot;l1&quot;&gt;&nbsp;&nbsp;&nbsp;&lt;ul&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;img&nbsp;src=&quot;30-023131_451.jpg&quot;&nbsp;/&gt;&lt;/li&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;img&nbsp;src=&quot;30-023131_451.jpg&quot;&nbsp;/&gt;&lt;/li&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;img&nbsp;src=&quot;30-023131_451.jpg&quot;&nbsp;/&gt;&lt;/li&gt;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;&lt;/div&gt;我们会发现li底部与img底部有间隙，so bad！第一，给图片img标签display:block。兼容性IE8+，firefox，chrome第二，定义容器里的字体大小为0。font-size:0&nbsp;兼容性IE8+，firefox，chrome第三，定义图片img标签vertical-align:bottom，vertical-align:middle，vertical-align:topimg{vertical-align:bottom}兼容性IE7+，firefox，chrome&nbsp;第四，给li加高度兼容性IE7+，firefox，chrome测试发现，给img加vertical-align效果最佳","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"li设置float时如何控制ul的高度","slug":"li设置float时如何控制ul的高度","date":"2015-12-08T12:22:58.000Z","updated":"2021-04-13T07:33:11.965Z","comments":true,"path":"2015/12/08/5/","link":"","permalink":"http://github.13sai.com/2015/12/08/5/","excerpt":"","text":"在网页设计中，常常需要对li标签做浮动效果，但是在不同浏览器中会遇到兼容性问题，比如IE中会出现ul高度为0的情况，是效果不能达到预期效果。那么这里我就来讲解一下解决这个问题的几种方法。 1.给ul元素设置高度height最直接的办法是给ul元素设置一个高度，即ul标签添加height属性，代码如下: ul { list-style-type: none; height: 30px; /添加高度属性/} 次方法有个缺点：就是元素的高度不能自适应内容。 2.添加一个空的div添加一个空的div，这个div和浮动元素同一级别，且位于浮动元素的最后。这个方法必须要为这个div添加一个clear:both属性，代码如下： 标签1 标签2 标签3 3.添加zoom属性，适用于IE IE支持一个CSS属性zoom，当定义了这个属性之后在 IE 浏览器里面就会自动适应高度了。设置为zoom:1，代码如下： ul { list-style:none; zoom:1; /* 适用于IE */}","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"详解CSS选择器、优先级与匹配原理","slug":"详解CSS选择器、优先级与匹配原理","date":"2015-12-01T11:25:58.000Z","updated":"2021-04-13T07:28:34.124Z","comments":true,"path":"2015/12/01/4/","link":"","permalink":"http://github.13sai.com/2015/12/01/4/","excerpt":"","text":"选择器种类严格来讲，选择器的种类可以分为三种：标签名选择器、类选择器和ID选择器。而所谓的后代选择器和群组选择器只不过是对前三种选择器的扩展应用。而 在标签内写入style=&quot;&quot;的方式，应该是CSS的一种引入方式，而不是选择器，因为根本就没有用到选择器。而一般人们将上面这几种方式结合在一起，所 以就有了5种或6种选择器了。三种基本的选择器类型语法如下：◆标签名选择器，如：p{}，即直接使用HTML标签作为选择器。◆类选择器，如.polaris{}。◆ID选择器，如#polaris{}。注意，ID选择器跟类选择器有很大的不同：一个页面内不能出现相同的ID；再就是ID也是后台开发人员会经常用的，所以前端开发人员应该尽量少的使用。当然跟后台人员的工作配合十分娴熟之后，这些都不会成为限制。扩展选择器◆后代选择器，如.polaris span img{}，后代选贼器实际上是使用多个选择器加上中间的空格来找到具体的要控制标签。◆群组选择器，如div,span,img{}，群组选择器实际上是对CSS的一种简化写法，只不过把有相同定义的不同选择器放在一起，省了很多代码。选择器的优先级别了解了各种选择器后，还有一个重要的知识点就是CSS选择器的优先级。这也就是为什么polaris会遇到文章开头的问题。举个简单的例子：&lt;div&nbsp;class=&quot;polaris&quot;&gt;&nbsp;&lt;span&nbsp;class=&quot;beijixing&quot;&gt;&nbsp;beijixing &nbsp;&lt;/span&gt;&nbsp;&lt;span&gt;&nbsp;polaris &nbsp;&lt;/span&gt;&nbsp;&lt;/div&gt;&nbsp;如果已经把.polaris下面span内的字体设置成红色：.polaris&nbsp;span&nbsp;{color:red;}&nbsp;这时，如果要改变.beijixing的颜色为蓝色，用下面的命令是不能实现的：.beijixing&nbsp;{color:blue;}&nbsp;出现这种情况就是因为后一个命令的优先级不够，两条相互冲突的样式设置，浏览器只会执行优先级较高的那个。那么选择器的优先级是怎么规定的呢？一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。通常我们用1表示标签名选择器的优先级，用10表示类选择 器的优先级，用100标示ID选择器的优先级。比如上例当中 .polaris span {color:red;}的选择器优先级是 10 + 1 也就是11；而 .polaris 的优先级是10；浏览器自然会显示红色的字。理解了这个道理之后下面的优先级计算自是易如反掌：div.test1&nbsp;.span&nbsp;var&nbsp;优先级&nbsp;1+10&nbsp;+10&nbsp;+1 &nbsp;span#xxx&nbsp;.songs&nbsp;li&nbsp;优先级1+100&nbsp;+&nbsp;10&nbsp;+&nbsp;1 &nbsp;#xxx&nbsp;li&nbsp;优先级&nbsp;100&nbsp;+1&nbsp;对于什么情况下使用什么选择器，用不同选择器的原则是：第一：准确的选到要控制的标签；第二：使用最合理优先级的选择器；第三：HTML和CSS代码尽量简洁美观。通常：1、最常用的选择器是类选择器。2、li、td、dd等经常大量连续出现，并且样式相同或者相类似的标签，我们采用类选择器跟标签名选择器结合的后代选择器 .xx li/td/dd {} 的方式选择。3、极少的情况下会用ID选择器，当然很多前端开发人员喜欢header，footer，banner，conntent设置成ID选择器的，因为相同的样式在一个页面里不可能有第二次。在这里不得不提使用在标签内引入CSS的方式来写CSS，即：&lt;div&nbsp;style=&quot;color:red&quot;&gt;polaris&lt;/div&gt;&nbsp;这时候的优先级是最高的。我们给它的优先级是1000，这种写法不推荐使用，特别是对新手来说。这也完全违背了内容和显示分离的思想。DIV+CSS的优点也不能再有任何体现。后代选择器的定位原则在这里介绍一下对于后代选择器，浏览器是如何查找元素的呢？浏览器CSS匹配不是从左到右进行查找，而是从右到左进行查找。比如DIV#divBox p span.red{color:red;}，浏览器的查找顺序如下：先查找html中所有class=&#39;red&#39;的span元素，找到后，再查找其父辈元 素中是否有p元素，再判断p的父元素中是否有id为divBox的div元素，如果都存在则匹配上。浏览器从右到左进行查找的好处是为了尽早过滤掉一些无关的样式规则和元素。比如如下html和css:&lt;style&gt;&nbsp;DIV#divBox&nbsp;p&nbsp;span.red{color:red;} &nbsp;&gt;&lt;style&gt;&nbsp;&lt;body&gt;&nbsp;&lt;div&nbsp;id=&quot;divBox&quot;&gt;&nbsp;&lt;p&gt;&lt;span&gt;s1&lt;/span&gt;&lt;/p&gt;&nbsp;&lt;p&gt;&lt;span&gt;s2&lt;/span&gt;&lt;/p&gt;&nbsp;&lt;p&gt;&lt;span&gt;s3&lt;/span&gt;&lt;/p&gt;&nbsp;&lt;p&gt;&lt;span&nbsp;class=&#39;red&#39;&gt;s4&lt;/span&gt;&lt;/p&gt;&nbsp;&lt;/div&gt;&nbsp;&lt;/body&gt;&nbsp;如果按从左到右查找，哪会先查找到很多不相关的p和span元素。而如果按从左到右的方式进行查找，则首先就查找到&lt;span class=&#39;red&#39;&gt;的元素。firefox称这种查找方式为key selector(关键字查询)，所谓的关键字就是样式规则中最后(最右边)的规则，上面的key就是span.red。简洁、高效的CSS所谓高效的CSS就是让浏览器在查找style匹配的元素的时候尽量进行少的查找，下面列出一些我们常见的写CSS犯一些低效错误：◆不要在ID选择器前使用标签名一般写法：DIV#divBox更好写法：#divBox解释： 因为ID选择器是唯一的，加上div反而增加不必要的匹配。◆不要再class选择器前使用标签名一般写法：span.red更好写法：.red解释：同第一条，但如果你定义了多个.red，而且在不同的元素下是样式不一样，则不能去掉，比如你css文件中定义如下：p.red{color:red;} &nbsp;span.red{color:#ff00ff}&nbsp;如果是这样定义的就不要去掉，去掉后就会混淆，不过建议最好不要这样写◆尽量少使用层级关系一般写法：#divBox p .red{color:red;}更好写法：.red{..}◆使用class代替层级关系一般写法：#divBox ul li a{display:block;}更好写法：.block{display:block;}","categories":[{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]},{"title":"关于mysql数据库可查询不可写入的问题","slug":"关于mysql数据库可查询不可写入的问题","date":"2015-12-01T05:25:58.000Z","updated":"2021-04-13T07:21:09.451Z","comments":true,"path":"2015/12/01/3/","link":"","permalink":"http://github.13sai.com/2015/12/01/3/","excerpt":"","text":"之前不知道改了数据库里的表单，然后就不能写入数据到数据库了，自己研究了一下，实在是弄不清为何。 只得找baidu了，说是木有权限，或者说是字符类型什么的不对。（吐槽一句，有时候百度出来的结果很多，但大同小异，都解决不了自己弄出来的问题），权限是有的，因为之前可以。 那就改了字符类型，仍然不能插入数据。 只能自己捣鼓，恰巧需要新建表，插入一条数据，成功，再插入，失败，发现id相同，换id，成功。 然后就想是不是id的问题。 改id为自增，提示设为主键，改主键为id，改自增，提示id45错误，删除45数据，重新插入，成功。","categories":[{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"}]}],"categories":[{"name":"db","slug":"db","permalink":"http://github.13sai.com/categories/db/"},{"name":"MQ","slug":"MQ","permalink":"http://github.13sai.com/categories/MQ/"},{"name":"debug","slug":"debug","permalink":"http://github.13sai.com/categories/debug/"},{"name":"kubernetes","slug":"kubernetes","permalink":"http://github.13sai.com/categories/kubernetes/"},{"name":"DDD","slug":"DDD","permalink":"http://github.13sai.com/categories/DDD/"},{"name":"note","slug":"note","permalink":"http://github.13sai.com/categories/note/"},{"name":"go","slug":"go","permalink":"http://github.13sai.com/categories/go/"},{"name":"base","slug":"base","permalink":"http://github.13sai.com/categories/base/"},{"name":"php","slug":"php","permalink":"http://github.13sai.com/categories/php/"},{"name":"Docker","slug":"Docker","permalink":"http://github.13sai.com/categories/Docker/"},{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/categories/redis/"},{"name":"linux","slug":"linux","permalink":"http://github.13sai.com/categories/linux/"},{"name":"算法","slug":"算法","permalink":"http://github.13sai.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"cache","slug":"cache","permalink":"http://github.13sai.com/categories/cache/"},{"name":"devops","slug":"devops","permalink":"http://github.13sai.com/categories/devops/"},{"name":"架构","slug":"架构","permalink":"http://github.13sai.com/categories/%E6%9E%B6%E6%9E%84/"},{"name":"网络","slug":"网络","permalink":"http://github.13sai.com/categories/%E7%BD%91%E7%BB%9C/"},{"name":"ci","slug":"ci","permalink":"http://github.13sai.com/categories/ci/"},{"name":"SQL","slug":"SQL","permalink":"http://github.13sai.com/categories/SQL/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://github.13sai.com/categories/ElasticSearch/"},{"name":"js","slug":"js","permalink":"http://github.13sai.com/categories/js/"},{"name":"web","slug":"web","permalink":"http://github.13sai.com/categories/web/"},{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/categories/sql/"},{"name":"vue","slug":"vue","permalink":"http://github.13sai.com/categories/vue/"},{"name":"algorithm","slug":"algorithm","permalink":"http://github.13sai.com/categories/algorithm/"},{"name":"test","slug":"test","permalink":"http://github.13sai.com/categories/test/"},{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/categories/nginx/"},{"name":"microservice","slug":"microservice","permalink":"http://github.13sai.com/categories/microservice/"},{"name":"life","slug":"life","permalink":"http://github.13sai.com/categories/life/"},{"name":"python","slug":"python","permalink":"http://github.13sai.com/categories/python/"},{"name":"windows","slug":"windows","permalink":"http://github.13sai.com/categories/windows/"}],"tags":[{"name":"db","slug":"db","permalink":"http://github.13sai.com/tags/db/"},{"name":"nsq","slug":"nsq","permalink":"http://github.13sai.com/tags/nsq/"},{"name":"go","slug":"go","permalink":"http://github.13sai.com/tags/go/"},{"name":"kubernetes","slug":"kubernetes","permalink":"http://github.13sai.com/tags/kubernetes/"},{"name":"DDD","slug":"DDD","permalink":"http://github.13sai.com/tags/DDD/"},{"name":"note","slug":"note","permalink":"http://github.13sai.com/tags/note/"},{"name":"base","slug":"base","permalink":"http://github.13sai.com/tags/base/"},{"name":"PHP","slug":"PHP","permalink":"http://github.13sai.com/tags/PHP/"},{"name":"Docker","slug":"Docker","permalink":"http://github.13sai.com/tags/Docker/"},{"name":"redis","slug":"redis","permalink":"http://github.13sai.com/tags/redis/"},{"name":"Linux","slug":"Linux","permalink":"http://github.13sai.com/tags/Linux/"},{"name":"算法","slug":"算法","permalink":"http://github.13sai.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"k8s","slug":"k8s","permalink":"http://github.13sai.com/tags/k8s/"},{"name":"架构","slug":"架构","permalink":"http://github.13sai.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"网络","slug":"网络","permalink":"http://github.13sai.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"git","slug":"git","permalink":"http://github.13sai.com/tags/git/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://github.13sai.com/tags/MongoDB/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://github.13sai.com/tags/ElasticSearch/"},{"name":"vue","slug":"vue","permalink":"http://github.13sai.com/tags/vue/"},{"name":"web","slug":"web","permalink":"http://github.13sai.com/tags/web/"},{"name":"mongodb","slug":"mongodb","permalink":"http://github.13sai.com/tags/mongodb/"},{"name":"mysql","slug":"mysql","permalink":"http://github.13sai.com/tags/mysql/"},{"name":"js","slug":"js","permalink":"http://github.13sai.com/tags/js/"},{"name":"Laravel","slug":"Laravel","permalink":"http://github.13sai.com/tags/Laravel/"},{"name":"gin","slug":"gin","permalink":"http://github.13sai.com/tags/gin/"},{"name":"ElementUI","slug":"ElementUI","permalink":"http://github.13sai.com/tags/ElementUI/"},{"name":"shell","slug":"shell","permalink":"http://github.13sai.com/tags/shell/"},{"name":"PHP系列","slug":"PHP系列","permalink":"http://github.13sai.com/tags/PHP%E7%B3%BB%E5%88%97/"},{"name":"algorithm","slug":"algorithm","permalink":"http://github.13sai.com/tags/algorithm/"},{"name":"jwt","slug":"jwt","permalink":"http://github.13sai.com/tags/jwt/"},{"name":"test","slug":"test","permalink":"http://github.13sai.com/tags/test/"},{"name":"nginx","slug":"nginx","permalink":"http://github.13sai.com/tags/nginx/"},{"name":"RPC","slug":"RPC","permalink":"http://github.13sai.com/tags/RPC/"},{"name":"CI","slug":"CI","permalink":"http://github.13sai.com/tags/CI/"},{"name":"consul","slug":"consul","permalink":"http://github.13sai.com/tags/consul/"},{"name":"tcp","slug":"tcp","permalink":"http://github.13sai.com/tags/tcp/"},{"name":"Nginx","slug":"Nginx","permalink":"http://github.13sai.com/tags/Nginx/"},{"name":"jenkins","slug":"jenkins","permalink":"http://github.13sai.com/tags/jenkins/"},{"name":"面试","slug":"面试","permalink":"http://github.13sai.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://github.13sai.com/tags/RabbitMQ/"},{"name":"sql","slug":"sql","permalink":"http://github.13sai.com/tags/sql/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://github.13sai.com/tags/ThinkPHP/"},{"name":"swoole","slug":"swoole","permalink":"http://github.13sai.com/tags/swoole/"},{"name":"LNMP","slug":"LNMP","permalink":"http://github.13sai.com/tags/LNMP/"},{"name":"gulp","slug":"gulp","permalink":"http://github.13sai.com/tags/gulp/"},{"name":"svn","slug":"svn","permalink":"http://github.13sai.com/tags/svn/"},{"name":"SVN","slug":"SVN","permalink":"http://github.13sai.com/tags/SVN/"},{"name":"html","slug":"html","permalink":"http://github.13sai.com/tags/html/"},{"name":"wamp","slug":"wamp","permalink":"http://github.13sai.com/tags/wamp/"},{"name":"python","slug":"python","permalink":"http://github.13sai.com/tags/python/"},{"name":"windows","slug":"windows","permalink":"http://github.13sai.com/tags/windows/"},{"name":"asp","slug":"asp","permalink":"http://github.13sai.com/tags/asp/"},{"name":"css","slug":"css","permalink":"http://github.13sai.com/tags/css/"}]}